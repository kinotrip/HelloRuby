#include "ruby_cocos2dx_auto.hpp"

#include "RubyValueMap.h"
#include "BindingHelper.h"

#include "cocos2d.h"
RBVAL rb_cocos2dx_Ref_release(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Ref* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Ref_release : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->release();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Ref_release : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Ref_retain(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Ref* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Ref_retain : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->retain();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Ref_retain : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Ref_getReferenceCount(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Ref* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Ref_getReferenceCount : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					unsigned int ret = cobj->getReferenceCount();
				value = uint_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Ref_getReferenceCount : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_Ref() {
		
	RBVAL classValue=rb_define_class_bridge("Ref",rb_get_root_class(),true);

	rb_define_method_bridge(classValue,"release",RB_FUNC(rb_cocos2dx_Ref_release));

	

	rb_define_method_bridge(classValue,"retain",RB_FUNC(rb_cocos2dx_Ref_retain));

	

	rb_define_method_bridge(classValue,"getReferenceCount",RB_FUNC(rb_cocos2dx_Ref_getReferenceCount));

   rb_define_method_bridge(classValue,"referenceCount",RB_FUNC(rb_cocos2dx_Ref_getReferenceCount));
	



	TypeTest<cocos2d::Ref> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Ref",classValue);
}
RBVAL rb_cocos2dx_Console_stop(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Console* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Console_stop : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->stop();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Console_stop : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Console_listenOnTCP(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Console* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Console_listenOnTCP : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Console_listenOnTCP : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->listenOnTCP(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Console_listenOnTCP : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Console_listenOnFileDescriptor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Console* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Console_listenOnFileDescriptor : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Console_listenOnFileDescriptor : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->listenOnFileDescriptor(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Console_listenOnFileDescriptor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Console_log(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Console* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Console_log : self ptr is null");return RBNil();}
		if (argc == 1) {
			const char* arg0;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Console_log : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->log(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Console_log : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_Console() {
		
	RBVAL classValue=rb_define_class_bridge("Console",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"stop",RB_FUNC(rb_cocos2dx_Console_stop));

	

	rb_define_method_bridge(classValue,"listenOnTCP",RB_FUNC(rb_cocos2dx_Console_listenOnTCP));

	

	rb_define_method_bridge(classValue,"listenOnFileDescriptor",RB_FUNC(rb_cocos2dx_Console_listenOnFileDescriptor));

	

	rb_define_method_bridge(classValue,"log",RB_FUNC(rb_cocos2dx_Console_log));

	



	TypeTest<cocos2d::Console> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Console",classValue);
}
RBVAL rb_cocos2dx_Texture2D_getMaxT(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_getMaxT : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getMaxT();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_getMaxT : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_getStringForFormat(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_getStringForFormat : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const char* ret = cobj->getStringForFormat();
				value = char_ptr_to_rb_string(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_getStringForFormat : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_initWithImage(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithImage : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			cocos2d::Image* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithImage : Error processing argument 1 ( 2 )");return RBNil(); }
			cocos2d::Texture2D::PixelFormat arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithImage : Error processing argument 2 ( 2 )");return RBNil(); }
			bool ret = cobj->initWithImage(arg0, arg1);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 1) {
			cocos2d::Image* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithImage : Error processing argument 1 ( 1 )");return RBNil(); }
			bool ret = cobj->initWithImage(arg0);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithImage : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_getMaxS(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_getMaxS : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getMaxS();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_getMaxS : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_releaseGLTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_releaseGLTexture : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->releaseGLTexture();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_releaseGLTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_hasPremultipliedAlpha(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_hasPremultipliedAlpha : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->hasPremultipliedAlpha();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_hasPremultipliedAlpha : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_getPixelsHigh(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_getPixelsHigh : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getPixelsHigh();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_getPixelsHigh : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_getBitsPerPixelForFormat(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_getBitsPerPixelForFormat : self ptr is null");return RBNil();}
	do {
		if (argc == 1) {
			cocos2d::Texture2D::PixelFormat arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_getBitsPerPixelForFormat : Error processing argument 1 ( 1 )");return RBNil(); }
			unsigned int ret = cobj->getBitsPerPixelForFormat(arg0);
			RBVAL value = RBNil();
			value = uint_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 0) {
			unsigned int ret = cobj->getBitsPerPixelForFormat();
			RBVAL value = RBNil();
			value = uint_to_rb_value(ret);
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Texture2D_getBitsPerPixelForFormat : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_getName(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_getName : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					unsigned int ret = cobj->getName();
				value = uint_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_getName : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_initWithString(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			const char* arg0;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 1 ( 2 )");return RBNil(); }
			cocos2d::FontDefinition arg1;
			ok &= rb_value_to_FontDefinition(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 2 ( 2 )");return RBNil(); }
			bool ret = cobj->initWithString(arg0, arg1);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 3) {
			const char* arg0;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 1 ( 3 )");return RBNil(); }
			std::string arg1;
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 2 ( 3 )");return RBNil(); }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 3 ( 3 )");return RBNil(); }
			bool ret = cobj->initWithString(arg0, arg1, arg2);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 4) {
			const char* arg0;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 1 ( 4 )");return RBNil(); }
			std::string arg1;
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 2 ( 4 )");return RBNil(); }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 3 ( 4 )");return RBNil(); }
			cocos2d::Size arg3;
			ok &= rb_value_to_ccsize(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 4 ( 4 )");return RBNil(); }
			bool ret = cobj->initWithString(arg0, arg1, arg2, arg3);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 5) {
			const char* arg0;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 1 ( 5 )");return RBNil(); }
			std::string arg1;
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 2 ( 5 )");return RBNil(); }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 3 ( 5 )");return RBNil(); }
			cocos2d::Size arg3;
			ok &= rb_value_to_ccsize(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 4 ( 5 )");return RBNil(); }
			cocos2d::TextHAlignment arg4;
			ok &= rb_value_to_int(argv[4], (int *)&arg4);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 5 ( 5 )");return RBNil(); }
			bool ret = cobj->initWithString(arg0, arg1, arg2, arg3, arg4);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 6) {
			const char* arg0;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 1 ( 6 )");return RBNil(); }
			std::string arg1;
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 2 ( 6 )");return RBNil(); }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 3 ( 6 )");return RBNil(); }
			cocos2d::Size arg3;
			ok &= rb_value_to_ccsize(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 4 ( 6 )");return RBNil(); }
			cocos2d::TextHAlignment arg4;
			ok &= rb_value_to_int(argv[4], (int *)&arg4);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 5 ( 6 )");return RBNil(); }
			cocos2d::TextVAlignment arg5;
			ok &= rb_value_to_int(argv[5], (int *)&arg5);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : Error processing argument 6 ( 6 )");return RBNil(); }
			bool ret = cobj->initWithString(arg0, arg1, arg2, arg3, arg4, arg5);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Texture2D_initWithString : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_setMaxT(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_setMaxT : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_setMaxT : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setMaxT(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("maxT");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_setMaxT : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_drawInRect(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_drawInRect : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Rect arg0;
			ok &= rb_value_to_ccrect(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_drawInRect : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->drawInRect(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_drawInRect : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_getContentSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_getContentSize : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Size ret = cobj->getContentSize();
				value = ccsize_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_getContentSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_setAliasTexParameters(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_setAliasTexParameters : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->setAliasTexParameters();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_setAliasTexParameters : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_setAntiAliasTexParameters(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_setAntiAliasTexParameters : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->setAntiAliasTexParameters();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_setAntiAliasTexParameters : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_generateMipmap(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_generateMipmap : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->generateMipmap();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_generateMipmap : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_getDescription(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_getDescription : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					std::string ret = cobj->getDescription();
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_getDescription : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_getPixelFormat(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_getPixelFormat : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getPixelFormat();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_getPixelFormat : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_setGLProgram(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_setGLProgram : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::GLProgram* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_setGLProgram : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setGLProgram(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("gLProgram");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_setGLProgram : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_getContentSizeInPixels(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_getContentSizeInPixels : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Size& ret = cobj->getContentSizeInPixels();
				value = ccsize_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_getContentSizeInPixels : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_getPixelsWide(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_getPixelsWide : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getPixelsWide();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_getPixelsWide : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_drawAtPoint(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_drawAtPoint : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_drawAtPoint : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->drawAtPoint(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_drawAtPoint : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_getGLProgram(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_getGLProgram : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::GLProgram* ret = cobj->getGLProgram();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::GLProgram>((cocos2d::GLProgram*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_getGLProgram : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_hasMipmaps(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_hasMipmaps : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->hasMipmaps();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_hasMipmaps : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_setMaxS(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Texture2D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_setMaxS : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_setMaxS : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setMaxS(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("maxS");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_setMaxS : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Texture2D_setDefaultAlphaPixelFormat(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::Texture2D::PixelFormat arg0;
		ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Texture2D_setDefaultAlphaPixelFormat : Error processing arguments");return RBNil();}
		cocos2d::Texture2D::setDefaultAlphaPixelFormat(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("defaultAlphaPixelFormat");
				}
				rb_cvar_set_bridge(clazz,propSYM,argv[0]);
		RBVAL value=RBNil();
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Texture2D_setDefaultAlphaPixelFormat : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_Texture2D_getDefaultAlphaPixelFormat(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		int ret = (int)cocos2d::Texture2D::getDefaultAlphaPixelFormat();
		RBVAL value=RBNil();
		value = int_to_rb_value(ret);
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Texture2D_getDefaultAlphaPixelFormat : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_Texture2D_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::Texture2D> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::Texture2D* cobj = new cocos2d::Texture2D();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Texture2D_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Texture2D() {
		
	RBVAL classValue=rb_define_class_bridge("Texture2D",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"getMaxT",RB_FUNC(rb_cocos2dx_Texture2D_getMaxT));

   rb_define_method_bridge(classValue,"maxT",RB_FUNC(rb_cocos2dx_Texture2D_getMaxT));
	

	rb_define_method_bridge(classValue,"getStringForFormat",RB_FUNC(rb_cocos2dx_Texture2D_getStringForFormat));

   rb_define_method_bridge(classValue,"stringForFormat",RB_FUNC(rb_cocos2dx_Texture2D_getStringForFormat));
	

	rb_define_method_bridge(classValue,"initWithImage",RB_FUNC(rb_cocos2dx_Texture2D_initWithImage));

	

	rb_define_method_bridge(classValue,"getMaxS",RB_FUNC(rb_cocos2dx_Texture2D_getMaxS));

   rb_define_method_bridge(classValue,"maxS",RB_FUNC(rb_cocos2dx_Texture2D_getMaxS));
	

	rb_define_method_bridge(classValue,"releaseGLTexture",RB_FUNC(rb_cocos2dx_Texture2D_releaseGLTexture));

	

	rb_define_method_bridge(classValue,"hasPremultipliedAlpha",RB_FUNC(rb_cocos2dx_Texture2D_hasPremultipliedAlpha));

	

	rb_define_method_bridge(classValue,"getPixelsHigh",RB_FUNC(rb_cocos2dx_Texture2D_getPixelsHigh));

   rb_define_method_bridge(classValue,"pixelsHigh",RB_FUNC(rb_cocos2dx_Texture2D_getPixelsHigh));
	

	rb_define_method_bridge(classValue,"getBitsPerPixelForFormat",RB_FUNC(rb_cocos2dx_Texture2D_getBitsPerPixelForFormat));

   rb_define_method_bridge(classValue,"bitsPerPixelForFormat",RB_FUNC(rb_cocos2dx_Texture2D_getBitsPerPixelForFormat));
	

	rb_define_method_bridge(classValue,"getName",RB_FUNC(rb_cocos2dx_Texture2D_getName));

   rb_define_method_bridge(classValue,"name",RB_FUNC(rb_cocos2dx_Texture2D_getName));
	

	rb_define_method_bridge(classValue,"initWithString",RB_FUNC(rb_cocos2dx_Texture2D_initWithString));

	

	rb_define_method_bridge(classValue,"setMaxT",RB_FUNC(rb_cocos2dx_Texture2D_setMaxT));

    rb_define_method_bridge(classValue,"maxT=",RB_FUNC(rb_cocos2dx_Texture2D_setMaxT));
	

	rb_define_method_bridge(classValue,"drawInRect",RB_FUNC(rb_cocos2dx_Texture2D_drawInRect));

	

	rb_define_method_bridge(classValue,"getContentSize",RB_FUNC(rb_cocos2dx_Texture2D_getContentSize));

   rb_define_method_bridge(classValue,"contentSize",RB_FUNC(rb_cocos2dx_Texture2D_getContentSize));
	

	rb_define_method_bridge(classValue,"setAliasTexParameters",RB_FUNC(rb_cocos2dx_Texture2D_setAliasTexParameters));

    rb_define_method_bridge(classValue,"aliasTexParameters=",RB_FUNC(rb_cocos2dx_Texture2D_setAliasTexParameters));
	

	rb_define_method_bridge(classValue,"setAntiAliasTexParameters",RB_FUNC(rb_cocos2dx_Texture2D_setAntiAliasTexParameters));

    rb_define_method_bridge(classValue,"antiAliasTexParameters=",RB_FUNC(rb_cocos2dx_Texture2D_setAntiAliasTexParameters));
	

	rb_define_method_bridge(classValue,"generateMipmap",RB_FUNC(rb_cocos2dx_Texture2D_generateMipmap));

	

	rb_define_method_bridge(classValue,"getDescription",RB_FUNC(rb_cocos2dx_Texture2D_getDescription));

   rb_define_method_bridge(classValue,"description",RB_FUNC(rb_cocos2dx_Texture2D_getDescription));
	

	rb_define_method_bridge(classValue,"getPixelFormat",RB_FUNC(rb_cocos2dx_Texture2D_getPixelFormat));

   rb_define_method_bridge(classValue,"pixelFormat",RB_FUNC(rb_cocos2dx_Texture2D_getPixelFormat));
	

	rb_define_method_bridge(classValue,"setGLProgram",RB_FUNC(rb_cocos2dx_Texture2D_setGLProgram));

    rb_define_method_bridge(classValue,"gLProgram=",RB_FUNC(rb_cocos2dx_Texture2D_setGLProgram));
	

	rb_define_method_bridge(classValue,"getContentSizeInPixels",RB_FUNC(rb_cocos2dx_Texture2D_getContentSizeInPixels));

   rb_define_method_bridge(classValue,"contentSizeInPixels",RB_FUNC(rb_cocos2dx_Texture2D_getContentSizeInPixels));
	

	rb_define_method_bridge(classValue,"getPixelsWide",RB_FUNC(rb_cocos2dx_Texture2D_getPixelsWide));

   rb_define_method_bridge(classValue,"pixelsWide",RB_FUNC(rb_cocos2dx_Texture2D_getPixelsWide));
	

	rb_define_method_bridge(classValue,"drawAtPoint",RB_FUNC(rb_cocos2dx_Texture2D_drawAtPoint));

	

	rb_define_method_bridge(classValue,"getGLProgram",RB_FUNC(rb_cocos2dx_Texture2D_getGLProgram));

   rb_define_method_bridge(classValue,"gLProgram",RB_FUNC(rb_cocos2dx_Texture2D_getGLProgram));
	

	rb_define_method_bridge(classValue,"hasMipmaps",RB_FUNC(rb_cocos2dx_Texture2D_hasMipmaps));

	

	rb_define_method_bridge(classValue,"setMaxS",RB_FUNC(rb_cocos2dx_Texture2D_setMaxS));

    rb_define_method_bridge(classValue,"maxS=",RB_FUNC(rb_cocos2dx_Texture2D_setMaxS));
	

	

	rb_define_singleton_method_bridge(classValue,"setDefaultAlphaPixelFormat",RB_FUNC(rb_cocos2dx_Texture2D_setDefaultAlphaPixelFormat));

    rb_define_singleton_method_bridge(classValue,"defaultAlphaPixelFormat=",RB_FUNC(rb_cocos2dx_Texture2D_setDefaultAlphaPixelFormat));
	
	

	rb_define_singleton_method_bridge(classValue,"getDefaultAlphaPixelFormat",RB_FUNC(rb_cocos2dx_Texture2D_getDefaultAlphaPixelFormat));

   rb_define_singleton_method_bridge(classValue,"defaultAlphaPixelFormat",RB_FUNC(rb_cocos2dx_Texture2D_getDefaultAlphaPixelFormat));
	

	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_Texture2D_constructor));

	TypeTest<cocos2d::Texture2D> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Texture2D",classValue);
}
RBVAL rb_cocos2dx_Touch_getPreviousLocationInView(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Touch* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Touch_getPreviousLocationInView : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getPreviousLocationInView();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Touch_getPreviousLocationInView : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Touch_getLocation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Touch* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Touch_getLocation : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getLocation();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Touch_getLocation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Touch_getDelta(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Touch* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Touch_getDelta : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getDelta();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Touch_getDelta : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Touch_getStartLocationInView(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Touch* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Touch_getStartLocationInView : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getStartLocationInView();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Touch_getStartLocationInView : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Touch_getStartLocation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Touch* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Touch_getStartLocation : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getStartLocation();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Touch_getStartLocation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Touch_getID(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Touch* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Touch_getID : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getID();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Touch_getID : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Touch_setTouchInfo(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Touch* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Touch_setTouchInfo : self ptr is null");return RBNil();}
		if (argc == 3) {
			int arg0;
			float arg1;
			float arg2;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			ok &= rb_value_to_float(argv[1], &arg1);
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Touch_setTouchInfo : Error processing argument 3 ( 3 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTouchInfo(arg0, arg1, arg2);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Touch_setTouchInfo : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Touch_getLocationInView(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Touch* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Touch_getLocationInView : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getLocationInView();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Touch_getLocationInView : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Touch_getPreviousLocation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Touch* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Touch_getPreviousLocation : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getPreviousLocation();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Touch_getPreviousLocation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Touch_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::Touch> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::Touch* cobj = new cocos2d::Touch();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Touch_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Touch() {
		
	RBVAL classValue=rb_define_class_bridge("Touch",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"getPreviousLocationInView",RB_FUNC(rb_cocos2dx_Touch_getPreviousLocationInView));

   rb_define_method_bridge(classValue,"previousLocationInView",RB_FUNC(rb_cocos2dx_Touch_getPreviousLocationInView));
	

	rb_define_method_bridge(classValue,"getLocation",RB_FUNC(rb_cocos2dx_Touch_getLocation));

   rb_define_method_bridge(classValue,"location",RB_FUNC(rb_cocos2dx_Touch_getLocation));
	

	rb_define_method_bridge(classValue,"getDelta",RB_FUNC(rb_cocos2dx_Touch_getDelta));

   rb_define_method_bridge(classValue,"delta",RB_FUNC(rb_cocos2dx_Touch_getDelta));
	

	rb_define_method_bridge(classValue,"getStartLocationInView",RB_FUNC(rb_cocos2dx_Touch_getStartLocationInView));

   rb_define_method_bridge(classValue,"startLocationInView",RB_FUNC(rb_cocos2dx_Touch_getStartLocationInView));
	

	rb_define_method_bridge(classValue,"getStartLocation",RB_FUNC(rb_cocos2dx_Touch_getStartLocation));

   rb_define_method_bridge(classValue,"startLocation",RB_FUNC(rb_cocos2dx_Touch_getStartLocation));
	

	rb_define_method_bridge(classValue,"getId",RB_FUNC(rb_cocos2dx_Touch_getID));

   rb_define_method_bridge(classValue,"id",RB_FUNC(rb_cocos2dx_Touch_getID));
	

	rb_define_method_bridge(classValue,"setTouchInfo",RB_FUNC(rb_cocos2dx_Touch_setTouchInfo));

    rb_define_method_bridge(classValue,"touchInfo=",RB_FUNC(rb_cocos2dx_Touch_setTouchInfo));
	

	rb_define_method_bridge(classValue,"getLocationInView",RB_FUNC(rb_cocos2dx_Touch_getLocationInView));

   rb_define_method_bridge(classValue,"locationInView",RB_FUNC(rb_cocos2dx_Touch_getLocationInView));
	

	rb_define_method_bridge(classValue,"getPreviousLocation",RB_FUNC(rb_cocos2dx_Touch_getPreviousLocation));

   rb_define_method_bridge(classValue,"previousLocation",RB_FUNC(rb_cocos2dx_Touch_getPreviousLocation));
	


	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_Touch_constructor));

	TypeTest<cocos2d::Touch> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Touch",classValue);
}
RBVAL rb_cocos2dx_Event_isStopped(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Event* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Event_isStopped : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isStopped();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Event_isStopped : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Event_getType(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Event* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Event_getType : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getType();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Event_getType : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Event_getCurrentTarget(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Event* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Event_getCurrentTarget : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Node* ret = cobj->getCurrentTarget();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Event_getCurrentTarget : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Event_stopPropagation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Event* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Event_stopPropagation : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->stopPropagation();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Event_stopPropagation : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_Event() {
		
	RBVAL classValue=rb_define_class_bridge("Event",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"isStopped",RB_FUNC(rb_cocos2dx_Event_isStopped));

	

	rb_define_method_bridge(classValue,"getType",RB_FUNC(rb_cocos2dx_Event_getType));

   rb_define_method_bridge(classValue,"type",RB_FUNC(rb_cocos2dx_Event_getType));
	

	rb_define_method_bridge(classValue,"getCurrentTarget",RB_FUNC(rb_cocos2dx_Event_getCurrentTarget));

   rb_define_method_bridge(classValue,"currentTarget",RB_FUNC(rb_cocos2dx_Event_getCurrentTarget));
	

	rb_define_method_bridge(classValue,"stopPropagation",RB_FUNC(rb_cocos2dx_Event_stopPropagation));

	



	TypeTest<cocos2d::Event> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Event",classValue);
}
RBVAL rb_cocos2dx_EventTouch_getEventCode(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventTouch* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventTouch_getEventCode : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getEventCode();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventTouch_getEventCode : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventTouch_setEventCode(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventTouch* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventTouch_setEventCode : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::EventTouch::EventCode arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventTouch_setEventCode : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEventCode(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("eventCode");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventTouch_setEventCode : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventTouch_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::EventTouch> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::EventTouch* cobj = new cocos2d::EventTouch();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventTouch_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EventTouch() {
		
	RBVAL classValue=rb_define_class_bridge("EventTouch",rb_get_class_value("cocos2d::Event"),true);

	rb_define_method_bridge(classValue,"getEventCode",RB_FUNC(rb_cocos2dx_EventTouch_getEventCode));

   rb_define_method_bridge(classValue,"eventCode",RB_FUNC(rb_cocos2dx_EventTouch_getEventCode));
	

	rb_define_method_bridge(classValue,"setEventCode",RB_FUNC(rb_cocos2dx_EventTouch_setEventCode));

    rb_define_method_bridge(classValue,"eventCode=",RB_FUNC(rb_cocos2dx_EventTouch_setEventCode));
	


	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_EventTouch_constructor));

	TypeTest<cocos2d::EventTouch> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EventTouch",classValue);
}
RBVAL rb_cocos2dx_EventKeyboard_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::EventKeyboard> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 2) {
			cocos2d::EventKeyboard::KeyCode arg0;
			bool arg1;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventKeyboard_constructor : Error processing argument 2 ( 2 )");return RBNil();}
			cocos2d::EventKeyboard* cobj = new cocos2d::EventKeyboard(arg0, arg1);
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventKeyboard_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EventKeyboard() {
		
	RBVAL classValue=rb_define_class_bridge("EventKeyboard",rb_get_class_value("cocos2d::Event"),true);


	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_EventKeyboard_constructor));

	TypeTest<cocos2d::EventKeyboard> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EventKeyboard",classValue);
}
RBVAL rb_cocos2dx_Node_addChild(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_addChild : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_addChild : Error processing argument 1 ( 2 )");return RBNil(); }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_addChild : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->addChild(arg0, arg1);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_addChild : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->addChild(arg0);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 3) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_addChild : Error processing argument 1 ( 3 )");return RBNil(); }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_addChild : Error processing argument 2 ( 3 )");return RBNil(); }
			int arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_addChild : Error processing argument 3 ( 3 )");return RBNil(); }
			cobj->addChild(arg0, arg1, arg2);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 3) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_addChild : Error processing argument 1 ( 3 )");return RBNil(); }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_addChild : Error processing argument 2 ( 3 )");return RBNil(); }
			std::string arg2;
			ok &= rb_value_to_std_string(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_addChild : Error processing argument 3 ( 3 )");return RBNil(); }
			cobj->addChild(arg0, arg1, arg2);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Node_addChild : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_removeComponent(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeComponent : self ptr is null");return RBNil();}
	do {
		if (argc == 1) {
			cocos2d::Component* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeComponent : Error processing argument 1 ( 1 )");return RBNil(); }
			bool ret = cobj->removeComponent(arg0);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeComponent : Error processing argument 1 ( 1 )");return RBNil(); }
			bool ret = cobj->removeComponent(arg0);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Node_removeComponent : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setPhysicsBody(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setPhysicsBody : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::PhysicsBody* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setPhysicsBody : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setPhysicsBody(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("physicsBody");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setPhysicsBody : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getDescription(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getDescription : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					std::string ret = cobj->getDescription();
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getDescription : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setRotationSkewY(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setRotationSkewY : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setRotationSkewY : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRotationSkewY(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("rotationSkewY");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setRotationSkewY : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setOpacityModifyRGB(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setOpacityModifyRGB : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setOpacityModifyRGB : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setOpacityModifyRGB(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("opacityModifyRGB");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setOpacityModifyRGB : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setCascadeOpacityEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setCascadeOpacityEnabled : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setCascadeOpacityEnabled : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setCascadeOpacityEnabled(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("cascadeOpacityEnabled");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setCascadeOpacityEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getChildren(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getChildren : self ptr is null");return RBNil();}
	do {
		if (argc == 0) {
			const cocos2d::Vector<cocos2d::Node *>& ret = cobj->getChildren();
			RBVAL value = RBNil();
			value = ccvector_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 0) {
			cocos2d::Vector<cocos2d::Node *>& ret = cobj->getChildren();
			RBVAL value = RBNil();
			value = ccvector_to_rb_value(ret);
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Node_getChildren : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setOnExitCallback(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setOnExitCallback : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::function<void ()> arg0;
			do {
			RBVAL rbproc= argv[0];
			auto lambda = [=]() -> void {
				RBVAL templargv;
				RBVAL value=rb_proc_call_bridge(rbproc, RBNil());
			};
			arg0 = lambda;
		} while(0)
		;
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setOnExitCallback : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setOnExitCallback(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("onExitCallback");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setOnExitCallback : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_pause(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_pause : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->pause();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_pause : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_convertToWorldSpaceAR(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_convertToWorldSpaceAR : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_convertToWorldSpaceAR : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->convertToWorldSpaceAR(arg0);
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_convertToWorldSpaceAR : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_isIgnoreAnchorPointForPosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_isIgnoreAnchorPointForPosition : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isIgnoreAnchorPointForPosition();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_isIgnoreAnchorPointForPosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getChildByName(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getChildByName : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getChildByName : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Node* ret = cobj->getChildByName(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getChildByName : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_updateDisplayedOpacity(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_updateDisplayedOpacity : self ptr is null");return RBNil();}
		if (argc == 1) {
			unsigned char arg0;
			ok &= rb_value_to_uint16(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_updateDisplayedOpacity : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->updateDisplayedOpacity(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_updateDisplayedOpacity : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getCameraMask(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getCameraMask : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					unsigned short ret = cobj->getCameraMask();
				value = uint32_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getCameraMask : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setRotation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setRotation : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setRotation : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRotation(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("rotation");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setRotation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setScaleZ(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setScaleZ : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setScaleZ : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setScaleZ(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("scaleZ");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setScaleZ : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setScaleY(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setScaleY : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setScaleY : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setScaleY(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("scaleY");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setScaleY : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setScaleX(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setScaleX : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setScaleX : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setScaleX(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("scaleX");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setScaleX : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setRotationSkewX(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setRotationSkewX : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setRotationSkewX : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRotationSkewX(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("rotationSkewX");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setRotationSkewX : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setonEnterTransitionDidFinishCallback(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setonEnterTransitionDidFinishCallback : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::function<void ()> arg0;
			do {
			RBVAL rbproc= argv[0];
			auto lambda = [=]() -> void {
				RBVAL templargv;
				RBVAL value=rb_proc_call_bridge(rbproc, RBNil());
			};
			arg0 = lambda;
		} while(0)
		;
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setonEnterTransitionDidFinishCallback : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setonEnterTransitionDidFinishCallback(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("onEnterTransitionDidFinishCallback");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setonEnterTransitionDidFinishCallback : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_removeFromPhysicsWorld(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeFromPhysicsWorld : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->removeFromPhysicsWorld();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_removeFromPhysicsWorld : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_removeAllComponents(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeAllComponents : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->removeAllComponents();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_removeAllComponents : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getOpacity(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getOpacity : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					unsigned char ret = cobj->getOpacity();
				value = uint16_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getOpacity : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setCameraMask(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setCameraMask : self ptr is null");return RBNil();}
		if (argc == 1) {
			unsigned short arg0;
			ok &= rb_value_to_uint32(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setCameraMask : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setCameraMask(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("cameraMask");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}
		if (argc == 2) {
			unsigned short arg0;
			bool arg1;
			ok &= rb_value_to_uint32(argv[0], &arg0);
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setCameraMask : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setCameraMask(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setCameraMask : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getTag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getTag : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getTag();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getTag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getGLProgram(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getGLProgram : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::GLProgram* ret = cobj->getGLProgram();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::GLProgram>((cocos2d::GLProgram*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getGLProgram : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getNodeToWorldTransform(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getNodeToWorldTransform : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Mat4 ret = cobj->getNodeToWorldTransform();
				value = mat4_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getNodeToWorldTransform : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getPosition3D(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getPosition3D : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec3 ret = cobj->getPosition3D();
				value = vec3_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getPosition3D : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_removeChild(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeChild : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeChild : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeChild(arg0);
		return value;
		}
		if (argc == 2) {
			cocos2d::Node* arg0;
			bool arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeChild : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeChild(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_removeChild : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_convertToWorldSpace(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_convertToWorldSpace : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_convertToWorldSpace : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->convertToWorldSpace(arg0);
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_convertToWorldSpace : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getScene(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getScene : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Scene* ret = cobj->getScene();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Scene>((cocos2d::Scene*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getScene : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getEventDispatcher(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getEventDispatcher : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::EventDispatcher* ret = cobj->getEventDispatcher();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::EventDispatcher>((cocos2d::EventDispatcher*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getEventDispatcher : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setSkewX(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setSkewX : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setSkewX : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setSkewX(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("skewX");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setSkewX : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setGLProgramState(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setGLProgramState : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::GLProgramState* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setGLProgramState : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setGLProgramState(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("gLProgramState");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setGLProgramState : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setOnEnterCallback(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setOnEnterCallback : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::function<void ()> arg0;
			do {
			RBVAL rbproc= argv[0];
			auto lambda = [=]() -> void {
				RBVAL templargv;
				RBVAL value=rb_proc_call_bridge(rbproc, RBNil());
			};
			arg0 = lambda;
		} while(0)
		;
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setOnEnterCallback : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setOnEnterCallback(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("onEnterCallback");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setOnEnterCallback : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setNormalizedPosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setNormalizedPosition : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setNormalizedPosition : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setNormalizedPosition(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("normalizedPosition");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setNormalizedPosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setonExitTransitionDidStartCallback(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setonExitTransitionDidStartCallback : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::function<void ()> arg0;
			do {
			RBVAL rbproc= argv[0];
			auto lambda = [=]() -> void {
				RBVAL templargv;
				RBVAL value=rb_proc_call_bridge(rbproc, RBNil());
			};
			arg0 = lambda;
		} while(0)
		;
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setonExitTransitionDidStartCallback : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setonExitTransitionDidStartCallback(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("onExitTransitionDidStartCallback");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setonExitTransitionDidStartCallback : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_convertTouchToNodeSpace(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_convertTouchToNodeSpace : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Touch* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_convertTouchToNodeSpace : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->convertTouchToNodeSpace(arg0);
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_convertTouchToNodeSpace : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_removeAllChildrenWithCleanup(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeAllChildrenWithCleanup : self ptr is null");return RBNil();}
	do {
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeAllChildrenWithCleanup : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->removeAllChildrenWithCleanup(arg0);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 0) {
			cobj->removeAllChildren();
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Node_removeAllChildrenWithCleanup : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getNodeToParentAffineTransform(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getNodeToParentAffineTransform : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::AffineTransform ret = cobj->getNodeToParentAffineTransform();
				value = ccaffinetransform_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getNodeToParentAffineTransform : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_isCascadeOpacityEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_isCascadeOpacityEnabled : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isCascadeOpacityEnabled();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_isCascadeOpacityEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setParent(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setParent : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setParent : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setParent(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("parent");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setParent : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getName(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getName : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					std::string ret = cobj->getName();
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getName : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_resume(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_resume : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->resume();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_resume : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getRotation3D(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getRotation3D : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec3 ret = cobj->getRotation3D();
				value = vec3_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getRotation3D : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getNodeToParentTransform(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getNodeToParentTransform : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Mat4& ret = cobj->getNodeToParentTransform();
				value = mat4_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getNodeToParentTransform : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_convertTouchToNodeSpaceAR(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_convertTouchToNodeSpaceAR : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Touch* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_convertTouchToNodeSpaceAR : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->convertTouchToNodeSpaceAR(arg0);
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_convertTouchToNodeSpaceAR : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_convertToNodeSpace(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_convertToNodeSpace : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_convertToNodeSpace : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->convertToNodeSpace(arg0);
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_convertToNodeSpace : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getPhysicsBody(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getPhysicsBody : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::PhysicsBody* ret = cobj->getPhysicsBody();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::PhysicsBody>((cocos2d::PhysicsBody*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getPhysicsBody : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setPosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setPosition : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setPosition : Error processing argument 1 ( 2 )");return RBNil(); }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setPosition : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setPosition(arg0, arg1);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setPosition : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->setPosition(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("position");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Node_setPosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_stopActionByTag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_stopActionByTag : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_stopActionByTag : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->stopActionByTag(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_stopActionByTag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_reorderChild(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_reorderChild : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::Node* arg0;
			int arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_reorderChild : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->reorderChild(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_reorderChild : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_ignoreAnchorPointForPosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_ignoreAnchorPointForPosition : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_ignoreAnchorPointForPosition : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->ignoreAnchorPointForPosition(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_ignoreAnchorPointForPosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setSkewY(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setSkewY : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setSkewY : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setSkewY(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("skewY");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setSkewY : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setPositionZ(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setPositionZ : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setPositionZ : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setPositionZ(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("positionZ");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setPositionZ : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setRotation3D(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setRotation3D : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec3 arg0;
			ok &= rb_value_to_vec3(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setRotation3D : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRotation3D(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("rotation3D");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setRotation3D : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setPositionX(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setPositionX : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setPositionX : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setPositionX(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("positionX");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setPositionX : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setNodeToParentTransform(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setNodeToParentTransform : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Mat4 arg0;
			ok &= rb_value_to_mat4(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setNodeToParentTransform : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setNodeToParentTransform(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("nodeToParentTransform");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setNodeToParentTransform : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getAnchorPoint(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getAnchorPoint : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec2& ret = cobj->getAnchorPoint();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getAnchorPoint : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getNumberOfRunningActions(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getNumberOfRunningActions : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					ssize_t ret = cobj->getNumberOfRunningActions();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getNumberOfRunningActions : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_updateTransform(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_updateTransform : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->updateTransform();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_updateTransform : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_isVisible(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_isVisible : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isVisible();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_isVisible : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getChildrenCount(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getChildrenCount : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					ssize_t ret = cobj->getChildrenCount();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getChildrenCount : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setAnchorPoint(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setAnchorPoint : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setAnchorPoint : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAnchorPoint(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("anchorPoint");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setAnchorPoint : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_convertToNodeSpaceAR(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_convertToNodeSpaceAR : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_convertToNodeSpaceAR : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->convertToNodeSpaceAR(arg0);
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_convertToNodeSpaceAR : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_addComponent(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_addComponent : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Component* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_addComponent : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->addComponent(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_addComponent : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_runAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_runAction : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Action* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_runAction : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Action* ret = cobj->runAction(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Action>((cocos2d::Action*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_runAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_isOpacityModifyRGB(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_isOpacityModifyRGB : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isOpacityModifyRGB();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_isOpacityModifyRGB : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getRotation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getRotation : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getRotation();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getRotation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getAnchorPointInPoints(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getAnchorPointInPoints : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec2& ret = cobj->getAnchorPointInPoints();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getAnchorPointInPoints : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_visit(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_visit : self ptr is null");return RBNil();}
	do {
		if (argc == 0) {
			cobj->visit();
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 3) {
			cocos2d::Renderer* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_visit : Error processing argument 1 ( 3 )");return RBNil(); }
			cocos2d::Mat4 arg1;
			ok &= rb_value_to_mat4(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_visit : Error processing argument 2 ( 3 )");return RBNil(); }
			unsigned int arg2;
			ok &= rb_value_to_uint(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_visit : Error processing argument 3 ( 3 )");return RBNil(); }
			cobj->visit(arg0, arg1, arg2);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Node_visit : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_removeChildByName(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeChildByName : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeChildByName : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeChildByName(arg0);
		return value;
		}
		if (argc == 2) {
			std::string arg0;
			bool arg1;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeChildByName : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeChildByName(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_removeChildByName : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getGLProgramState(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getGLProgramState : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::GLProgramState* ret = cobj->getGLProgramState();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::GLProgramState>((cocos2d::GLProgramState*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getGLProgramState : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setScheduler(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setScheduler : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Scheduler* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setScheduler : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setScheduler(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("scheduler");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setScheduler : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_stopAllActions(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_stopAllActions : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->stopAllActions();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_stopAllActions : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getSkewX(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getSkewX : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getSkewX();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getSkewX : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getSkewY(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getSkewY : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getSkewY();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getSkewY : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getDisplayedColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getDisplayedColor : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Color3B& ret = cobj->getDisplayedColor();
				value = cccolor3b_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getDisplayedColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getActionByTag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getActionByTag : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getActionByTag : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Action* ret = cobj->getActionByTag(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Action>((cocos2d::Action*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getActionByTag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setName(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setName : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setName : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setName(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("name");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setName : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getDisplayedOpacity(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getDisplayedOpacity : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					unsigned char ret = cobj->getDisplayedOpacity();
				value = uint16_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getDisplayedOpacity : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getLocalZOrder(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getLocalZOrder : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getLocalZOrder();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getLocalZOrder : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getScheduler(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getScheduler : self ptr is null");return RBNil();}
	do {
		if (argc == 0) {
			const cocos2d::Scheduler* ret = cobj->getScheduler();
			RBVAL value = RBNil();
						if (ret) {
				value = rbb_get_or_create_value<cocos2d::Scheduler>((cocos2d::Scheduler*)ret);
			} else {
				value = RBNil();
			};
			return value;
		}
	} while(0);

	do {
		if (argc == 0) {
			cocos2d::Scheduler* ret = cobj->getScheduler();
			RBVAL value = RBNil();
						if (ret) {
				value = rbb_get_or_create_value<cocos2d::Scheduler>((cocos2d::Scheduler*)ret);
			} else {
				value = RBNil();
			};
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Node_getScheduler : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getParentToNodeAffineTransform(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getParentToNodeAffineTransform : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::AffineTransform ret = cobj->getParentToNodeAffineTransform();
				value = ccaffinetransform_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getParentToNodeAffineTransform : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getOrderOfArrival(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getOrderOfArrival : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getOrderOfArrival();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getOrderOfArrival : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setContentSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setContentSize : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Size arg0;
			ok &= rb_value_to_ccsize(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setContentSize : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setContentSize(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("contentSize");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setContentSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setActionManager(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setActionManager : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ActionManager* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setActionManager : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setActionManager(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("actionManager");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setActionManager : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getPosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getPosition : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			float* arg0;
			#pragma warning NO CONVERSION TO NATIVE FOR float*
			ok = false;
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getPosition : Error processing argument 1 ( 2 )");return RBNil(); }
			float* arg1;
			#pragma warning NO CONVERSION TO NATIVE FOR float*
			ok = false;
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getPosition : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->getPosition(arg0, arg1);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 0) {
			const cocos2d::Vec2& ret = cobj->getPosition();
			RBVAL value = RBNil();
			value = vec2_to_rb_value(ret);
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Node_getPosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setColor : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Color3B arg0;
			ok &= rb_value_to_cccolor3b(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setColor : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setColor(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("color");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_isRunning(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_isRunning : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isRunning();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_isRunning : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getParent(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getParent : self ptr is null");return RBNil();}
	do {
		if (argc == 0) {
			const cocos2d::Node* ret = cobj->getParent();
			RBVAL value = RBNil();
						if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
			return value;
		}
	} while(0);

	do {
		if (argc == 0) {
			cocos2d::Node* ret = cobj->getParent();
			RBVAL value = RBNil();
						if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Node_getParent : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getPositionZ(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getPositionZ : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getPositionZ();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getPositionZ : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getPositionY(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getPositionY : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getPositionY();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getPositionY : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getPositionX(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getPositionX : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getPositionX();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getPositionX : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_removeChildByTag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeChildByTag : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeChildByTag : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeChildByTag(arg0);
		return value;
		}
		if (argc == 2) {
			int arg0;
			bool arg1;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeChildByTag : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeChildByTag(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_removeChildByTag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setPositionY(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setPositionY : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setPositionY : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setPositionY(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("positionY");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setPositionY : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getNodeToWorldAffineTransform(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getNodeToWorldAffineTransform : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::AffineTransform ret = cobj->getNodeToWorldAffineTransform();
				value = ccaffinetransform_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getNodeToWorldAffineTransform : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_updateDisplayedColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_updateDisplayedColor : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Color3B arg0;
			ok &= rb_value_to_cccolor3b(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_updateDisplayedColor : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->updateDisplayedColor(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_updateDisplayedColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setVisible(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setVisible : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setVisible : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setVisible(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("visible");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setVisible : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getParentToNodeTransform(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getParentToNodeTransform : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Mat4& ret = cobj->getParentToNodeTransform();
				value = mat4_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getParentToNodeTransform : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_isScheduled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_isScheduled : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_isScheduled : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->isScheduled(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_isScheduled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setGlobalZOrder(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setGlobalZOrder : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setGlobalZOrder : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setGlobalZOrder(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("globalZOrder");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setGlobalZOrder : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setScale(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setScale : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setScale : Error processing argument 1 ( 2 )");return RBNil(); }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setScale : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setScale(arg0, arg1);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setScale : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->setScale(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("scale");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Node_setScale : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getChildByTag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getChildByTag : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getChildByTag : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Node* ret = cobj->getChildByTag(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getChildByTag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setOrderOfArrival(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setOrderOfArrival : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setOrderOfArrival : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setOrderOfArrival(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("orderOfArrival");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setOrderOfArrival : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getScaleZ(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getScaleZ : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getScaleZ();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getScaleZ : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getScaleY(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getScaleY : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getScaleY();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getScaleY : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getScaleX(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getScaleX : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getScaleX();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getScaleX : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setLocalZOrder(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setLocalZOrder : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setLocalZOrder : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setLocalZOrder(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("localZOrder");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setLocalZOrder : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getWorldToNodeAffineTransform(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getWorldToNodeAffineTransform : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::AffineTransform ret = cobj->getWorldToNodeAffineTransform();
				value = ccaffinetransform_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getWorldToNodeAffineTransform : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setCascadeColorEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setCascadeColorEnabled : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setCascadeColorEnabled : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setCascadeColorEnabled(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("cascadeColorEnabled");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setCascadeColorEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setOpacity(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setOpacity : self ptr is null");return RBNil();}
		if (argc == 1) {
			unsigned char arg0;
			ok &= rb_value_to_uint16(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setOpacity : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setOpacity(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("opacity");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setOpacity : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_cleanup(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_cleanup : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->cleanup();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_cleanup : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getComponent(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getComponent : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getComponent : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Component* ret = cobj->getComponent(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Component>((cocos2d::Component*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getComponent : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getContentSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getContentSize : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Size& ret = cobj->getContentSize();
				value = ccsize_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getContentSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_stopAllActionsByTag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_stopAllActionsByTag : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_stopAllActionsByTag : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->stopAllActionsByTag(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_stopAllActionsByTag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getColor : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Color3B& ret = cobj->getColor();
				value = cccolor3b_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getBoundingBox(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getBoundingBox : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Rect ret = cobj->getBoundingBox();
				value = ccrect_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getBoundingBox : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setEventDispatcher(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setEventDispatcher : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::EventDispatcher* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setEventDispatcher : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEventDispatcher(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("eventDispatcher");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setEventDispatcher : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getGlobalZOrder(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getGlobalZOrder : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getGlobalZOrder();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getGlobalZOrder : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_draw(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_draw : self ptr is null");return RBNil();}
	do {
		if (argc == 0) {
			cobj->draw();
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 3) {
			cocos2d::Renderer* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_draw : Error processing argument 1 ( 3 )");return RBNil(); }
			cocos2d::Mat4 arg1;
			ok &= rb_value_to_mat4(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_draw : Error processing argument 2 ( 3 )");return RBNil(); }
			unsigned int arg2;
			ok &= rb_value_to_uint(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_draw : Error processing argument 3 ( 3 )");return RBNil(); }
			cobj->draw(arg0, arg1, arg2);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Node_draw : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setUserObject(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setUserObject : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Ref* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setUserObject : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setUserObject(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("userObject");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setUserObject : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_removeFromParentAndCleanup(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeFromParentAndCleanup : self ptr is null");return RBNil();}
	do {
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_removeFromParentAndCleanup : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->removeFromParentAndCleanup(arg0);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 0) {
			cobj->removeFromParent();
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Node_removeFromParentAndCleanup : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setPosition3D(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setPosition3D : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec3 arg0;
			ok &= rb_value_to_vec3(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setPosition3D : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setPosition3D(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("position3D");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setPosition3D : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_update(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_update : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_update : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->update(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_update : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_sortAllChildren(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_sortAllChildren : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->sortAllChildren();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_sortAllChildren : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getWorldToNodeTransform(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getWorldToNodeTransform : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Mat4 ret = cobj->getWorldToNodeTransform();
				value = mat4_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getWorldToNodeTransform : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setGLProgram(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setGLProgram : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::GLProgram* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setGLProgram : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setGLProgram(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("gLProgram");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setGLProgram : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getScale(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getScale : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getScale();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getScale : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getNormalizedPosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getNormalizedPosition : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec2& ret = cobj->getNormalizedPosition();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getNormalizedPosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getRotationSkewX(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getRotationSkewX : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getRotationSkewX();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getRotationSkewX : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getRotationSkewY(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getRotationSkewY : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getRotationSkewY();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_getRotationSkewY : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_setTag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setTag : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_setTag : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTag(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("tag");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_setTag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_isCascadeColorEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_isCascadeColorEnabled : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isCascadeColorEnabled();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_isCascadeColorEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_stopAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_stopAction : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Action* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_stopAction : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->stopAction(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Node_stopAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_getActionManager(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Node* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Node_getActionManager : self ptr is null");return RBNil();}
	do {
		if (argc == 0) {
			const cocos2d::ActionManager* ret = cobj->getActionManager();
			RBVAL value = RBNil();
						if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionManager>((cocos2d::ActionManager*)ret);
			} else {
				value = RBNil();
			};
			return value;
		}
	} while(0);

	do {
		if (argc == 0) {
			cocos2d::ActionManager* ret = cobj->getActionManager();
			RBVAL value = RBNil();
						if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionManager>((cocos2d::ActionManager*)ret);
			} else {
				value = RBNil();
			};
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Node_getActionManager : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Node_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::Node* ret = cocos2d::Node::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Node_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Node() {
		
	RBVAL classValue=rb_define_class_bridge("Node",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"addChild",RB_FUNC(rb_cocos2dx_Node_addChild));

	

	rb_define_method_bridge(classValue,"removeComponent",RB_FUNC(rb_cocos2dx_Node_removeComponent));

	

	rb_define_method_bridge(classValue,"setPhysicsBody",RB_FUNC(rb_cocos2dx_Node_setPhysicsBody));

    rb_define_method_bridge(classValue,"physicsBody=",RB_FUNC(rb_cocos2dx_Node_setPhysicsBody));
	

	rb_define_method_bridge(classValue,"getDescription",RB_FUNC(rb_cocos2dx_Node_getDescription));

   rb_define_method_bridge(classValue,"description",RB_FUNC(rb_cocos2dx_Node_getDescription));
	

	rb_define_method_bridge(classValue,"setRotationSkewY",RB_FUNC(rb_cocos2dx_Node_setRotationSkewY));

    rb_define_method_bridge(classValue,"rotationSkewY=",RB_FUNC(rb_cocos2dx_Node_setRotationSkewY));
	

	rb_define_method_bridge(classValue,"setOpacityModifyRGB",RB_FUNC(rb_cocos2dx_Node_setOpacityModifyRGB));

    rb_define_method_bridge(classValue,"opacityModifyRGB=",RB_FUNC(rb_cocos2dx_Node_setOpacityModifyRGB));
	

	rb_define_method_bridge(classValue,"setCascadeOpacityEnabled",RB_FUNC(rb_cocos2dx_Node_setCascadeOpacityEnabled));

    rb_define_method_bridge(classValue,"cascadeOpacityEnabled=",RB_FUNC(rb_cocos2dx_Node_setCascadeOpacityEnabled));
	

	rb_define_method_bridge(classValue,"getChildren",RB_FUNC(rb_cocos2dx_Node_getChildren));

   rb_define_method_bridge(classValue,"children",RB_FUNC(rb_cocos2dx_Node_getChildren));
	

	rb_define_method_bridge(classValue,"setOnExitCallback",RB_FUNC(rb_cocos2dx_Node_setOnExitCallback));

    rb_define_method_bridge(classValue,"onExitCallback=",RB_FUNC(rb_cocos2dx_Node_setOnExitCallback));
	

	rb_define_method_bridge(classValue,"pause",RB_FUNC(rb_cocos2dx_Node_pause));

	

	rb_define_method_bridge(classValue,"convertToWorldSpaceAR",RB_FUNC(rb_cocos2dx_Node_convertToWorldSpaceAR));

	

	rb_define_method_bridge(classValue,"isIgnoreAnchorPointForPosition",RB_FUNC(rb_cocos2dx_Node_isIgnoreAnchorPointForPosition));

	

	rb_define_method_bridge(classValue,"getChildByName",RB_FUNC(rb_cocos2dx_Node_getChildByName));

   rb_define_method_bridge(classValue,"childByName",RB_FUNC(rb_cocos2dx_Node_getChildByName));
	

	rb_define_method_bridge(classValue,"updateDisplayedOpacity",RB_FUNC(rb_cocos2dx_Node_updateDisplayedOpacity));

	

	rb_define_method_bridge(classValue,"getCameraMask",RB_FUNC(rb_cocos2dx_Node_getCameraMask));

   rb_define_method_bridge(classValue,"cameraMask",RB_FUNC(rb_cocos2dx_Node_getCameraMask));
	

	rb_define_method_bridge(classValue,"setRotation",RB_FUNC(rb_cocos2dx_Node_setRotation));

    rb_define_method_bridge(classValue,"rotation=",RB_FUNC(rb_cocos2dx_Node_setRotation));
	

	rb_define_method_bridge(classValue,"setScaleZ",RB_FUNC(rb_cocos2dx_Node_setScaleZ));

    rb_define_method_bridge(classValue,"scaleZ=",RB_FUNC(rb_cocos2dx_Node_setScaleZ));
	

	rb_define_method_bridge(classValue,"setScaleY",RB_FUNC(rb_cocos2dx_Node_setScaleY));

    rb_define_method_bridge(classValue,"scaleY=",RB_FUNC(rb_cocos2dx_Node_setScaleY));
	

	rb_define_method_bridge(classValue,"setScaleX",RB_FUNC(rb_cocos2dx_Node_setScaleX));

    rb_define_method_bridge(classValue,"scaleX=",RB_FUNC(rb_cocos2dx_Node_setScaleX));
	

	rb_define_method_bridge(classValue,"setRotationSkewX",RB_FUNC(rb_cocos2dx_Node_setRotationSkewX));

    rb_define_method_bridge(classValue,"rotationSkewX=",RB_FUNC(rb_cocos2dx_Node_setRotationSkewX));
	

	rb_define_method_bridge(classValue,"setonEnterTransitionDidFinishCallback",RB_FUNC(rb_cocos2dx_Node_setonEnterTransitionDidFinishCallback));

    rb_define_method_bridge(classValue,"onEnterTransitionDidFinishCallback=",RB_FUNC(rb_cocos2dx_Node_setonEnterTransitionDidFinishCallback));
	

	rb_define_method_bridge(classValue,"removeFromPhysicsWorld",RB_FUNC(rb_cocos2dx_Node_removeFromPhysicsWorld));

	

	rb_define_method_bridge(classValue,"removeAllComponents",RB_FUNC(rb_cocos2dx_Node_removeAllComponents));

	

	rb_define_method_bridge(classValue,"getOpacity",RB_FUNC(rb_cocos2dx_Node_getOpacity));

   rb_define_method_bridge(classValue,"opacity",RB_FUNC(rb_cocos2dx_Node_getOpacity));
	

	rb_define_method_bridge(classValue,"setCameraMask",RB_FUNC(rb_cocos2dx_Node_setCameraMask));

    rb_define_method_bridge(classValue,"cameraMask=",RB_FUNC(rb_cocos2dx_Node_setCameraMask));
	

	rb_define_method_bridge(classValue,"getTag",RB_FUNC(rb_cocos2dx_Node_getTag));

   rb_define_method_bridge(classValue,"tag",RB_FUNC(rb_cocos2dx_Node_getTag));
	

	rb_define_method_bridge(classValue,"getGLProgram",RB_FUNC(rb_cocos2dx_Node_getGLProgram));

   rb_define_method_bridge(classValue,"gLProgram",RB_FUNC(rb_cocos2dx_Node_getGLProgram));
	

	rb_define_method_bridge(classValue,"getNodeToWorldTransform",RB_FUNC(rb_cocos2dx_Node_getNodeToWorldTransform));

   rb_define_method_bridge(classValue,"nodeToWorldTransform",RB_FUNC(rb_cocos2dx_Node_getNodeToWorldTransform));
	

	rb_define_method_bridge(classValue,"getPosition3D",RB_FUNC(rb_cocos2dx_Node_getPosition3D));

   rb_define_method_bridge(classValue,"position3D",RB_FUNC(rb_cocos2dx_Node_getPosition3D));
	

	rb_define_method_bridge(classValue,"removeChild",RB_FUNC(rb_cocos2dx_Node_removeChild));

	

	rb_define_method_bridge(classValue,"convertToWorldSpace",RB_FUNC(rb_cocos2dx_Node_convertToWorldSpace));

	

	rb_define_method_bridge(classValue,"getScene",RB_FUNC(rb_cocos2dx_Node_getScene));

   rb_define_method_bridge(classValue,"scene",RB_FUNC(rb_cocos2dx_Node_getScene));
	

	rb_define_method_bridge(classValue,"getEventDispatcher",RB_FUNC(rb_cocos2dx_Node_getEventDispatcher));

   rb_define_method_bridge(classValue,"eventDispatcher",RB_FUNC(rb_cocos2dx_Node_getEventDispatcher));
	

	rb_define_method_bridge(classValue,"setSkewX",RB_FUNC(rb_cocos2dx_Node_setSkewX));

    rb_define_method_bridge(classValue,"skewX=",RB_FUNC(rb_cocos2dx_Node_setSkewX));
	

	rb_define_method_bridge(classValue,"setGLProgramState",RB_FUNC(rb_cocos2dx_Node_setGLProgramState));

    rb_define_method_bridge(classValue,"gLProgramState=",RB_FUNC(rb_cocos2dx_Node_setGLProgramState));
	

	rb_define_method_bridge(classValue,"setOnEnterCallback",RB_FUNC(rb_cocos2dx_Node_setOnEnterCallback));

    rb_define_method_bridge(classValue,"onEnterCallback=",RB_FUNC(rb_cocos2dx_Node_setOnEnterCallback));
	

	rb_define_method_bridge(classValue,"setNormalizedPosition",RB_FUNC(rb_cocos2dx_Node_setNormalizedPosition));

    rb_define_method_bridge(classValue,"normalizedPosition=",RB_FUNC(rb_cocos2dx_Node_setNormalizedPosition));
	

	rb_define_method_bridge(classValue,"setonExitTransitionDidStartCallback",RB_FUNC(rb_cocos2dx_Node_setonExitTransitionDidStartCallback));

    rb_define_method_bridge(classValue,"onExitTransitionDidStartCallback=",RB_FUNC(rb_cocos2dx_Node_setonExitTransitionDidStartCallback));
	

	rb_define_method_bridge(classValue,"convertTouchToNodeSpace",RB_FUNC(rb_cocos2dx_Node_convertTouchToNodeSpace));

	

	rb_define_method_bridge(classValue,"removeAllChildren",RB_FUNC(rb_cocos2dx_Node_removeAllChildrenWithCleanup));

	

	rb_define_method_bridge(classValue,"getNodeToParentAffineTransform",RB_FUNC(rb_cocos2dx_Node_getNodeToParentAffineTransform));

   rb_define_method_bridge(classValue,"nodeToParentAffineTransform",RB_FUNC(rb_cocos2dx_Node_getNodeToParentAffineTransform));
	

	rb_define_method_bridge(classValue,"isCascadeOpacityEnabled",RB_FUNC(rb_cocos2dx_Node_isCascadeOpacityEnabled));

	

	rb_define_method_bridge(classValue,"setParent",RB_FUNC(rb_cocos2dx_Node_setParent));

    rb_define_method_bridge(classValue,"parent=",RB_FUNC(rb_cocos2dx_Node_setParent));
	

	rb_define_method_bridge(classValue,"getName",RB_FUNC(rb_cocos2dx_Node_getName));

   rb_define_method_bridge(classValue,"name",RB_FUNC(rb_cocos2dx_Node_getName));
	

	rb_define_method_bridge(classValue,"resume",RB_FUNC(rb_cocos2dx_Node_resume));

	

	rb_define_method_bridge(classValue,"getRotation3D",RB_FUNC(rb_cocos2dx_Node_getRotation3D));

   rb_define_method_bridge(classValue,"rotation3D",RB_FUNC(rb_cocos2dx_Node_getRotation3D));
	

	rb_define_method_bridge(classValue,"getNodeToParentTransform",RB_FUNC(rb_cocos2dx_Node_getNodeToParentTransform));

   rb_define_method_bridge(classValue,"nodeToParentTransform",RB_FUNC(rb_cocos2dx_Node_getNodeToParentTransform));
	

	rb_define_method_bridge(classValue,"convertTouchToNodeSpaceAR",RB_FUNC(rb_cocos2dx_Node_convertTouchToNodeSpaceAR));

	

	rb_define_method_bridge(classValue,"convertToNodeSpace",RB_FUNC(rb_cocos2dx_Node_convertToNodeSpace));

	

	rb_define_method_bridge(classValue,"getPhysicsBody",RB_FUNC(rb_cocos2dx_Node_getPhysicsBody));

   rb_define_method_bridge(classValue,"physicsBody",RB_FUNC(rb_cocos2dx_Node_getPhysicsBody));
	

	rb_define_method_bridge(classValue,"setPosition",RB_FUNC(rb_cocos2dx_Node_setPosition));

    rb_define_method_bridge(classValue,"position=",RB_FUNC(rb_cocos2dx_Node_setPosition));
	

	rb_define_method_bridge(classValue,"stopActionByTag",RB_FUNC(rb_cocos2dx_Node_stopActionByTag));

	

	rb_define_method_bridge(classValue,"reorderChild",RB_FUNC(rb_cocos2dx_Node_reorderChild));

	

	rb_define_method_bridge(classValue,"ignoreAnchorPointForPosition",RB_FUNC(rb_cocos2dx_Node_ignoreAnchorPointForPosition));

	

	rb_define_method_bridge(classValue,"setSkewY",RB_FUNC(rb_cocos2dx_Node_setSkewY));

    rb_define_method_bridge(classValue,"skewY=",RB_FUNC(rb_cocos2dx_Node_setSkewY));
	

	rb_define_method_bridge(classValue,"setPositionZ",RB_FUNC(rb_cocos2dx_Node_setPositionZ));

    rb_define_method_bridge(classValue,"positionZ=",RB_FUNC(rb_cocos2dx_Node_setPositionZ));
	

	rb_define_method_bridge(classValue,"setRotation3D",RB_FUNC(rb_cocos2dx_Node_setRotation3D));

    rb_define_method_bridge(classValue,"rotation3D=",RB_FUNC(rb_cocos2dx_Node_setRotation3D));
	

	rb_define_method_bridge(classValue,"setPositionX",RB_FUNC(rb_cocos2dx_Node_setPositionX));

    rb_define_method_bridge(classValue,"positionX=",RB_FUNC(rb_cocos2dx_Node_setPositionX));
	

	rb_define_method_bridge(classValue,"setNodeToParentTransform",RB_FUNC(rb_cocos2dx_Node_setNodeToParentTransform));

    rb_define_method_bridge(classValue,"nodeToParentTransform=",RB_FUNC(rb_cocos2dx_Node_setNodeToParentTransform));
	

	rb_define_method_bridge(classValue,"getAnchorPoint",RB_FUNC(rb_cocos2dx_Node_getAnchorPoint));

   rb_define_method_bridge(classValue,"anchorPoint",RB_FUNC(rb_cocos2dx_Node_getAnchorPoint));
	

	rb_define_method_bridge(classValue,"getNumberOfRunningActions",RB_FUNC(rb_cocos2dx_Node_getNumberOfRunningActions));

   rb_define_method_bridge(classValue,"numberOfRunningActions",RB_FUNC(rb_cocos2dx_Node_getNumberOfRunningActions));
	

	rb_define_method_bridge(classValue,"updateTransform",RB_FUNC(rb_cocos2dx_Node_updateTransform));

	

	rb_define_method_bridge(classValue,"isVisible",RB_FUNC(rb_cocos2dx_Node_isVisible));

	

	rb_define_method_bridge(classValue,"getChildrenCount",RB_FUNC(rb_cocos2dx_Node_getChildrenCount));

   rb_define_method_bridge(classValue,"childrenCount",RB_FUNC(rb_cocos2dx_Node_getChildrenCount));
	

	rb_define_method_bridge(classValue,"setAnchorPoint",RB_FUNC(rb_cocos2dx_Node_setAnchorPoint));

    rb_define_method_bridge(classValue,"anchorPoint=",RB_FUNC(rb_cocos2dx_Node_setAnchorPoint));
	

	rb_define_method_bridge(classValue,"convertToNodeSpaceAR",RB_FUNC(rb_cocos2dx_Node_convertToNodeSpaceAR));

	

	rb_define_method_bridge(classValue,"addComponent",RB_FUNC(rb_cocos2dx_Node_addComponent));

	

	rb_define_method_bridge(classValue,"runAction",RB_FUNC(rb_cocos2dx_Node_runAction));

	

	rb_define_method_bridge(classValue,"isOpacityModifyRGB",RB_FUNC(rb_cocos2dx_Node_isOpacityModifyRGB));

	

	rb_define_method_bridge(classValue,"getRotation",RB_FUNC(rb_cocos2dx_Node_getRotation));

   rb_define_method_bridge(classValue,"rotation",RB_FUNC(rb_cocos2dx_Node_getRotation));
	

	rb_define_method_bridge(classValue,"getAnchorPointInPoints",RB_FUNC(rb_cocos2dx_Node_getAnchorPointInPoints));

   rb_define_method_bridge(classValue,"anchorPointInPoints",RB_FUNC(rb_cocos2dx_Node_getAnchorPointInPoints));
	

	rb_define_method_bridge(classValue,"visit",RB_FUNC(rb_cocos2dx_Node_visit));

	

	rb_define_method_bridge(classValue,"removeChildByName",RB_FUNC(rb_cocos2dx_Node_removeChildByName));

	

	rb_define_method_bridge(classValue,"getGLProgramState",RB_FUNC(rb_cocos2dx_Node_getGLProgramState));

   rb_define_method_bridge(classValue,"gLProgramState",RB_FUNC(rb_cocos2dx_Node_getGLProgramState));
	

	rb_define_method_bridge(classValue,"setScheduler",RB_FUNC(rb_cocos2dx_Node_setScheduler));

    rb_define_method_bridge(classValue,"scheduler=",RB_FUNC(rb_cocos2dx_Node_setScheduler));
	

	rb_define_method_bridge(classValue,"stopAllActions",RB_FUNC(rb_cocos2dx_Node_stopAllActions));

	

	rb_define_method_bridge(classValue,"getSkewX",RB_FUNC(rb_cocos2dx_Node_getSkewX));

   rb_define_method_bridge(classValue,"skewX",RB_FUNC(rb_cocos2dx_Node_getSkewX));
	

	rb_define_method_bridge(classValue,"getSkewY",RB_FUNC(rb_cocos2dx_Node_getSkewY));

   rb_define_method_bridge(classValue,"skewY",RB_FUNC(rb_cocos2dx_Node_getSkewY));
	

	rb_define_method_bridge(classValue,"getDisplayedColor",RB_FUNC(rb_cocos2dx_Node_getDisplayedColor));

   rb_define_method_bridge(classValue,"displayedColor",RB_FUNC(rb_cocos2dx_Node_getDisplayedColor));
	

	rb_define_method_bridge(classValue,"getActionByTag",RB_FUNC(rb_cocos2dx_Node_getActionByTag));

   rb_define_method_bridge(classValue,"actionByTag",RB_FUNC(rb_cocos2dx_Node_getActionByTag));
	

	rb_define_method_bridge(classValue,"setName",RB_FUNC(rb_cocos2dx_Node_setName));

    rb_define_method_bridge(classValue,"name=",RB_FUNC(rb_cocos2dx_Node_setName));
	

	rb_define_method_bridge(classValue,"getDisplayedOpacity",RB_FUNC(rb_cocos2dx_Node_getDisplayedOpacity));

   rb_define_method_bridge(classValue,"displayedOpacity",RB_FUNC(rb_cocos2dx_Node_getDisplayedOpacity));
	

	rb_define_method_bridge(classValue,"getLocalZOrder",RB_FUNC(rb_cocos2dx_Node_getLocalZOrder));

   rb_define_method_bridge(classValue,"localZOrder",RB_FUNC(rb_cocos2dx_Node_getLocalZOrder));
	

	rb_define_method_bridge(classValue,"getScheduler",RB_FUNC(rb_cocos2dx_Node_getScheduler));

   rb_define_method_bridge(classValue,"scheduler",RB_FUNC(rb_cocos2dx_Node_getScheduler));
	

	rb_define_method_bridge(classValue,"getParentToNodeAffineTransform",RB_FUNC(rb_cocos2dx_Node_getParentToNodeAffineTransform));

   rb_define_method_bridge(classValue,"parentToNodeAffineTransform",RB_FUNC(rb_cocos2dx_Node_getParentToNodeAffineTransform));
	

	rb_define_method_bridge(classValue,"getOrderOfArrival",RB_FUNC(rb_cocos2dx_Node_getOrderOfArrival));

   rb_define_method_bridge(classValue,"orderOfArrival",RB_FUNC(rb_cocos2dx_Node_getOrderOfArrival));
	

	rb_define_method_bridge(classValue,"setContentSize",RB_FUNC(rb_cocos2dx_Node_setContentSize));

    rb_define_method_bridge(classValue,"contentSize=",RB_FUNC(rb_cocos2dx_Node_setContentSize));
	

	rb_define_method_bridge(classValue,"setActionManager",RB_FUNC(rb_cocos2dx_Node_setActionManager));

    rb_define_method_bridge(classValue,"actionManager=",RB_FUNC(rb_cocos2dx_Node_setActionManager));
	

	rb_define_method_bridge(classValue,"getPosition",RB_FUNC(rb_cocos2dx_Node_getPosition));

   rb_define_method_bridge(classValue,"position",RB_FUNC(rb_cocos2dx_Node_getPosition));
	

	rb_define_method_bridge(classValue,"setColor",RB_FUNC(rb_cocos2dx_Node_setColor));

    rb_define_method_bridge(classValue,"color=",RB_FUNC(rb_cocos2dx_Node_setColor));
	

	rb_define_method_bridge(classValue,"isRunning",RB_FUNC(rb_cocos2dx_Node_isRunning));

	

	rb_define_method_bridge(classValue,"getParent",RB_FUNC(rb_cocos2dx_Node_getParent));

   rb_define_method_bridge(classValue,"parent",RB_FUNC(rb_cocos2dx_Node_getParent));
	

	rb_define_method_bridge(classValue,"getPositionZ",RB_FUNC(rb_cocos2dx_Node_getPositionZ));

   rb_define_method_bridge(classValue,"positionZ",RB_FUNC(rb_cocos2dx_Node_getPositionZ));
	

	rb_define_method_bridge(classValue,"getPositionY",RB_FUNC(rb_cocos2dx_Node_getPositionY));

   rb_define_method_bridge(classValue,"positionY",RB_FUNC(rb_cocos2dx_Node_getPositionY));
	

	rb_define_method_bridge(classValue,"getPositionX",RB_FUNC(rb_cocos2dx_Node_getPositionX));

   rb_define_method_bridge(classValue,"positionX",RB_FUNC(rb_cocos2dx_Node_getPositionX));
	

	rb_define_method_bridge(classValue,"removeChildByTag",RB_FUNC(rb_cocos2dx_Node_removeChildByTag));

	

	rb_define_method_bridge(classValue,"setPositionY",RB_FUNC(rb_cocos2dx_Node_setPositionY));

    rb_define_method_bridge(classValue,"positionY=",RB_FUNC(rb_cocos2dx_Node_setPositionY));
	

	rb_define_method_bridge(classValue,"getNodeToWorldAffineTransform",RB_FUNC(rb_cocos2dx_Node_getNodeToWorldAffineTransform));

   rb_define_method_bridge(classValue,"nodeToWorldAffineTransform",RB_FUNC(rb_cocos2dx_Node_getNodeToWorldAffineTransform));
	

	rb_define_method_bridge(classValue,"updateDisplayedColor",RB_FUNC(rb_cocos2dx_Node_updateDisplayedColor));

	

	rb_define_method_bridge(classValue,"setVisible",RB_FUNC(rb_cocos2dx_Node_setVisible));

    rb_define_method_bridge(classValue,"visible=",RB_FUNC(rb_cocos2dx_Node_setVisible));
	

	rb_define_method_bridge(classValue,"getParentToNodeTransform",RB_FUNC(rb_cocos2dx_Node_getParentToNodeTransform));

   rb_define_method_bridge(classValue,"parentToNodeTransform",RB_FUNC(rb_cocos2dx_Node_getParentToNodeTransform));
	

	rb_define_method_bridge(classValue,"isScheduled",RB_FUNC(rb_cocos2dx_Node_isScheduled));

	

	rb_define_method_bridge(classValue,"setGlobalZOrder",RB_FUNC(rb_cocos2dx_Node_setGlobalZOrder));

    rb_define_method_bridge(classValue,"globalZOrder=",RB_FUNC(rb_cocos2dx_Node_setGlobalZOrder));
	

	rb_define_method_bridge(classValue,"setScale",RB_FUNC(rb_cocos2dx_Node_setScale));

    rb_define_method_bridge(classValue,"scale=",RB_FUNC(rb_cocos2dx_Node_setScale));
	

	rb_define_method_bridge(classValue,"getChildByTag",RB_FUNC(rb_cocos2dx_Node_getChildByTag));

   rb_define_method_bridge(classValue,"childByTag",RB_FUNC(rb_cocos2dx_Node_getChildByTag));
	

	rb_define_method_bridge(classValue,"setOrderOfArrival",RB_FUNC(rb_cocos2dx_Node_setOrderOfArrival));

    rb_define_method_bridge(classValue,"orderOfArrival=",RB_FUNC(rb_cocos2dx_Node_setOrderOfArrival));
	

	rb_define_method_bridge(classValue,"getScaleZ",RB_FUNC(rb_cocos2dx_Node_getScaleZ));

   rb_define_method_bridge(classValue,"scaleZ",RB_FUNC(rb_cocos2dx_Node_getScaleZ));
	

	rb_define_method_bridge(classValue,"getScaleY",RB_FUNC(rb_cocos2dx_Node_getScaleY));

   rb_define_method_bridge(classValue,"scaleY",RB_FUNC(rb_cocos2dx_Node_getScaleY));
	

	rb_define_method_bridge(classValue,"getScaleX",RB_FUNC(rb_cocos2dx_Node_getScaleX));

   rb_define_method_bridge(classValue,"scaleX",RB_FUNC(rb_cocos2dx_Node_getScaleX));
	

	rb_define_method_bridge(classValue,"setLocalZOrder",RB_FUNC(rb_cocos2dx_Node_setLocalZOrder));

    rb_define_method_bridge(classValue,"localZOrder=",RB_FUNC(rb_cocos2dx_Node_setLocalZOrder));
	

	rb_define_method_bridge(classValue,"getWorldToNodeAffineTransform",RB_FUNC(rb_cocos2dx_Node_getWorldToNodeAffineTransform));

   rb_define_method_bridge(classValue,"worldToNodeAffineTransform",RB_FUNC(rb_cocos2dx_Node_getWorldToNodeAffineTransform));
	

	rb_define_method_bridge(classValue,"setCascadeColorEnabled",RB_FUNC(rb_cocos2dx_Node_setCascadeColorEnabled));

    rb_define_method_bridge(classValue,"cascadeColorEnabled=",RB_FUNC(rb_cocos2dx_Node_setCascadeColorEnabled));
	

	rb_define_method_bridge(classValue,"setOpacity",RB_FUNC(rb_cocos2dx_Node_setOpacity));

    rb_define_method_bridge(classValue,"opacity=",RB_FUNC(rb_cocos2dx_Node_setOpacity));
	

	rb_define_method_bridge(classValue,"cleanup",RB_FUNC(rb_cocos2dx_Node_cleanup));

	

	rb_define_method_bridge(classValue,"getComponent",RB_FUNC(rb_cocos2dx_Node_getComponent));

   rb_define_method_bridge(classValue,"component",RB_FUNC(rb_cocos2dx_Node_getComponent));
	

	rb_define_method_bridge(classValue,"getContentSize",RB_FUNC(rb_cocos2dx_Node_getContentSize));

   rb_define_method_bridge(classValue,"contentSize",RB_FUNC(rb_cocos2dx_Node_getContentSize));
	

	rb_define_method_bridge(classValue,"stopAllActionsByTag",RB_FUNC(rb_cocos2dx_Node_stopAllActionsByTag));

	

	rb_define_method_bridge(classValue,"getColor",RB_FUNC(rb_cocos2dx_Node_getColor));

   rb_define_method_bridge(classValue,"color",RB_FUNC(rb_cocos2dx_Node_getColor));
	

	rb_define_method_bridge(classValue,"getBoundingBox",RB_FUNC(rb_cocos2dx_Node_getBoundingBox));

   rb_define_method_bridge(classValue,"boundingBox",RB_FUNC(rb_cocos2dx_Node_getBoundingBox));
	

	rb_define_method_bridge(classValue,"setEventDispatcher",RB_FUNC(rb_cocos2dx_Node_setEventDispatcher));

    rb_define_method_bridge(classValue,"eventDispatcher=",RB_FUNC(rb_cocos2dx_Node_setEventDispatcher));
	

	rb_define_method_bridge(classValue,"getGlobalZOrder",RB_FUNC(rb_cocos2dx_Node_getGlobalZOrder));

   rb_define_method_bridge(classValue,"globalZOrder",RB_FUNC(rb_cocos2dx_Node_getGlobalZOrder));
	

	rb_define_method_bridge(classValue,"draw",RB_FUNC(rb_cocos2dx_Node_draw));

	

	rb_define_method_bridge(classValue,"setUserObject",RB_FUNC(rb_cocos2dx_Node_setUserObject));

    rb_define_method_bridge(classValue,"userObject=",RB_FUNC(rb_cocos2dx_Node_setUserObject));
	

	rb_define_method_bridge(classValue,"removeFromParent",RB_FUNC(rb_cocos2dx_Node_removeFromParentAndCleanup));

	

	rb_define_method_bridge(classValue,"setPosition3D",RB_FUNC(rb_cocos2dx_Node_setPosition3D));

    rb_define_method_bridge(classValue,"position3D=",RB_FUNC(rb_cocos2dx_Node_setPosition3D));
	

	rb_define_method_bridge(classValue,"update",RB_FUNC(rb_cocos2dx_Node_update));

	

	rb_define_method_bridge(classValue,"sortAllChildren",RB_FUNC(rb_cocos2dx_Node_sortAllChildren));

	

	rb_define_method_bridge(classValue,"getWorldToNodeTransform",RB_FUNC(rb_cocos2dx_Node_getWorldToNodeTransform));

   rb_define_method_bridge(classValue,"worldToNodeTransform",RB_FUNC(rb_cocos2dx_Node_getWorldToNodeTransform));
	

	rb_define_method_bridge(classValue,"setGLProgram",RB_FUNC(rb_cocos2dx_Node_setGLProgram));

    rb_define_method_bridge(classValue,"gLProgram=",RB_FUNC(rb_cocos2dx_Node_setGLProgram));
	

	rb_define_method_bridge(classValue,"getScale",RB_FUNC(rb_cocos2dx_Node_getScale));

   rb_define_method_bridge(classValue,"scale",RB_FUNC(rb_cocos2dx_Node_getScale));
	

	rb_define_method_bridge(classValue,"getNormalizedPosition",RB_FUNC(rb_cocos2dx_Node_getNormalizedPosition));

   rb_define_method_bridge(classValue,"normalizedPosition",RB_FUNC(rb_cocos2dx_Node_getNormalizedPosition));
	

	rb_define_method_bridge(classValue,"getRotationSkewX",RB_FUNC(rb_cocos2dx_Node_getRotationSkewX));

   rb_define_method_bridge(classValue,"rotationSkewX",RB_FUNC(rb_cocos2dx_Node_getRotationSkewX));
	

	rb_define_method_bridge(classValue,"getRotationSkewY",RB_FUNC(rb_cocos2dx_Node_getRotationSkewY));

   rb_define_method_bridge(classValue,"rotationSkewY",RB_FUNC(rb_cocos2dx_Node_getRotationSkewY));
	

	rb_define_method_bridge(classValue,"setTag",RB_FUNC(rb_cocos2dx_Node_setTag));

    rb_define_method_bridge(classValue,"tag=",RB_FUNC(rb_cocos2dx_Node_setTag));
	

	rb_define_method_bridge(classValue,"isCascadeColorEnabled",RB_FUNC(rb_cocos2dx_Node_isCascadeColorEnabled));

	

	rb_define_method_bridge(classValue,"stopAction",RB_FUNC(rb_cocos2dx_Node_stopAction));

	

	rb_define_method_bridge(classValue,"getActionManager",RB_FUNC(rb_cocos2dx_Node_getActionManager));

   rb_define_method_bridge(classValue,"actionManager",RB_FUNC(rb_cocos2dx_Node_getActionManager));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Node_create));

	


	TypeTest<cocos2d::Node> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Node",classValue);
}
RBVAL rb_cocos2dx_Scene_render(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Scene* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Scene_render : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Renderer* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Scene_render : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->render(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Scene_render : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Scene_createWithSize(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::Size arg0;
		ok &= rb_value_to_ccsize(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Scene_createWithSize : Error processing arguments");return RBNil();}
		cocos2d::Scene* ret = cocos2d::Scene::createWithSize(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Scene>((cocos2d::Scene*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Scene_createWithSize : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_Scene_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::Scene* ret = cocos2d::Scene::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Scene>((cocos2d::Scene*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Scene_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_Scene_createWithPhysics(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::Scene* ret = cocos2d::Scene::createWithPhysics();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Scene>((cocos2d::Scene*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Scene_createWithPhysics : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Scene() {
		
	RBVAL classValue=rb_define_class_bridge("Scene",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"render",RB_FUNC(rb_cocos2dx_Scene_render));

	

	

	rb_define_singleton_method_bridge(classValue,"createWithSize",RB_FUNC(rb_cocos2dx_Scene_createWithSize));

	
	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Scene_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithPhysics",RB_FUNC(rb_cocos2dx_Scene_createWithPhysics));

	


	TypeTest<cocos2d::Scene> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Scene",classValue);
}
RBVAL rb_cocos2dx_GLView_setFrameSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setFrameSize : self ptr is null");return RBNil();}
		if (argc == 2) {
			float arg0;
			float arg1;
			ok &= rb_value_to_float(argv[0], &arg0);
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setFrameSize : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setFrameSize(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_setFrameSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_getViewPortRect(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_getViewPortRect : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Rect& ret = cobj->getViewPortRect();
				value = ccrect_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_getViewPortRect : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_setContentScaleFactor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setContentScaleFactor : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setContentScaleFactor : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->setContentScaleFactor(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_setContentScaleFactor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_getContentScaleFactor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_getContentScaleFactor : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getContentScaleFactor();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_getContentScaleFactor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_setIMEKeyboardState(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setIMEKeyboardState : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setIMEKeyboardState : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setIMEKeyboardState(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("iMEKeyboardState");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_setIMEKeyboardState : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_setScissorInPoints(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setScissorInPoints : self ptr is null");return RBNil();}
		if (argc == 4) {
			float arg0;
			float arg1;
			float arg2;
			float arg3;
			ok &= rb_value_to_float(argv[0], &arg0);
			ok &= rb_value_to_float(argv[1], &arg1);
			ok &= rb_value_to_float(argv[2], &arg2);
			ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setScissorInPoints : Error processing argument 4 ( 4 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setScissorInPoints(arg0, arg1, arg2, arg3);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_setScissorInPoints : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_getViewName(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_getViewName : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const std::string& ret = cobj->getViewName();
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_getViewName : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_isOpenGLReady(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_isOpenGLReady : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isOpenGLReady();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_isOpenGLReady : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_end(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_end : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->end();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_end : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_getScaleY(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_getScaleY : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getScaleY();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_getScaleY : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_getScaleX(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_getScaleX : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getScaleX();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_getScaleX : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_getVisibleOrigin(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_getVisibleOrigin : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getVisibleOrigin();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_getVisibleOrigin : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_getFrameSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_getFrameSize : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Size& ret = cobj->getFrameSize();
				value = ccsize_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_getFrameSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_setFrameZoomFactor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setFrameZoomFactor : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setFrameZoomFactor : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setFrameZoomFactor(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("frameZoomFactor");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_setFrameZoomFactor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_getFrameZoomFactor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_getFrameZoomFactor : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getFrameZoomFactor();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_getFrameZoomFactor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_getDesignResolutionSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_getDesignResolutionSize : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Size& ret = cobj->getDesignResolutionSize();
				value = ccsize_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_getDesignResolutionSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_windowShouldClose(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_windowShouldClose : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->windowShouldClose();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_windowShouldClose : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_swapBuffers(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_swapBuffers : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->swapBuffers();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_swapBuffers : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_setDesignResolutionSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setDesignResolutionSize : self ptr is null");return RBNil();}
		if (argc == 3) {
			float arg0;
			float arg1;
			ResolutionPolicy arg2;
			ok &= rb_value_to_float(argv[0], &arg0);
			ok &= rb_value_to_float(argv[1], &arg1);
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setDesignResolutionSize : Error processing argument 3 ( 3 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDesignResolutionSize(arg0, arg1, arg2);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_setDesignResolutionSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_getResolutionPolicy(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_getResolutionPolicy : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getResolutionPolicy();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_getResolutionPolicy : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_isRetinaDisplay(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_isRetinaDisplay : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isRetinaDisplay();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_isRetinaDisplay : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_setViewPortInPoints(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setViewPortInPoints : self ptr is null");return RBNil();}
		if (argc == 4) {
			float arg0;
			float arg1;
			float arg2;
			float arg3;
			ok &= rb_value_to_float(argv[0], &arg0);
			ok &= rb_value_to_float(argv[1], &arg1);
			ok &= rb_value_to_float(argv[2], &arg2);
			ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setViewPortInPoints : Error processing argument 4 ( 4 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setViewPortInPoints(arg0, arg1, arg2, arg3);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_setViewPortInPoints : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_getScissorRect(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_getScissorRect : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Rect ret = cobj->getScissorRect();
				value = ccrect_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_getScissorRect : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_getRetinaFactor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_getRetinaFactor : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getRetinaFactor();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_getRetinaFactor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_setViewName(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setViewName : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setViewName : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setViewName(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("viewName");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_setViewName : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_getVisibleRect(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_getVisibleRect : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Rect ret = cobj->getVisibleRect();
				value = ccrect_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_getVisibleRect : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_getVisibleSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_getVisibleSize : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Size ret = cobj->getVisibleSize();
				value = ccsize_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_getVisibleSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_isScissorEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_isScissorEnabled : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isScissorEnabled();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_isScissorEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_pollEvents(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLView* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_pollEvents : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->pollEvents();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLView_pollEvents : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLView_setGLContextAttrs(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		GLContextAttrs arg0;
		#pragma warning NO CONVERSION TO NATIVE FOR GLContextAttrs
		ok = false;
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLView_setGLContextAttrs : Error processing arguments");return RBNil();}
		cocos2d::GLView::setGLContextAttrs(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("gLContextAttrs");
				}
				rb_cvar_set_bridge(clazz,propSYM,argv[0]);
		RBVAL value=RBNil();
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_GLView_setGLContextAttrs : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_GLView_getGLContextAttrs(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		GLContextAttrs ret = cocos2d::GLView::getGLContextAttrs();
		RBVAL value=RBNil();
		#pragma warning NO CONVERSION FROM NATIVE FOR GLContextAttrs;
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_GLView_getGLContextAttrs : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_GLView() {
		
	RBVAL classValue=rb_define_class_bridge("GLView",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"setFrameSize",RB_FUNC(rb_cocos2dx_GLView_setFrameSize));

    rb_define_method_bridge(classValue,"frameSize=",RB_FUNC(rb_cocos2dx_GLView_setFrameSize));
	

	rb_define_method_bridge(classValue,"getViewPortRect",RB_FUNC(rb_cocos2dx_GLView_getViewPortRect));

   rb_define_method_bridge(classValue,"viewPortRect",RB_FUNC(rb_cocos2dx_GLView_getViewPortRect));
	

	rb_define_method_bridge(classValue,"setContentScaleFactor",RB_FUNC(rb_cocos2dx_GLView_setContentScaleFactor));

    rb_define_method_bridge(classValue,"contentScaleFactor=",RB_FUNC(rb_cocos2dx_GLView_setContentScaleFactor));
	

	rb_define_method_bridge(classValue,"getContentScaleFactor",RB_FUNC(rb_cocos2dx_GLView_getContentScaleFactor));

   rb_define_method_bridge(classValue,"contentScaleFactor",RB_FUNC(rb_cocos2dx_GLView_getContentScaleFactor));
	

	rb_define_method_bridge(classValue,"setIMEKeyboardState",RB_FUNC(rb_cocos2dx_GLView_setIMEKeyboardState));

    rb_define_method_bridge(classValue,"iMEKeyboardState=",RB_FUNC(rb_cocos2dx_GLView_setIMEKeyboardState));
	

	rb_define_method_bridge(classValue,"setScissorInPoints",RB_FUNC(rb_cocos2dx_GLView_setScissorInPoints));

    rb_define_method_bridge(classValue,"scissorInPoints=",RB_FUNC(rb_cocos2dx_GLView_setScissorInPoints));
	

	rb_define_method_bridge(classValue,"getViewName",RB_FUNC(rb_cocos2dx_GLView_getViewName));

   rb_define_method_bridge(classValue,"viewName",RB_FUNC(rb_cocos2dx_GLView_getViewName));
	

	rb_define_method_bridge(classValue,"isOpenGLReady",RB_FUNC(rb_cocos2dx_GLView_isOpenGLReady));

	

	rb_define_method_bridge(classValue,"end",RB_FUNC(rb_cocos2dx_GLView_end));

	

	rb_define_method_bridge(classValue,"getScaleY",RB_FUNC(rb_cocos2dx_GLView_getScaleY));

   rb_define_method_bridge(classValue,"scaleY",RB_FUNC(rb_cocos2dx_GLView_getScaleY));
	

	rb_define_method_bridge(classValue,"getScaleX",RB_FUNC(rb_cocos2dx_GLView_getScaleX));

   rb_define_method_bridge(classValue,"scaleX",RB_FUNC(rb_cocos2dx_GLView_getScaleX));
	

	rb_define_method_bridge(classValue,"getVisibleOrigin",RB_FUNC(rb_cocos2dx_GLView_getVisibleOrigin));

   rb_define_method_bridge(classValue,"visibleOrigin",RB_FUNC(rb_cocos2dx_GLView_getVisibleOrigin));
	

	rb_define_method_bridge(classValue,"getFrameSize",RB_FUNC(rb_cocos2dx_GLView_getFrameSize));

   rb_define_method_bridge(classValue,"frameSize",RB_FUNC(rb_cocos2dx_GLView_getFrameSize));
	

	rb_define_method_bridge(classValue,"setFrameZoomFactor",RB_FUNC(rb_cocos2dx_GLView_setFrameZoomFactor));

    rb_define_method_bridge(classValue,"frameZoomFactor=",RB_FUNC(rb_cocos2dx_GLView_setFrameZoomFactor));
	

	rb_define_method_bridge(classValue,"getFrameZoomFactor",RB_FUNC(rb_cocos2dx_GLView_getFrameZoomFactor));

   rb_define_method_bridge(classValue,"frameZoomFactor",RB_FUNC(rb_cocos2dx_GLView_getFrameZoomFactor));
	

	rb_define_method_bridge(classValue,"getDesignResolutionSize",RB_FUNC(rb_cocos2dx_GLView_getDesignResolutionSize));

   rb_define_method_bridge(classValue,"designResolutionSize",RB_FUNC(rb_cocos2dx_GLView_getDesignResolutionSize));
	

	rb_define_method_bridge(classValue,"windowShouldClose",RB_FUNC(rb_cocos2dx_GLView_windowShouldClose));

	

	rb_define_method_bridge(classValue,"swapBuffers",RB_FUNC(rb_cocos2dx_GLView_swapBuffers));

	

	rb_define_method_bridge(classValue,"setDesignResolutionSize",RB_FUNC(rb_cocos2dx_GLView_setDesignResolutionSize));

    rb_define_method_bridge(classValue,"designResolutionSize=",RB_FUNC(rb_cocos2dx_GLView_setDesignResolutionSize));
	

	rb_define_method_bridge(classValue,"getResolutionPolicy",RB_FUNC(rb_cocos2dx_GLView_getResolutionPolicy));

   rb_define_method_bridge(classValue,"resolutionPolicy",RB_FUNC(rb_cocos2dx_GLView_getResolutionPolicy));
	

	rb_define_method_bridge(classValue,"isRetinaDisplay",RB_FUNC(rb_cocos2dx_GLView_isRetinaDisplay));

	

	rb_define_method_bridge(classValue,"setViewPortInPoints",RB_FUNC(rb_cocos2dx_GLView_setViewPortInPoints));

    rb_define_method_bridge(classValue,"viewPortInPoints=",RB_FUNC(rb_cocos2dx_GLView_setViewPortInPoints));
	

	rb_define_method_bridge(classValue,"getScissorRect",RB_FUNC(rb_cocos2dx_GLView_getScissorRect));

   rb_define_method_bridge(classValue,"scissorRect",RB_FUNC(rb_cocos2dx_GLView_getScissorRect));
	

	rb_define_method_bridge(classValue,"getRetinaFactor",RB_FUNC(rb_cocos2dx_GLView_getRetinaFactor));

   rb_define_method_bridge(classValue,"retinaFactor",RB_FUNC(rb_cocos2dx_GLView_getRetinaFactor));
	

	rb_define_method_bridge(classValue,"setViewName",RB_FUNC(rb_cocos2dx_GLView_setViewName));

    rb_define_method_bridge(classValue,"viewName=",RB_FUNC(rb_cocos2dx_GLView_setViewName));
	

	rb_define_method_bridge(classValue,"getVisibleRect",RB_FUNC(rb_cocos2dx_GLView_getVisibleRect));

   rb_define_method_bridge(classValue,"visibleRect",RB_FUNC(rb_cocos2dx_GLView_getVisibleRect));
	

	rb_define_method_bridge(classValue,"getVisibleSize",RB_FUNC(rb_cocos2dx_GLView_getVisibleSize));

   rb_define_method_bridge(classValue,"visibleSize",RB_FUNC(rb_cocos2dx_GLView_getVisibleSize));
	

	rb_define_method_bridge(classValue,"isScissorEnabled",RB_FUNC(rb_cocos2dx_GLView_isScissorEnabled));

	

	rb_define_method_bridge(classValue,"pollEvents",RB_FUNC(rb_cocos2dx_GLView_pollEvents));

	

	

	rb_define_singleton_method_bridge(classValue,"setGLContextAttrs",RB_FUNC(rb_cocos2dx_GLView_setGLContextAttrs));

    rb_define_singleton_method_bridge(classValue,"gLContextAttrs=",RB_FUNC(rb_cocos2dx_GLView_setGLContextAttrs));
	
	

	rb_define_singleton_method_bridge(classValue,"getGLContextAttrs",RB_FUNC(rb_cocos2dx_GLView_getGLContextAttrs));

   rb_define_singleton_method_bridge(classValue,"gLContextAttrs",RB_FUNC(rb_cocos2dx_GLView_getGLContextAttrs));
	


	TypeTest<cocos2d::GLView> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::GLView",classValue);
}
RBVAL rb_cocos2dx_Director_pause(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_pause : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->pause();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_pause : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_setEventDispatcher(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setEventDispatcher : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::EventDispatcher* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setEventDispatcher : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEventDispatcher(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("eventDispatcher");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_setEventDispatcher : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_setContentScaleFactor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setContentScaleFactor : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setContentScaleFactor : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setContentScaleFactor(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("contentScaleFactor");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_setContentScaleFactor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getContentScaleFactor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getContentScaleFactor : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getContentScaleFactor();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getContentScaleFactor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getWinSizeInPixels(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getWinSizeInPixels : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Size ret = cobj->getWinSizeInPixels();
				value = ccsize_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getWinSizeInPixels : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getDeltaTime(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getDeltaTime : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getDeltaTime();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getDeltaTime : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_setGLDefaultValues(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setGLDefaultValues : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->setGLDefaultValues();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_setGLDefaultValues : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_setActionManager(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setActionManager : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ActionManager* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setActionManager : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setActionManager(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("actionManager");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_setActionManager : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_setAlphaBlending(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setAlphaBlending : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setAlphaBlending : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAlphaBlending(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("alphaBlending");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_setAlphaBlending : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_popToRootScene(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_popToRootScene : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->popToRootScene();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_popToRootScene : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_loadMatrix(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_loadMatrix : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::MATRIX_STACK_TYPE arg0;
			cocos2d::Mat4 arg1;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			ok &= rb_value_to_mat4(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_loadMatrix : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->loadMatrix(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_loadMatrix : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getNotificationNode(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getNotificationNode : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Node* ret = cobj->getNotificationNode();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getNotificationNode : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getWinSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getWinSize : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Size& ret = cobj->getWinSize();
				value = ccsize_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getWinSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getTextureCache(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getTextureCache : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::TextureCache* ret = cobj->getTextureCache();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::TextureCache>((cocos2d::TextureCache*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getTextureCache : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_isSendCleanupToScene(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_isSendCleanupToScene : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isSendCleanupToScene();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_isSendCleanupToScene : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getVisibleOrigin(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getVisibleOrigin : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getVisibleOrigin();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getVisibleOrigin : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_mainLoop(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_mainLoop : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->mainLoop();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_mainLoop : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_setDepthTest(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setDepthTest : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setDepthTest : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDepthTest(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("depthTest");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_setDepthTest : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getFrameRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getFrameRate : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getFrameRate();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getFrameRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getSecondsPerFrame(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getSecondsPerFrame : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getSecondsPerFrame();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getSecondsPerFrame : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_resetMatrixStack(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_resetMatrixStack : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->resetMatrixStack();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_resetMatrixStack : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_convertToUI(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_convertToUI : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_convertToUI : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->convertToUI(arg0);
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_convertToUI : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_pushMatrix(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_pushMatrix : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::MATRIX_STACK_TYPE arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_pushMatrix : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->pushMatrix(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_pushMatrix : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_setDefaultValues(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setDefaultValues : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->setDefaultValues();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_setDefaultValues : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_init(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_init : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->init();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_init : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_setScheduler(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setScheduler : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Scheduler* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setScheduler : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setScheduler(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("scheduler");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_setScheduler : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_startAnimation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_startAnimation : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->startAnimation();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_startAnimation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getOpenGLView(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getOpenGLView : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::GLView* ret = cobj->getOpenGLView();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::GLView>((cocos2d::GLView*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getOpenGLView : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getRunningScene(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getRunningScene : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Scene* ret = cobj->getRunningScene();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Scene>((cocos2d::Scene*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getRunningScene : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_setViewport(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setViewport : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->setViewport();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_setViewport : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_stopAnimation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_stopAnimation : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->stopAnimation();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_stopAnimation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_popToSceneStackLevel(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_popToSceneStackLevel : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_popToSceneStackLevel : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->popToSceneStackLevel(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_popToSceneStackLevel : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_resume(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_resume : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->resume();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_resume : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_isNextDeltaTimeZero(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_isNextDeltaTimeZero : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isNextDeltaTimeZero();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_isNextDeltaTimeZero : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_setOpenGLView(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setOpenGLView : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::GLView* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setOpenGLView : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setOpenGLView(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("openGLView");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_setOpenGLView : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_convertToGL(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_convertToGL : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_convertToGL : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->convertToGL(arg0);
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_convertToGL : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_purgeCachedData(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_purgeCachedData : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->purgeCachedData();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_purgeCachedData : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getTotalFrames(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getTotalFrames : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					unsigned int ret = cobj->getTotalFrames();
				value = uint_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getTotalFrames : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_runWithScene(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_runWithScene : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Scene* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_runWithScene : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->runWithScene(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_runWithScene : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_setNotificationNode(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setNotificationNode : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setNotificationNode : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setNotificationNode(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("notificationNode");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_setNotificationNode : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_drawScene(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_drawScene : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->drawScene();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_drawScene : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getMatrix(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getMatrix : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::MATRIX_STACK_TYPE arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getMatrix : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					const cocos2d::Mat4& ret = cobj->getMatrix(arg0);
				value = mat4_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getMatrix : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_popScene(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_popScene : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->popScene();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_popScene : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_loadIdentityMatrix(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_loadIdentityMatrix : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::MATRIX_STACK_TYPE arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_loadIdentityMatrix : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->loadIdentityMatrix(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_loadIdentityMatrix : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_isDisplayStats(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_isDisplayStats : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isDisplayStats();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_isDisplayStats : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_setProjection(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setProjection : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Director::Projection arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setProjection : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setProjection(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("projection");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_setProjection : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getConsole(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getConsole : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Console* ret = cobj->getConsole();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Console>((cocos2d::Console*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getConsole : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_multiplyMatrix(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_multiplyMatrix : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::MATRIX_STACK_TYPE arg0;
			cocos2d::Mat4 arg1;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			ok &= rb_value_to_mat4(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_multiplyMatrix : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->multiplyMatrix(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_multiplyMatrix : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getZEye(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getZEye : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getZEye();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getZEye : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_setNextDeltaTimeZero(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setNextDeltaTimeZero : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setNextDeltaTimeZero : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setNextDeltaTimeZero(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("nextDeltaTimeZero");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_setNextDeltaTimeZero : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_popMatrix(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_popMatrix : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::MATRIX_STACK_TYPE arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_popMatrix : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->popMatrix(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_popMatrix : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getVisibleSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getVisibleSize : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Size ret = cobj->getVisibleSize();
				value = ccsize_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getVisibleSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getScheduler(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getScheduler : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Scheduler* ret = cobj->getScheduler();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Scheduler>((cocos2d::Scheduler*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getScheduler : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_pushScene(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_pushScene : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Scene* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_pushScene : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->pushScene(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_pushScene : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getAnimationInterval(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getAnimationInterval : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					double ret = cobj->getAnimationInterval();
				value = double_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getAnimationInterval : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_isPaused(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_isPaused : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isPaused();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_isPaused : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_setDisplayStats(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setDisplayStats : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setDisplayStats : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDisplayStats(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("displayStats");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_setDisplayStats : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getEventDispatcher(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getEventDispatcher : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::EventDispatcher* ret = cobj->getEventDispatcher();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::EventDispatcher>((cocos2d::EventDispatcher*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getEventDispatcher : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_replaceScene(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_replaceScene : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Scene* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_replaceScene : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->replaceScene(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_replaceScene : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_setAnimationInterval(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setAnimationInterval : self ptr is null");return RBNil();}
		if (argc == 1) {
			double arg0;
			ok &= rb_value_to_double(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_setAnimationInterval : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAnimationInterval(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("animationInterval");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_setAnimationInterval : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getActionManager(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Director* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Director_getActionManager : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::ActionManager* ret = cobj->getActionManager();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionManager>((cocos2d::ActionManager*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Director_getActionManager : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Director_getInstance(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::Director* ret = cocos2d::Director::getInstance();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Director>((cocos2d::Director*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Director_getInstance : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Director() {
		
	RBVAL classValue=rb_define_class_bridge("Director",rb_get_root_class(),true);

	rb_define_method_bridge(classValue,"pause",RB_FUNC(rb_cocos2dx_Director_pause));

	

	rb_define_method_bridge(classValue,"setEventDispatcher",RB_FUNC(rb_cocos2dx_Director_setEventDispatcher));

    rb_define_method_bridge(classValue,"eventDispatcher=",RB_FUNC(rb_cocos2dx_Director_setEventDispatcher));
	

	rb_define_method_bridge(classValue,"setContentScaleFactor",RB_FUNC(rb_cocos2dx_Director_setContentScaleFactor));

    rb_define_method_bridge(classValue,"contentScaleFactor=",RB_FUNC(rb_cocos2dx_Director_setContentScaleFactor));
	

	rb_define_method_bridge(classValue,"getContentScaleFactor",RB_FUNC(rb_cocos2dx_Director_getContentScaleFactor));

   rb_define_method_bridge(classValue,"contentScaleFactor",RB_FUNC(rb_cocos2dx_Director_getContentScaleFactor));
	

	rb_define_method_bridge(classValue,"getWinSizeInPixels",RB_FUNC(rb_cocos2dx_Director_getWinSizeInPixels));

   rb_define_method_bridge(classValue,"winSizeInPixels",RB_FUNC(rb_cocos2dx_Director_getWinSizeInPixels));
	

	rb_define_method_bridge(classValue,"getDeltaTime",RB_FUNC(rb_cocos2dx_Director_getDeltaTime));

   rb_define_method_bridge(classValue,"deltaTime",RB_FUNC(rb_cocos2dx_Director_getDeltaTime));
	

	rb_define_method_bridge(classValue,"setGLDefaultValues",RB_FUNC(rb_cocos2dx_Director_setGLDefaultValues));

    rb_define_method_bridge(classValue,"gLDefaultValues=",RB_FUNC(rb_cocos2dx_Director_setGLDefaultValues));
	

	rb_define_method_bridge(classValue,"setActionManager",RB_FUNC(rb_cocos2dx_Director_setActionManager));

    rb_define_method_bridge(classValue,"actionManager=",RB_FUNC(rb_cocos2dx_Director_setActionManager));
	

	rb_define_method_bridge(classValue,"setAlphaBlending",RB_FUNC(rb_cocos2dx_Director_setAlphaBlending));

    rb_define_method_bridge(classValue,"alphaBlending=",RB_FUNC(rb_cocos2dx_Director_setAlphaBlending));
	

	rb_define_method_bridge(classValue,"popToRootScene",RB_FUNC(rb_cocos2dx_Director_popToRootScene));

	

	rb_define_method_bridge(classValue,"loadMatrix",RB_FUNC(rb_cocos2dx_Director_loadMatrix));

	

	rb_define_method_bridge(classValue,"getNotificationNode",RB_FUNC(rb_cocos2dx_Director_getNotificationNode));

   rb_define_method_bridge(classValue,"notificationNode",RB_FUNC(rb_cocos2dx_Director_getNotificationNode));
	

	rb_define_method_bridge(classValue,"getWinSize",RB_FUNC(rb_cocos2dx_Director_getWinSize));

   rb_define_method_bridge(classValue,"winSize",RB_FUNC(rb_cocos2dx_Director_getWinSize));
	

	rb_define_method_bridge(classValue,"getTextureCache",RB_FUNC(rb_cocos2dx_Director_getTextureCache));

   rb_define_method_bridge(classValue,"textureCache",RB_FUNC(rb_cocos2dx_Director_getTextureCache));
	

	rb_define_method_bridge(classValue,"isSendCleanupToScene",RB_FUNC(rb_cocos2dx_Director_isSendCleanupToScene));

	

	rb_define_method_bridge(classValue,"getVisibleOrigin",RB_FUNC(rb_cocos2dx_Director_getVisibleOrigin));

   rb_define_method_bridge(classValue,"visibleOrigin",RB_FUNC(rb_cocos2dx_Director_getVisibleOrigin));
	

	rb_define_method_bridge(classValue,"mainLoop",RB_FUNC(rb_cocos2dx_Director_mainLoop));

	

	rb_define_method_bridge(classValue,"setDepthTest",RB_FUNC(rb_cocos2dx_Director_setDepthTest));

    rb_define_method_bridge(classValue,"depthTest=",RB_FUNC(rb_cocos2dx_Director_setDepthTest));
	

	rb_define_method_bridge(classValue,"getFrameRate",RB_FUNC(rb_cocos2dx_Director_getFrameRate));

   rb_define_method_bridge(classValue,"frameRate",RB_FUNC(rb_cocos2dx_Director_getFrameRate));
	

	rb_define_method_bridge(classValue,"getSecondsPerFrame",RB_FUNC(rb_cocos2dx_Director_getSecondsPerFrame));

   rb_define_method_bridge(classValue,"secondsPerFrame",RB_FUNC(rb_cocos2dx_Director_getSecondsPerFrame));
	

	rb_define_method_bridge(classValue,"resetMatrixStack",RB_FUNC(rb_cocos2dx_Director_resetMatrixStack));

	

	rb_define_method_bridge(classValue,"convertToUI",RB_FUNC(rb_cocos2dx_Director_convertToUI));

	

	rb_define_method_bridge(classValue,"pushMatrix",RB_FUNC(rb_cocos2dx_Director_pushMatrix));

	

	rb_define_method_bridge(classValue,"setDefaultValues",RB_FUNC(rb_cocos2dx_Director_setDefaultValues));

    rb_define_method_bridge(classValue,"defaultValues=",RB_FUNC(rb_cocos2dx_Director_setDefaultValues));
	

	rb_define_method_bridge(classValue,"init",RB_FUNC(rb_cocos2dx_Director_init));

	

	rb_define_method_bridge(classValue,"setScheduler",RB_FUNC(rb_cocos2dx_Director_setScheduler));

    rb_define_method_bridge(classValue,"scheduler=",RB_FUNC(rb_cocos2dx_Director_setScheduler));
	

	rb_define_method_bridge(classValue,"startAnimation",RB_FUNC(rb_cocos2dx_Director_startAnimation));

	

	rb_define_method_bridge(classValue,"getOpenGLView",RB_FUNC(rb_cocos2dx_Director_getOpenGLView));

   rb_define_method_bridge(classValue,"openGLView",RB_FUNC(rb_cocos2dx_Director_getOpenGLView));
	

	rb_define_method_bridge(classValue,"getRunningScene",RB_FUNC(rb_cocos2dx_Director_getRunningScene));

   rb_define_method_bridge(classValue,"runningScene",RB_FUNC(rb_cocos2dx_Director_getRunningScene));
	

	rb_define_method_bridge(classValue,"setViewport",RB_FUNC(rb_cocos2dx_Director_setViewport));

    rb_define_method_bridge(classValue,"viewport=",RB_FUNC(rb_cocos2dx_Director_setViewport));
	

	rb_define_method_bridge(classValue,"stopAnimation",RB_FUNC(rb_cocos2dx_Director_stopAnimation));

	

	rb_define_method_bridge(classValue,"popToSceneStackLevel",RB_FUNC(rb_cocos2dx_Director_popToSceneStackLevel));

	

	rb_define_method_bridge(classValue,"resume",RB_FUNC(rb_cocos2dx_Director_resume));

	

	rb_define_method_bridge(classValue,"isNextDeltaTimeZero",RB_FUNC(rb_cocos2dx_Director_isNextDeltaTimeZero));

	

	rb_define_method_bridge(classValue,"setOpenGLView",RB_FUNC(rb_cocos2dx_Director_setOpenGLView));

    rb_define_method_bridge(classValue,"openGLView=",RB_FUNC(rb_cocos2dx_Director_setOpenGLView));
	

	rb_define_method_bridge(classValue,"convertToGL",RB_FUNC(rb_cocos2dx_Director_convertToGL));

	

	rb_define_method_bridge(classValue,"purgeCachedData",RB_FUNC(rb_cocos2dx_Director_purgeCachedData));

	

	rb_define_method_bridge(classValue,"getTotalFrames",RB_FUNC(rb_cocos2dx_Director_getTotalFrames));

   rb_define_method_bridge(classValue,"totalFrames",RB_FUNC(rb_cocos2dx_Director_getTotalFrames));
	

	rb_define_method_bridge(classValue,"runWithScene",RB_FUNC(rb_cocos2dx_Director_runWithScene));

	

	rb_define_method_bridge(classValue,"setNotificationNode",RB_FUNC(rb_cocos2dx_Director_setNotificationNode));

    rb_define_method_bridge(classValue,"notificationNode=",RB_FUNC(rb_cocos2dx_Director_setNotificationNode));
	

	rb_define_method_bridge(classValue,"drawScene",RB_FUNC(rb_cocos2dx_Director_drawScene));

	

	rb_define_method_bridge(classValue,"getMatrix",RB_FUNC(rb_cocos2dx_Director_getMatrix));

   rb_define_method_bridge(classValue,"matrix",RB_FUNC(rb_cocos2dx_Director_getMatrix));
	

	rb_define_method_bridge(classValue,"popScene",RB_FUNC(rb_cocos2dx_Director_popScene));

	

	rb_define_method_bridge(classValue,"loadIdentityMatrix",RB_FUNC(rb_cocos2dx_Director_loadIdentityMatrix));

	

	rb_define_method_bridge(classValue,"isDisplayStats",RB_FUNC(rb_cocos2dx_Director_isDisplayStats));

	

	rb_define_method_bridge(classValue,"setProjection",RB_FUNC(rb_cocos2dx_Director_setProjection));

    rb_define_method_bridge(classValue,"projection=",RB_FUNC(rb_cocos2dx_Director_setProjection));
	

	rb_define_method_bridge(classValue,"getConsole",RB_FUNC(rb_cocos2dx_Director_getConsole));

   rb_define_method_bridge(classValue,"console",RB_FUNC(rb_cocos2dx_Director_getConsole));
	

	rb_define_method_bridge(classValue,"multiplyMatrix",RB_FUNC(rb_cocos2dx_Director_multiplyMatrix));

	

	rb_define_method_bridge(classValue,"getZEye",RB_FUNC(rb_cocos2dx_Director_getZEye));

   rb_define_method_bridge(classValue,"zEye",RB_FUNC(rb_cocos2dx_Director_getZEye));
	

	rb_define_method_bridge(classValue,"setNextDeltaTimeZero",RB_FUNC(rb_cocos2dx_Director_setNextDeltaTimeZero));

    rb_define_method_bridge(classValue,"nextDeltaTimeZero=",RB_FUNC(rb_cocos2dx_Director_setNextDeltaTimeZero));
	

	rb_define_method_bridge(classValue,"popMatrix",RB_FUNC(rb_cocos2dx_Director_popMatrix));

	

	rb_define_method_bridge(classValue,"getVisibleSize",RB_FUNC(rb_cocos2dx_Director_getVisibleSize));

   rb_define_method_bridge(classValue,"visibleSize",RB_FUNC(rb_cocos2dx_Director_getVisibleSize));
	

	rb_define_method_bridge(classValue,"getScheduler",RB_FUNC(rb_cocos2dx_Director_getScheduler));

   rb_define_method_bridge(classValue,"scheduler",RB_FUNC(rb_cocos2dx_Director_getScheduler));
	

	rb_define_method_bridge(classValue,"pushScene",RB_FUNC(rb_cocos2dx_Director_pushScene));

	

	rb_define_method_bridge(classValue,"getAnimationInterval",RB_FUNC(rb_cocos2dx_Director_getAnimationInterval));

   rb_define_method_bridge(classValue,"animationInterval",RB_FUNC(rb_cocos2dx_Director_getAnimationInterval));
	

	rb_define_method_bridge(classValue,"isPaused",RB_FUNC(rb_cocos2dx_Director_isPaused));

	

	rb_define_method_bridge(classValue,"setDisplayStats",RB_FUNC(rb_cocos2dx_Director_setDisplayStats));

    rb_define_method_bridge(classValue,"displayStats=",RB_FUNC(rb_cocos2dx_Director_setDisplayStats));
	

	rb_define_method_bridge(classValue,"getEventDispatcher",RB_FUNC(rb_cocos2dx_Director_getEventDispatcher));

   rb_define_method_bridge(classValue,"eventDispatcher",RB_FUNC(rb_cocos2dx_Director_getEventDispatcher));
	

	rb_define_method_bridge(classValue,"replaceScene",RB_FUNC(rb_cocos2dx_Director_replaceScene));

	

	rb_define_method_bridge(classValue,"setAnimationInterval",RB_FUNC(rb_cocos2dx_Director_setAnimationInterval));

    rb_define_method_bridge(classValue,"animationInterval=",RB_FUNC(rb_cocos2dx_Director_setAnimationInterval));
	

	rb_define_method_bridge(classValue,"getActionManager",RB_FUNC(rb_cocos2dx_Director_getActionManager));

   rb_define_method_bridge(classValue,"actionManager",RB_FUNC(rb_cocos2dx_Director_getActionManager));
	

	

	rb_define_singleton_method_bridge(classValue,"getInstance",RB_FUNC(rb_cocos2dx_Director_getInstance));

   rb_define_singleton_method_bridge(classValue,"instance",RB_FUNC(rb_cocos2dx_Director_getInstance));
	


	TypeTest<cocos2d::Director> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Director",classValue);
}
RBVAL rb_cocos2dx_Timer_getInterval(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Timer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Timer_getInterval : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getInterval();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Timer_getInterval : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Timer_setupTimerWithInterval(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Timer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Timer_setupTimerWithInterval : self ptr is null");return RBNil();}
		if (argc == 3) {
			float arg0;
			unsigned int arg1;
			float arg2;
			ok &= rb_value_to_float(argv[0], &arg0);
			ok &= rb_value_to_uint(argv[1], &arg1);
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Timer_setupTimerWithInterval : Error processing argument 3 ( 3 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setupTimerWithInterval(arg0, arg1, arg2);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Timer_setupTimerWithInterval : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Timer_setInterval(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Timer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Timer_setInterval : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Timer_setInterval : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setInterval(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("interval");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Timer_setInterval : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Timer_update(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Timer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Timer_update : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Timer_update : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->update(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Timer_update : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Timer_trigger(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Timer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Timer_trigger : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->trigger();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Timer_trigger : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Timer_cancel(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Timer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Timer_cancel : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->cancel();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Timer_cancel : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_Timer() {
		
	RBVAL classValue=rb_define_class_bridge("Timer",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"getInterval",RB_FUNC(rb_cocos2dx_Timer_getInterval));

   rb_define_method_bridge(classValue,"interval",RB_FUNC(rb_cocos2dx_Timer_getInterval));
	

	rb_define_method_bridge(classValue,"setupTimerWithInterval",RB_FUNC(rb_cocos2dx_Timer_setupTimerWithInterval));

    rb_define_method_bridge(classValue,"upTimerWithInterval=",RB_FUNC(rb_cocos2dx_Timer_setupTimerWithInterval));
	

	rb_define_method_bridge(classValue,"setInterval",RB_FUNC(rb_cocos2dx_Timer_setInterval));

    rb_define_method_bridge(classValue,"interval=",RB_FUNC(rb_cocos2dx_Timer_setInterval));
	

	rb_define_method_bridge(classValue,"update",RB_FUNC(rb_cocos2dx_Timer_update));

	

	rb_define_method_bridge(classValue,"trigger",RB_FUNC(rb_cocos2dx_Timer_trigger));

	

	rb_define_method_bridge(classValue,"cancel",RB_FUNC(rb_cocos2dx_Timer_cancel));

	



	TypeTest<cocos2d::Timer> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Timer",classValue);
}
RBVAL rb_cocos2dx_Scheduler_setTimeScale(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Scheduler* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Scheduler_setTimeScale : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Scheduler_setTimeScale : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTimeScale(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("timeScale");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Scheduler_setTimeScale : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Scheduler_getTimeScale(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Scheduler* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Scheduler_getTimeScale : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getTimeScale();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Scheduler_getTimeScale : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Scheduler_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::Scheduler> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::Scheduler* cobj = new cocos2d::Scheduler();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Scheduler_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Scheduler() {
		
	RBVAL classValue=rb_define_class_bridge("Scheduler",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"setTimeScale",RB_FUNC(rb_cocos2dx_Scheduler_setTimeScale));

    rb_define_method_bridge(classValue,"timeScale=",RB_FUNC(rb_cocos2dx_Scheduler_setTimeScale));
	

	rb_define_method_bridge(classValue,"getTimeScale",RB_FUNC(rb_cocos2dx_Scheduler_getTimeScale));

   rb_define_method_bridge(classValue,"timeScale",RB_FUNC(rb_cocos2dx_Scheduler_getTimeScale));
	


	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_Scheduler_constructor));

	TypeTest<cocos2d::Scheduler> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Scheduler",classValue);
}
RBVAL rb_cocos2dx_FileUtils_fullPathForFilename(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_fullPathForFilename : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_fullPathForFilename : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					std::string ret = cobj->fullPathForFilename(arg0);
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_fullPathForFilename : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_getStringFromFile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_getStringFromFile : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_getStringFromFile : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					std::string ret = cobj->getStringFromFile(arg0);
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_getStringFromFile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_setFilenameLookupDictionary(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_setFilenameLookupDictionary : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ValueMap arg0;
			ok &= rb_value_to_ccvaluemap(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_setFilenameLookupDictionary : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setFilenameLookupDictionary(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("filenameLookupDictionary");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_setFilenameLookupDictionary : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_removeFile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_removeFile : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_removeFile : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->removeFile(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_removeFile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_isAbsolutePath(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_isAbsolutePath : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_isAbsolutePath : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->isAbsolutePath(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_isAbsolutePath : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_renameFile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_renameFile : self ptr is null");return RBNil();}
		if (argc == 3) {
			std::string arg0;
			std::string arg1;
			std::string arg2;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			ok &= rb_value_to_std_string(argv[1], &arg1);
			ok &= rb_value_to_std_string(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_renameFile : Error processing argument 3 ( 3 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->renameFile(arg0, arg1, arg2);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_renameFile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->loadFilenameLookupDictionaryFromFile(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_isPopupNotify(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_isPopupNotify : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isPopupNotify();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_isPopupNotify : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_writeToFile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_writeToFile : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::ValueMap arg0;
			std::string arg1;
			ok &= rb_value_to_ccvaluemap(argv[0], &arg0);
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_writeToFile : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->writeToFile(arg0, arg1);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_writeToFile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_getValueMapFromFile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_getValueMapFromFile : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_getValueMapFromFile : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::ValueMap ret = cobj->getValueMapFromFile(arg0);
				value = ccvaluemap_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_getValueMapFromFile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_getValueMapFromData(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_getValueMapFromData : self ptr is null");return RBNil();}
		if (argc == 2) {
			const char* arg0;
			int arg1;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_getValueMapFromData : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::ValueMap ret = cobj->getValueMapFromData(arg0, arg1);
				value = ccvaluemap_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_getValueMapFromData : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_removeDirectory(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_removeDirectory : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_removeDirectory : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->removeDirectory(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_removeDirectory : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_getFileSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_getFileSize : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_getFileSize : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					long ret = cobj->getFileSize(arg0);
				value = long_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_getFileSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_addSearchResolutionsOrder(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_addSearchResolutionsOrder : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_addSearchResolutionsOrder : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addSearchResolutionsOrder(arg0);
		return value;
		}
		if (argc == 2) {
			std::string arg0;
			bool arg1;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_addSearchResolutionsOrder : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addSearchResolutionsOrder(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_addSearchResolutionsOrder : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_addSearchPath(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_addSearchPath : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_addSearchPath : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addSearchPath(arg0);
		return value;
		}
		if (argc == 2) {
			std::string arg0;
			bool arg1;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_addSearchPath : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addSearchPath(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_addSearchPath : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_isFileExist(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_isFileExist : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_isFileExist : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->isFileExist(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_isFileExist : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_purgeCachedEntries(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_purgeCachedEntries : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->purgeCachedEntries();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_purgeCachedEntries : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_fullPathFromRelativeFile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_fullPathFromRelativeFile : self ptr is null");return RBNil();}
		if (argc == 2) {
			std::string arg0;
			std::string arg1;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_fullPathFromRelativeFile : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
					std::string ret = cobj->fullPathFromRelativeFile(arg0, arg1);
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_fullPathFromRelativeFile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_setPopupNotify(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_setPopupNotify : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_setPopupNotify : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setPopupNotify(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("popupNotify");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_setPopupNotify : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_isDirectoryExist(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_isDirectoryExist : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_isDirectoryExist : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->isDirectoryExist(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_isDirectoryExist : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_createDirectory(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_createDirectory : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_createDirectory : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->createDirectory(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_createDirectory : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_getWritablePath(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FileUtils* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FileUtils_getWritablePath : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					std::string ret = cobj->getWritablePath();
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FileUtils_getWritablePath : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FileUtils_destroyInstance(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::FileUtils::destroyInstance();
		RBVAL value=RBNil();
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_FileUtils_destroyInstance : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_FileUtils_getInstance(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::FileUtils* ret = cocos2d::FileUtils::getInstance();
		RBVAL value=RBNil();
		value = FileUtils_to_rb_value(ret);
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_FileUtils_getInstance : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_FileUtils() {
		
	RBVAL classValue=rb_define_class_bridge("FileUtils",rb_get_root_class(),true);

	rb_define_method_bridge(classValue,"fullPathForFilename",RB_FUNC(rb_cocos2dx_FileUtils_fullPathForFilename));

	

	rb_define_method_bridge(classValue,"getStringFromFile",RB_FUNC(rb_cocos2dx_FileUtils_getStringFromFile));

   rb_define_method_bridge(classValue,"stringFromFile",RB_FUNC(rb_cocos2dx_FileUtils_getStringFromFile));
	

	rb_define_method_bridge(classValue,"setFilenameLookupDictionary",RB_FUNC(rb_cocos2dx_FileUtils_setFilenameLookupDictionary));

    rb_define_method_bridge(classValue,"filenameLookupDictionary=",RB_FUNC(rb_cocos2dx_FileUtils_setFilenameLookupDictionary));
	

	rb_define_method_bridge(classValue,"removeFile",RB_FUNC(rb_cocos2dx_FileUtils_removeFile));

	

	rb_define_method_bridge(classValue,"isAbsolutePath",RB_FUNC(rb_cocos2dx_FileUtils_isAbsolutePath));

	

	rb_define_method_bridge(classValue,"renameFile",RB_FUNC(rb_cocos2dx_FileUtils_renameFile));

	

	rb_define_method_bridge(classValue,"loadFilenameLookup",RB_FUNC(rb_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile));

	

	rb_define_method_bridge(classValue,"isPopupNotify",RB_FUNC(rb_cocos2dx_FileUtils_isPopupNotify));

	

	rb_define_method_bridge(classValue,"writeToFile",RB_FUNC(rb_cocos2dx_FileUtils_writeToFile));

	

	rb_define_method_bridge(classValue,"getValueMapFromFile",RB_FUNC(rb_cocos2dx_FileUtils_getValueMapFromFile));

   rb_define_method_bridge(classValue,"valueMapFromFile",RB_FUNC(rb_cocos2dx_FileUtils_getValueMapFromFile));
	

	rb_define_method_bridge(classValue,"getValueMapFromData",RB_FUNC(rb_cocos2dx_FileUtils_getValueMapFromData));

   rb_define_method_bridge(classValue,"valueMapFromData",RB_FUNC(rb_cocos2dx_FileUtils_getValueMapFromData));
	

	rb_define_method_bridge(classValue,"removeDirectory",RB_FUNC(rb_cocos2dx_FileUtils_removeDirectory));

	

	rb_define_method_bridge(classValue,"getFileSize",RB_FUNC(rb_cocos2dx_FileUtils_getFileSize));

   rb_define_method_bridge(classValue,"fileSize",RB_FUNC(rb_cocos2dx_FileUtils_getFileSize));
	

	rb_define_method_bridge(classValue,"addSearchResolutionsOrder",RB_FUNC(rb_cocos2dx_FileUtils_addSearchResolutionsOrder));

	

	rb_define_method_bridge(classValue,"addSearchPath",RB_FUNC(rb_cocos2dx_FileUtils_addSearchPath));

	

	rb_define_method_bridge(classValue,"isFileExist",RB_FUNC(rb_cocos2dx_FileUtils_isFileExist));

	

	rb_define_method_bridge(classValue,"purgeCachedEntries",RB_FUNC(rb_cocos2dx_FileUtils_purgeCachedEntries));

	

	rb_define_method_bridge(classValue,"fullPathFromRelativeFile",RB_FUNC(rb_cocos2dx_FileUtils_fullPathFromRelativeFile));

	

	rb_define_method_bridge(classValue,"setPopupNotify",RB_FUNC(rb_cocos2dx_FileUtils_setPopupNotify));

    rb_define_method_bridge(classValue,"popupNotify=",RB_FUNC(rb_cocos2dx_FileUtils_setPopupNotify));
	

	rb_define_method_bridge(classValue,"isDirectoryExist",RB_FUNC(rb_cocos2dx_FileUtils_isDirectoryExist));

	

	rb_define_method_bridge(classValue,"createDirectory",RB_FUNC(rb_cocos2dx_FileUtils_createDirectory));

	

	rb_define_method_bridge(classValue,"getWritablePath",RB_FUNC(rb_cocos2dx_FileUtils_getWritablePath));

   rb_define_method_bridge(classValue,"writablePath",RB_FUNC(rb_cocos2dx_FileUtils_getWritablePath));
	

	

	rb_define_singleton_method_bridge(classValue,"destroyInstance",RB_FUNC(rb_cocos2dx_FileUtils_destroyInstance));

	
	

	rb_define_singleton_method_bridge(classValue,"getInstance",RB_FUNC(rb_cocos2dx_FileUtils_getInstance));

   rb_define_singleton_method_bridge(classValue,"instance",RB_FUNC(rb_cocos2dx_FileUtils_getInstance));
	


	TypeTest<cocos2d::FileUtils> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::FileUtils",classValue);
}
RBVAL rb_cocos2dx_UserDefault_setIntegerForKey(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::UserDefault* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_setIntegerForKey : self ptr is null");return RBNil();}
		if (argc == 2) {
			const char* arg0;
			int arg1;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_setIntegerForKey : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setIntegerForKey(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_UserDefault_setIntegerForKey : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_UserDefault_getFloatForKey(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::UserDefault* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getFloatForKey : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			const char* arg0;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getFloatForKey : Error processing argument 1 ( 2 )");return RBNil(); }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getFloatForKey : Error processing argument 2 ( 2 )");return RBNil(); }
			float ret = cobj->getFloatForKey(arg0, arg1);
			RBVAL value = RBNil();
			value = float_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 1) {
			const char* arg0;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getFloatForKey : Error processing argument 1 ( 1 )");return RBNil(); }
			float ret = cobj->getFloatForKey(arg0);
			RBVAL value = RBNil();
			value = float_to_rb_value(ret);
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_UserDefault_getFloatForKey : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_UserDefault_getBoolForKey(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::UserDefault* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getBoolForKey : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			const char* arg0;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getBoolForKey : Error processing argument 1 ( 2 )");return RBNil(); }
			bool arg1;
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getBoolForKey : Error processing argument 2 ( 2 )");return RBNil(); }
			bool ret = cobj->getBoolForKey(arg0, arg1);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 1) {
			const char* arg0;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getBoolForKey : Error processing argument 1 ( 1 )");return RBNil(); }
			bool ret = cobj->getBoolForKey(arg0);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_UserDefault_getBoolForKey : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_UserDefault_setDoubleForKey(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::UserDefault* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_setDoubleForKey : self ptr is null");return RBNil();}
		if (argc == 2) {
			const char* arg0;
			double arg1;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			ok &= rb_value_to_double(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_setDoubleForKey : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDoubleForKey(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_UserDefault_setDoubleForKey : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_UserDefault_setFloatForKey(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::UserDefault* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_setFloatForKey : self ptr is null");return RBNil();}
		if (argc == 2) {
			const char* arg0;
			float arg1;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_setFloatForKey : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setFloatForKey(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_UserDefault_setFloatForKey : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_UserDefault_getStringForKey(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::UserDefault* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getStringForKey : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			const char* arg0;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getStringForKey : Error processing argument 1 ( 2 )");return RBNil(); }
			std::string arg1;
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getStringForKey : Error processing argument 2 ( 2 )");return RBNil(); }
			std::string ret = cobj->getStringForKey(arg0, arg1);
			RBVAL value = RBNil();
			value = std_string_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 1) {
			const char* arg0;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getStringForKey : Error processing argument 1 ( 1 )");return RBNil(); }
			std::string ret = cobj->getStringForKey(arg0);
			RBVAL value = RBNil();
			value = std_string_to_rb_value(ret);
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_UserDefault_getStringForKey : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_UserDefault_setStringForKey(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::UserDefault* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_setStringForKey : self ptr is null");return RBNil();}
		if (argc == 2) {
			const char* arg0;
			std::string arg1;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_setStringForKey : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setStringForKey(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_UserDefault_setStringForKey : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_UserDefault_flush(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::UserDefault* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_flush : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->flush();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_UserDefault_flush : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_UserDefault_getIntegerForKey(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::UserDefault* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getIntegerForKey : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			const char* arg0;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getIntegerForKey : Error processing argument 1 ( 2 )");return RBNil(); }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getIntegerForKey : Error processing argument 2 ( 2 )");return RBNil(); }
			int ret = cobj->getIntegerForKey(arg0, arg1);
			RBVAL value = RBNil();
			value = int_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 1) {
			const char* arg0;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getIntegerForKey : Error processing argument 1 ( 1 )");return RBNil(); }
			int ret = cobj->getIntegerForKey(arg0);
			RBVAL value = RBNil();
			value = int_to_rb_value(ret);
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_UserDefault_getIntegerForKey : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_UserDefault_getDoubleForKey(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::UserDefault* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getDoubleForKey : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			const char* arg0;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getDoubleForKey : Error processing argument 1 ( 2 )");return RBNil(); }
			double arg1;
			ok &= rb_value_to_double(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getDoubleForKey : Error processing argument 2 ( 2 )");return RBNil(); }
			double ret = cobj->getDoubleForKey(arg0, arg1);
			RBVAL value = RBNil();
			value = double_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 1) {
			const char* arg0;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_getDoubleForKey : Error processing argument 1 ( 1 )");return RBNil(); }
			double ret = cobj->getDoubleForKey(arg0);
			RBVAL value = RBNil();
			value = double_to_rb_value(ret);
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_UserDefault_getDoubleForKey : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_UserDefault_setBoolForKey(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::UserDefault* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_setBoolForKey : self ptr is null");return RBNil();}
		if (argc == 2) {
			const char* arg0;
			bool arg1;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_UserDefault_setBoolForKey : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setBoolForKey(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_UserDefault_setBoolForKey : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_UserDefault_destroyInstance(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::UserDefault::destroyInstance();
		RBVAL value=RBNil();
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_UserDefault_destroyInstance : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_UserDefault_getXMLFilePath(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		const std::string& ret = cocos2d::UserDefault::getXMLFilePath();
		RBVAL value=RBNil();
		value = std_string_to_rb_value(ret);
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_UserDefault_getXMLFilePath : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_UserDefault_isXMLFileExist(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		bool ret = cocos2d::UserDefault::isXMLFileExist();
		RBVAL value=RBNil();
		value = bool_to_rb_value(ret);
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_UserDefault_isXMLFileExist : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_UserDefault() {
		
	RBVAL classValue=rb_define_class_bridge("UserDefault",rb_get_root_class(),true);

	rb_define_method_bridge(classValue,"setIntegerForKey",RB_FUNC(rb_cocos2dx_UserDefault_setIntegerForKey));

    rb_define_method_bridge(classValue,"integerForKey=",RB_FUNC(rb_cocos2dx_UserDefault_setIntegerForKey));
	

	rb_define_method_bridge(classValue,"getFloatForKey",RB_FUNC(rb_cocos2dx_UserDefault_getFloatForKey));

   rb_define_method_bridge(classValue,"floatForKey",RB_FUNC(rb_cocos2dx_UserDefault_getFloatForKey));
	

	rb_define_method_bridge(classValue,"getBoolForKey",RB_FUNC(rb_cocos2dx_UserDefault_getBoolForKey));

   rb_define_method_bridge(classValue,"boolForKey",RB_FUNC(rb_cocos2dx_UserDefault_getBoolForKey));
	

	rb_define_method_bridge(classValue,"setDoubleForKey",RB_FUNC(rb_cocos2dx_UserDefault_setDoubleForKey));

    rb_define_method_bridge(classValue,"doubleForKey=",RB_FUNC(rb_cocos2dx_UserDefault_setDoubleForKey));
	

	rb_define_method_bridge(classValue,"setFloatForKey",RB_FUNC(rb_cocos2dx_UserDefault_setFloatForKey));

    rb_define_method_bridge(classValue,"floatForKey=",RB_FUNC(rb_cocos2dx_UserDefault_setFloatForKey));
	

	rb_define_method_bridge(classValue,"getStringForKey",RB_FUNC(rb_cocos2dx_UserDefault_getStringForKey));

   rb_define_method_bridge(classValue,"stringForKey",RB_FUNC(rb_cocos2dx_UserDefault_getStringForKey));
	

	rb_define_method_bridge(classValue,"setStringForKey",RB_FUNC(rb_cocos2dx_UserDefault_setStringForKey));

    rb_define_method_bridge(classValue,"stringForKey=",RB_FUNC(rb_cocos2dx_UserDefault_setStringForKey));
	

	rb_define_method_bridge(classValue,"flush",RB_FUNC(rb_cocos2dx_UserDefault_flush));

	

	rb_define_method_bridge(classValue,"getIntegerForKey",RB_FUNC(rb_cocos2dx_UserDefault_getIntegerForKey));

   rb_define_method_bridge(classValue,"integerForKey",RB_FUNC(rb_cocos2dx_UserDefault_getIntegerForKey));
	

	rb_define_method_bridge(classValue,"getDoubleForKey",RB_FUNC(rb_cocos2dx_UserDefault_getDoubleForKey));

   rb_define_method_bridge(classValue,"doubleForKey",RB_FUNC(rb_cocos2dx_UserDefault_getDoubleForKey));
	

	rb_define_method_bridge(classValue,"setBoolForKey",RB_FUNC(rb_cocos2dx_UserDefault_setBoolForKey));

    rb_define_method_bridge(classValue,"boolForKey=",RB_FUNC(rb_cocos2dx_UserDefault_setBoolForKey));
	

	

	rb_define_singleton_method_bridge(classValue,"destroyInstance",RB_FUNC(rb_cocos2dx_UserDefault_destroyInstance));

	
	

	rb_define_singleton_method_bridge(classValue,"getXMLFilePath",RB_FUNC(rb_cocos2dx_UserDefault_getXMLFilePath));

   rb_define_singleton_method_bridge(classValue,"xMLFilePath",RB_FUNC(rb_cocos2dx_UserDefault_getXMLFilePath));
	
	

	rb_define_singleton_method_bridge(classValue,"isXMLFileExist",RB_FUNC(rb_cocos2dx_UserDefault_isXMLFileExist));

	


	TypeTest<cocos2d::UserDefault> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::UserDefault",classValue);
}
RBVAL rb_cocos2dx_EventListener_setEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventListener* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventListener_setEnabled : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventListener_setEnabled : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEnabled(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("enabled");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventListener_setEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventListener_clone(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventListener* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventListener_clone : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::EventListener* ret = cobj->clone();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::EventListener>((cocos2d::EventListener*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventListener_clone : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventListener_isEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventListener* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventListener_isEnabled : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isEnabled();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventListener_isEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventListener_checkAvailable(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventListener* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventListener_checkAvailable : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->checkAvailable();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventListener_checkAvailable : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_EventListener() {
		
	RBVAL classValue=rb_define_class_bridge("EventListener",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"setEnabled",RB_FUNC(rb_cocos2dx_EventListener_setEnabled));

    rb_define_method_bridge(classValue,"enabled=",RB_FUNC(rb_cocos2dx_EventListener_setEnabled));
	

	rb_define_method_bridge(classValue,"clone",RB_FUNC(rb_cocos2dx_EventListener_clone));

	

	rb_define_method_bridge(classValue,"isEnabled",RB_FUNC(rb_cocos2dx_EventListener_isEnabled));

	

	rb_define_method_bridge(classValue,"checkAvailable",RB_FUNC(rb_cocos2dx_EventListener_checkAvailable));

	



	TypeTest<cocos2d::EventListener> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EventListener",classValue);
}
RBVAL rb_cocos2dx_EventDispatcher_pauseEventListenersForTarget(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventDispatcher* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_pauseEventListenersForTarget : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_pauseEventListenersForTarget : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->pauseEventListenersForTarget(arg0);
		return value;
		}
		if (argc == 2) {
			cocos2d::Node* arg0;
			bool arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_pauseEventListenersForTarget : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->pauseEventListenersForTarget(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventDispatcher_pauseEventListenersForTarget : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventDispatcher* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::EventListener* arg0;
			cocos2d::Node* arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addEventListenerWithSceneGraphPriority(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventDispatcher_setEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventDispatcher* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_setEnabled : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_setEnabled : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEnabled(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("enabled");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventDispatcher_setEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventDispatcher* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::EventListener* arg0;
			int arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addEventListenerWithFixedPriority(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventDispatcher_removeEventListener(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventDispatcher* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_removeEventListener : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::EventListener* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_removeEventListener : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeEventListener(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventDispatcher_removeEventListener : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventDispatcher_resumeEventListenersForTarget(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventDispatcher* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_resumeEventListenersForTarget : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_resumeEventListenersForTarget : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->resumeEventListenersForTarget(arg0);
		return value;
		}
		if (argc == 2) {
			cocos2d::Node* arg0;
			bool arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_resumeEventListenersForTarget : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->resumeEventListenersForTarget(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventDispatcher_resumeEventListenersForTarget : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventDispatcher_removeEventListenersForTarget(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventDispatcher* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_removeEventListenersForTarget : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_removeEventListenersForTarget : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeEventListenersForTarget(arg0);
		return value;
		}
		if (argc == 2) {
			cocos2d::Node* arg0;
			bool arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_removeEventListenersForTarget : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeEventListenersForTarget(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventDispatcher_removeEventListenersForTarget : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventDispatcher_setPriority(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventDispatcher* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_setPriority : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::EventListener* arg0;
			int arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_setPriority : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setPriority(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventDispatcher_setPriority : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventDispatcher_addCustomEventListener(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventDispatcher* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_addCustomEventListener : self ptr is null");return RBNil();}
		if (argc == 2) {
			std::string arg0;
			std::function<void (cocos2d::EventCustom *)> arg1;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			do {
			RBVAL rbproc= argv[1];
			auto lambda = [=](cocos2d::EventCustom* larg0) -> void {
				RBVAL argarr=rb_array_new_brige();
				RBVAL templargv;
							if (larg0) {
						templargv = rbb_get_or_create_value<cocos2d::EventCustom>((cocos2d::EventCustom*)larg0);
					} else {
						templargv = RBNil();
					};
				rb_array_push_bridge(argarr,templargv);
				RBVAL value=rb_proc_call_bridge(rbproc, argarr);
			};
			arg1 = lambda;
		} while(0)
		;
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_addCustomEventListener : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::EventListenerCustom* ret = cobj->addCustomEventListener(arg0, arg1);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::EventListenerCustom>((cocos2d::EventListenerCustom*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventDispatcher_addCustomEventListener : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventDispatcher_dispatchEvent(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventDispatcher* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_dispatchEvent : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Event* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_dispatchEvent : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->dispatchEvent(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventDispatcher_dispatchEvent : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventDispatcher_removeAllEventListeners(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventDispatcher* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_removeAllEventListeners : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->removeAllEventListeners();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventDispatcher_removeAllEventListeners : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventDispatcher_removeCustomEventListeners(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventDispatcher* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_removeCustomEventListeners : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_removeCustomEventListeners : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeCustomEventListeners(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventDispatcher_removeCustomEventListeners : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventDispatcher_isEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventDispatcher* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_isEnabled : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isEnabled();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventDispatcher_isEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventDispatcher_removeEventListenersForType(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventDispatcher* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_removeEventListenersForType : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::EventListener::Type arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventDispatcher_removeEventListenersForType : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeEventListenersForType(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventDispatcher_removeEventListenersForType : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventDispatcher_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::EventDispatcher> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::EventDispatcher* cobj = new cocos2d::EventDispatcher();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventDispatcher_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EventDispatcher() {
		
	RBVAL classValue=rb_define_class_bridge("EventDispatcher",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"pauseEventListenersForTarget",RB_FUNC(rb_cocos2dx_EventDispatcher_pauseEventListenersForTarget));

	

	rb_define_method_bridge(classValue,"addEventListenerWithSceneGraphPriority",RB_FUNC(rb_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority));

	

	rb_define_method_bridge(classValue,"setEnabled",RB_FUNC(rb_cocos2dx_EventDispatcher_setEnabled));

    rb_define_method_bridge(classValue,"enabled=",RB_FUNC(rb_cocos2dx_EventDispatcher_setEnabled));
	

	rb_define_method_bridge(classValue,"addEventListenerWithFixedPriority",RB_FUNC(rb_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority));

	

	rb_define_method_bridge(classValue,"removeEventListener",RB_FUNC(rb_cocos2dx_EventDispatcher_removeEventListener));

	

	rb_define_method_bridge(classValue,"resumeEventListenersForTarget",RB_FUNC(rb_cocos2dx_EventDispatcher_resumeEventListenersForTarget));

	

	rb_define_method_bridge(classValue,"removeEventListenersForTarget",RB_FUNC(rb_cocos2dx_EventDispatcher_removeEventListenersForTarget));

	

	rb_define_method_bridge(classValue,"setPriority",RB_FUNC(rb_cocos2dx_EventDispatcher_setPriority));

    rb_define_method_bridge(classValue,"priority=",RB_FUNC(rb_cocos2dx_EventDispatcher_setPriority));
	

	rb_define_method_bridge(classValue,"addCustomEventListener",RB_FUNC(rb_cocos2dx_EventDispatcher_addCustomEventListener));

	

	rb_define_method_bridge(classValue,"dispatchEvent",RB_FUNC(rb_cocos2dx_EventDispatcher_dispatchEvent));

	

	rb_define_method_bridge(classValue,"removeAllEventListeners",RB_FUNC(rb_cocos2dx_EventDispatcher_removeAllEventListeners));

	

	rb_define_method_bridge(classValue,"removeCustomEventListeners",RB_FUNC(rb_cocos2dx_EventDispatcher_removeCustomEventListeners));

	

	rb_define_method_bridge(classValue,"isEnabled",RB_FUNC(rb_cocos2dx_EventDispatcher_isEnabled));

	

	rb_define_method_bridge(classValue,"removeEventListenersForType",RB_FUNC(rb_cocos2dx_EventDispatcher_removeEventListenersForType));

	


	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_EventDispatcher_constructor));

	TypeTest<cocos2d::EventDispatcher> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EventDispatcher",classValue);
}
RBVAL rb_cocos2dx_EventListenerTouchOneByOne_isSwallowTouches(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventListenerTouchOneByOne* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventListenerTouchOneByOne_isSwallowTouches : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isSwallowTouches();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventListenerTouchOneByOne_isSwallowTouches : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventListenerTouchOneByOne* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setSwallowTouches(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("swallowTouches");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventListenerTouchOneByOne_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::EventListenerTouchOneByOne* ret = cocos2d::EventListenerTouchOneByOne::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EventListenerTouchOneByOne>((cocos2d::EventListenerTouchOneByOne*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EventListenerTouchOneByOne_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EventListenerTouchOneByOne() {
		
	RBVAL classValue=rb_define_class_bridge("EventListenerTouchOneByOne",rb_get_class_value("cocos2d::EventListener"),true);

	rb_define_method_bridge(classValue,"isSwallowTouches",RB_FUNC(rb_cocos2dx_EventListenerTouchOneByOne_isSwallowTouches));

	

	rb_define_method_bridge(classValue,"setSwallowTouches",RB_FUNC(rb_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches));

    rb_define_method_bridge(classValue,"swallowTouches=",RB_FUNC(rb_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EventListenerTouchOneByOne_create));

	


	TypeTest<cocos2d::EventListenerTouchOneByOne> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EventListenerTouchOneByOne",classValue);
}
RBVAL rb_cocos2dx_EventListenerTouchAllAtOnce_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::EventListenerTouchAllAtOnce* ret = cocos2d::EventListenerTouchAllAtOnce::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EventListenerTouchAllAtOnce>((cocos2d::EventListenerTouchAllAtOnce*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EventListenerTouchAllAtOnce_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EventListenerTouchAllAtOnce() {
		
	RBVAL classValue=rb_define_class_bridge("EventListenerTouchAllAtOnce",rb_get_class_value("cocos2d::EventListener"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EventListenerTouchAllAtOnce_create));

	


	TypeTest<cocos2d::EventListenerTouchAllAtOnce> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EventListenerTouchAllAtOnce",classValue);
}
RBVAL rb_cocos2dx_EventListenerKeyboard_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::EventListenerKeyboard* ret = cocos2d::EventListenerKeyboard::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EventListenerKeyboard>((cocos2d::EventListenerKeyboard*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EventListenerKeyboard_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EventListenerKeyboard() {
		
	RBVAL classValue=rb_define_class_bridge("EventListenerKeyboard",rb_get_class_value("cocos2d::EventListener"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EventListenerKeyboard_create));

	


	TypeTest<cocos2d::EventListenerKeyboard> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EventListenerKeyboard",classValue);
}
RBVAL rb_cocos2dx_EventMouse_getPreviousLocationInView(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventMouse* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_getPreviousLocationInView : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getPreviousLocationInView();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventMouse_getPreviousLocationInView : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventMouse_getLocation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventMouse* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_getLocation : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getLocation();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventMouse_getLocation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventMouse_getMouseButton(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventMouse* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_getMouseButton : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getMouseButton();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventMouse_getMouseButton : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventMouse_getPreviousLocation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventMouse* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_getPreviousLocation : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getPreviousLocation();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventMouse_getPreviousLocation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventMouse_getDelta(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventMouse* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_getDelta : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getDelta();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventMouse_getDelta : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventMouse_setScrollData(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventMouse* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_setScrollData : self ptr is null");return RBNil();}
		if (argc == 2) {
			float arg0;
			float arg1;
			ok &= rb_value_to_float(argv[0], &arg0);
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_setScrollData : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setScrollData(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventMouse_setScrollData : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventMouse_getStartLocationInView(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventMouse* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_getStartLocationInView : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getStartLocationInView();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventMouse_getStartLocationInView : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventMouse_getStartLocation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventMouse* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_getStartLocation : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getStartLocation();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventMouse_getStartLocation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventMouse_setMouseButton(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventMouse* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_setMouseButton : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_setMouseButton : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setMouseButton(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("mouseButton");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventMouse_setMouseButton : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventMouse_getLocationInView(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventMouse* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_getLocationInView : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getLocationInView();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventMouse_getLocationInView : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventMouse_getScrollY(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventMouse* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_getScrollY : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getScrollY();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventMouse_getScrollY : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventMouse_getScrollX(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventMouse* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_getScrollX : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getScrollX();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventMouse_getScrollX : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventMouse_getCursorX(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventMouse* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_getCursorX : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getCursorX();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventMouse_getCursorX : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventMouse_getCursorY(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventMouse* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_getCursorY : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getCursorY();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventMouse_getCursorY : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventMouse_setCursorPosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventMouse* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_setCursorPosition : self ptr is null");return RBNil();}
		if (argc == 2) {
			float arg0;
			float arg1;
			ok &= rb_value_to_float(argv[0], &arg0);
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_setCursorPosition : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setCursorPosition(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventMouse_setCursorPosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventMouse_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::EventMouse> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 1) {
			cocos2d::EventMouse::MouseEventType arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventMouse_constructor : Error processing argument 1 ( 1 )");return RBNil();}
			cocos2d::EventMouse* cobj = new cocos2d::EventMouse(arg0);
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventMouse_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EventMouse() {
		
	RBVAL classValue=rb_define_class_bridge("EventMouse",rb_get_class_value("cocos2d::Event"),true);

	rb_define_method_bridge(classValue,"getPreviousLocationInView",RB_FUNC(rb_cocos2dx_EventMouse_getPreviousLocationInView));

   rb_define_method_bridge(classValue,"previousLocationInView",RB_FUNC(rb_cocos2dx_EventMouse_getPreviousLocationInView));
	

	rb_define_method_bridge(classValue,"getLocation",RB_FUNC(rb_cocos2dx_EventMouse_getLocation));

   rb_define_method_bridge(classValue,"location",RB_FUNC(rb_cocos2dx_EventMouse_getLocation));
	

	rb_define_method_bridge(classValue,"getMouseButton",RB_FUNC(rb_cocos2dx_EventMouse_getMouseButton));

   rb_define_method_bridge(classValue,"mouseButton",RB_FUNC(rb_cocos2dx_EventMouse_getMouseButton));
	

	rb_define_method_bridge(classValue,"getPreviousLocation",RB_FUNC(rb_cocos2dx_EventMouse_getPreviousLocation));

   rb_define_method_bridge(classValue,"previousLocation",RB_FUNC(rb_cocos2dx_EventMouse_getPreviousLocation));
	

	rb_define_method_bridge(classValue,"getDelta",RB_FUNC(rb_cocos2dx_EventMouse_getDelta));

   rb_define_method_bridge(classValue,"delta",RB_FUNC(rb_cocos2dx_EventMouse_getDelta));
	

	rb_define_method_bridge(classValue,"setScrollData",RB_FUNC(rb_cocos2dx_EventMouse_setScrollData));

    rb_define_method_bridge(classValue,"scrollData=",RB_FUNC(rb_cocos2dx_EventMouse_setScrollData));
	

	rb_define_method_bridge(classValue,"getStartLocationInView",RB_FUNC(rb_cocos2dx_EventMouse_getStartLocationInView));

   rb_define_method_bridge(classValue,"startLocationInView",RB_FUNC(rb_cocos2dx_EventMouse_getStartLocationInView));
	

	rb_define_method_bridge(classValue,"getStartLocation",RB_FUNC(rb_cocos2dx_EventMouse_getStartLocation));

   rb_define_method_bridge(classValue,"startLocation",RB_FUNC(rb_cocos2dx_EventMouse_getStartLocation));
	

	rb_define_method_bridge(classValue,"setMouseButton",RB_FUNC(rb_cocos2dx_EventMouse_setMouseButton));

    rb_define_method_bridge(classValue,"mouseButton=",RB_FUNC(rb_cocos2dx_EventMouse_setMouseButton));
	

	rb_define_method_bridge(classValue,"getLocationInView",RB_FUNC(rb_cocos2dx_EventMouse_getLocationInView));

   rb_define_method_bridge(classValue,"locationInView",RB_FUNC(rb_cocos2dx_EventMouse_getLocationInView));
	

	rb_define_method_bridge(classValue,"getScrollY",RB_FUNC(rb_cocos2dx_EventMouse_getScrollY));

   rb_define_method_bridge(classValue,"scrollY",RB_FUNC(rb_cocos2dx_EventMouse_getScrollY));
	

	rb_define_method_bridge(classValue,"getScrollX",RB_FUNC(rb_cocos2dx_EventMouse_getScrollX));

   rb_define_method_bridge(classValue,"scrollX",RB_FUNC(rb_cocos2dx_EventMouse_getScrollX));
	

	rb_define_method_bridge(classValue,"getCursorX",RB_FUNC(rb_cocos2dx_EventMouse_getCursorX));

   rb_define_method_bridge(classValue,"cursorX",RB_FUNC(rb_cocos2dx_EventMouse_getCursorX));
	

	rb_define_method_bridge(classValue,"getCursorY",RB_FUNC(rb_cocos2dx_EventMouse_getCursorY));

   rb_define_method_bridge(classValue,"cursorY",RB_FUNC(rb_cocos2dx_EventMouse_getCursorY));
	

	rb_define_method_bridge(classValue,"setCursorPosition",RB_FUNC(rb_cocos2dx_EventMouse_setCursorPosition));

    rb_define_method_bridge(classValue,"cursorPosition=",RB_FUNC(rb_cocos2dx_EventMouse_setCursorPosition));
	


	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_EventMouse_constructor));

	TypeTest<cocos2d::EventMouse> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EventMouse",classValue);
}
RBVAL rb_cocos2dx_EventListenerMouse_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::EventListenerMouse* ret = cocos2d::EventListenerMouse::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EventListenerMouse>((cocos2d::EventListenerMouse*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EventListenerMouse_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EventListenerMouse() {
		
	RBVAL classValue=rb_define_class_bridge("EventListenerMouse",rb_get_class_value("cocos2d::EventListener"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EventListenerMouse_create));

	


	TypeTest<cocos2d::EventListenerMouse> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EventListenerMouse",classValue);
}


void rb_register_cocos2dx_EventAcceleration() {
		
	RBVAL classValue=rb_define_class_bridge("EventAcceleration",rb_get_class_value("cocos2d::Event"),true);



	TypeTest<cocos2d::EventAcceleration> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EventAcceleration",classValue);
}
RBVAL rb_cocos2dx_EventListenerAcceleration_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		std::function<void (cocos2d::Acceleration *, cocos2d::Event *)> arg0;
		do {
			RBVAL rbproc= argv[0];
			auto lambda = [=](cocos2d::Acceleration* larg0, cocos2d::Event* larg1) -> void {
				RBVAL argarr=rb_array_new_brige();
				RBVAL templargv;
							if (larg0) {
						templargv = rbb_get_or_create_value<cocos2d::Acceleration>((cocos2d::Acceleration*)larg0);
					} else {
						templargv = RBNil();
					};
				rb_array_push_bridge(argarr,templargv);
							if (larg1) {
						templargv = rbb_get_or_create_value<cocos2d::Event>((cocos2d::Event*)larg1);
					} else {
						templargv = RBNil();
					};
				rb_array_push_bridge(argarr,templargv);
				RBVAL value=rb_proc_call_bridge(rbproc, argarr);
			};
			arg0 = lambda;
		} while(0)
		;
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventListenerAcceleration_create : Error processing arguments");return RBNil();}
		cocos2d::EventListenerAcceleration* ret = cocos2d::EventListenerAcceleration::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EventListenerAcceleration>((cocos2d::EventListenerAcceleration*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EventListenerAcceleration_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EventListenerAcceleration() {
		
	RBVAL classValue=rb_define_class_bridge("EventListenerAcceleration",rb_get_class_value("cocos2d::EventListener"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EventListenerAcceleration_create));

	


	TypeTest<cocos2d::EventListenerAcceleration> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EventListenerAcceleration",classValue);
}
RBVAL rb_cocos2dx_EventCustom_getEventName(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EventCustom* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventCustom_getEventName : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const std::string& ret = cobj->getEventName();
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventCustom_getEventName : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EventCustom_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::EventCustom> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventCustom_constructor : Error processing argument 1 ( 1 )");return RBNil();}
			cocos2d::EventCustom* cobj = new cocos2d::EventCustom(arg0);
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EventCustom_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EventCustom() {
		
	RBVAL classValue=rb_define_class_bridge("EventCustom",rb_get_class_value("cocos2d::Event"),true);

	rb_define_method_bridge(classValue,"getEventName",RB_FUNC(rb_cocos2dx_EventCustom_getEventName));

   rb_define_method_bridge(classValue,"eventName",RB_FUNC(rb_cocos2dx_EventCustom_getEventName));
	


	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_EventCustom_constructor));

	TypeTest<cocos2d::EventCustom> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EventCustom",classValue);
}
RBVAL rb_cocos2dx_EventListenerCustom_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		std::string arg0;
		std::function<void (cocos2d::EventCustom *)> arg1;
		ok &= rb_value_to_std_string(argv[0], &arg0);
		do {
			RBVAL rbproc= argv[1];
			auto lambda = [=](cocos2d::EventCustom* larg0) -> void {
				RBVAL argarr=rb_array_new_brige();
				RBVAL templargv;
							if (larg0) {
						templargv = rbb_get_or_create_value<cocos2d::EventCustom>((cocos2d::EventCustom*)larg0);
					} else {
						templargv = RBNil();
					};
				rb_array_push_bridge(argarr,templargv);
				RBVAL value=rb_proc_call_bridge(rbproc, argarr);
			};
			arg1 = lambda;
		} while(0)
		;
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EventListenerCustom_create : Error processing arguments");return RBNil();}
		cocos2d::EventListenerCustom* ret = cocos2d::EventListenerCustom::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EventListenerCustom>((cocos2d::EventListenerCustom*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EventListenerCustom_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EventListenerCustom() {
		
	RBVAL classValue=rb_define_class_bridge("EventListenerCustom",rb_get_class_value("cocos2d::EventListener"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EventListenerCustom_create));

	


	TypeTest<cocos2d::EventListenerCustom> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EventListenerCustom",classValue);
}


void rb_register_cocos2dx_EventFocus() {
		
	RBVAL classValue=rb_define_class_bridge("EventFocus",rb_get_class_value("cocos2d::Event"),true);



	TypeTest<cocos2d::EventFocus> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EventFocus",classValue);
}
RBVAL rb_cocos2dx_EventListenerFocus_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::EventListenerFocus* ret = cocos2d::EventListenerFocus::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EventListenerFocus>((cocos2d::EventListenerFocus*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EventListenerFocus_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EventListenerFocus() {
		
	RBVAL classValue=rb_define_class_bridge("EventListenerFocus",rb_get_class_value("cocos2d::EventListener"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EventListenerFocus_create));

	


	TypeTest<cocos2d::EventListenerFocus> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EventListenerFocus",classValue);
}
RBVAL rb_cocos2dx_Action_startWithTarget(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Action* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_startWithTarget : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_startWithTarget : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->startWithTarget(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Action_startWithTarget : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Action_setOriginalTarget(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Action* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_setOriginalTarget : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_setOriginalTarget : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setOriginalTarget(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("originalTarget");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Action_setOriginalTarget : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Action_clone(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Action* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_clone : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Action* ret = cobj->clone();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Action>((cocos2d::Action*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Action_clone : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Action_getOriginalTarget(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Action* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_getOriginalTarget : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Node* ret = cobj->getOriginalTarget();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Action_getOriginalTarget : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Action_stop(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Action* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_stop : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->stop();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Action_stop : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Action_update(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Action* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_update : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_update : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->update(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Action_update : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Action_getTarget(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Action* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_getTarget : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Node* ret = cobj->getTarget();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Action_getTarget : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Action_step(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Action* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_step : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_step : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->step(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Action_step : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Action_setTag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Action* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_setTag : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_setTag : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTag(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("tag");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Action_setTag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Action_getTag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Action* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_getTag : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getTag();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Action_getTag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Action_setTarget(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Action* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_setTarget : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_setTarget : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTarget(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("target");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Action_setTarget : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Action_isDone(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Action* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_isDone : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isDone();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Action_isDone : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Action_reverse(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Action* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Action_reverse : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Action* ret = cobj->reverse();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Action>((cocos2d::Action*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Action_reverse : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_Action() {
		
	RBVAL classValue=rb_define_class_bridge("Action",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"startWithTarget",RB_FUNC(rb_cocos2dx_Action_startWithTarget));

	

	rb_define_method_bridge(classValue,"setOriginalTarget",RB_FUNC(rb_cocos2dx_Action_setOriginalTarget));

    rb_define_method_bridge(classValue,"originalTarget=",RB_FUNC(rb_cocos2dx_Action_setOriginalTarget));
	

	rb_define_method_bridge(classValue,"clone",RB_FUNC(rb_cocos2dx_Action_clone));

	

	rb_define_method_bridge(classValue,"getOriginalTarget",RB_FUNC(rb_cocos2dx_Action_getOriginalTarget));

   rb_define_method_bridge(classValue,"originalTarget",RB_FUNC(rb_cocos2dx_Action_getOriginalTarget));
	

	rb_define_method_bridge(classValue,"stop",RB_FUNC(rb_cocos2dx_Action_stop));

	

	rb_define_method_bridge(classValue,"update",RB_FUNC(rb_cocos2dx_Action_update));

	

	rb_define_method_bridge(classValue,"getTarget",RB_FUNC(rb_cocos2dx_Action_getTarget));

   rb_define_method_bridge(classValue,"target",RB_FUNC(rb_cocos2dx_Action_getTarget));
	

	rb_define_method_bridge(classValue,"step",RB_FUNC(rb_cocos2dx_Action_step));

	

	rb_define_method_bridge(classValue,"setTag",RB_FUNC(rb_cocos2dx_Action_setTag));

    rb_define_method_bridge(classValue,"tag=",RB_FUNC(rb_cocos2dx_Action_setTag));
	

	rb_define_method_bridge(classValue,"getTag",RB_FUNC(rb_cocos2dx_Action_getTag));

   rb_define_method_bridge(classValue,"tag",RB_FUNC(rb_cocos2dx_Action_getTag));
	

	rb_define_method_bridge(classValue,"setTarget",RB_FUNC(rb_cocos2dx_Action_setTarget));

    rb_define_method_bridge(classValue,"target=",RB_FUNC(rb_cocos2dx_Action_setTarget));
	

	rb_define_method_bridge(classValue,"isDone",RB_FUNC(rb_cocos2dx_Action_isDone));

	

	rb_define_method_bridge(classValue,"reverse",RB_FUNC(rb_cocos2dx_Action_reverse));

	



	TypeTest<cocos2d::Action> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Action",classValue);
}
RBVAL rb_cocos2dx_FiniteTimeAction_setDuration(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FiniteTimeAction* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FiniteTimeAction_setDuration : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FiniteTimeAction_setDuration : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDuration(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("duration");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FiniteTimeAction_setDuration : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FiniteTimeAction_getDuration(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FiniteTimeAction* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FiniteTimeAction_getDuration : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getDuration();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FiniteTimeAction_getDuration : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_FiniteTimeAction() {
		
	RBVAL classValue=rb_define_class_bridge("FiniteTimeAction",rb_get_class_value("cocos2d::Action"),true);

	rb_define_method_bridge(classValue,"setDuration",RB_FUNC(rb_cocos2dx_FiniteTimeAction_setDuration));

    rb_define_method_bridge(classValue,"duration=",RB_FUNC(rb_cocos2dx_FiniteTimeAction_setDuration));
	

	rb_define_method_bridge(classValue,"getDuration",RB_FUNC(rb_cocos2dx_FiniteTimeAction_getDuration));

   rb_define_method_bridge(classValue,"duration",RB_FUNC(rb_cocos2dx_FiniteTimeAction_getDuration));
	



	TypeTest<cocos2d::FiniteTimeAction> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::FiniteTimeAction",classValue);
}
RBVAL rb_cocos2dx_Speed_setInnerAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Speed* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Speed_setInnerAction : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ActionInterval* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Speed_setInnerAction : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setInnerAction(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("innerAction");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Speed_setInnerAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Speed_setSpeed(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Speed* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Speed_setSpeed : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Speed_setSpeed : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setSpeed(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("speed");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Speed_setSpeed : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Speed_getInnerAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Speed* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Speed_getInnerAction : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->getInnerAction();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Speed_getInnerAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Speed_getSpeed(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Speed* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Speed_getSpeed : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getSpeed();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Speed_getSpeed : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Speed_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		cocos2d::ActionInterval* arg0;
		float arg1;
		ok &= rb_value_get_ptr(argv[0],&arg0);
		ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Speed_create : Error processing arguments");return RBNil();}
		cocos2d::Speed* ret = cocos2d::Speed::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Speed>((cocos2d::Speed*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Speed_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Speed() {
		
	RBVAL classValue=rb_define_class_bridge("Speed",rb_get_class_value("cocos2d::Action"),true);

	rb_define_method_bridge(classValue,"setInnerAction",RB_FUNC(rb_cocos2dx_Speed_setInnerAction));

    rb_define_method_bridge(classValue,"innerAction=",RB_FUNC(rb_cocos2dx_Speed_setInnerAction));
	

	rb_define_method_bridge(classValue,"setSpeed",RB_FUNC(rb_cocos2dx_Speed_setSpeed));

    rb_define_method_bridge(classValue,"speed=",RB_FUNC(rb_cocos2dx_Speed_setSpeed));
	

	rb_define_method_bridge(classValue,"getInnerAction",RB_FUNC(rb_cocos2dx_Speed_getInnerAction));

   rb_define_method_bridge(classValue,"innerAction",RB_FUNC(rb_cocos2dx_Speed_getInnerAction));
	

	rb_define_method_bridge(classValue,"getSpeed",RB_FUNC(rb_cocos2dx_Speed_getSpeed));

   rb_define_method_bridge(classValue,"speed",RB_FUNC(rb_cocos2dx_Speed_getSpeed));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Speed_create));

	


	TypeTest<cocos2d::Speed> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Speed",classValue);
}
RBVAL rb_cocos2dx_Follow_setBoundarySet(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Follow* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Follow_setBoundarySet : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Follow_setBoundarySet : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setBoundarySet(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("boundarySet");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Follow_setBoundarySet : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Follow_isBoundarySet(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Follow* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Follow_isBoundarySet : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isBoundarySet();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Follow_isBoundarySet : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Follow_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::Node* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Follow_create : Error processing arguments");return RBNil();}
		cocos2d::Follow* ret = cocos2d::Follow::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Follow>((cocos2d::Follow*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	if (argc == 2) {
		cocos2d::Node* arg0;
		cocos2d::Rect arg1;
		ok &= rb_value_get_ptr(argv[0],&arg0);
		ok &= rb_value_to_ccrect(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Follow_create : Error processing arguments");return RBNil();}
		cocos2d::Follow* ret = cocos2d::Follow::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Follow>((cocos2d::Follow*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Follow_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Follow() {
		
	RBVAL classValue=rb_define_class_bridge("Follow",rb_get_class_value("cocos2d::Action"),true);

	rb_define_method_bridge(classValue,"setBoundarySet",RB_FUNC(rb_cocos2dx_Follow_setBoundarySet));

    rb_define_method_bridge(classValue,"boundarySet=",RB_FUNC(rb_cocos2dx_Follow_setBoundarySet));
	

	rb_define_method_bridge(classValue,"isBoundarySet",RB_FUNC(rb_cocos2dx_Follow_isBoundarySet));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Follow_create));

	


	TypeTest<cocos2d::Follow> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Follow",classValue);
}
RBVAL rb_cocos2dx_SpriteFrame_clone(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_clone : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::SpriteFrame* ret = cobj->clone();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_clone : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_setRotated(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setRotated : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setRotated : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRotated(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("rotated");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setRotated : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_setTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setTexture : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Texture2D* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setTexture : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTexture(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("texture");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_getOffset(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_getOffset : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec2& ret = cobj->getOffset();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_getOffset : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_setRectInPixels(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setRectInPixels : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Rect arg0;
			ok &= rb_value_to_ccrect(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setRectInPixels : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRectInPixels(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("rectInPixels");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setRectInPixels : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_getTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_getTexture : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Texture2D* ret = cobj->getTexture();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Texture2D>((cocos2d::Texture2D*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_getTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_getRect(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_getRect : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Rect& ret = cobj->getRect();
				value = ccrect_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_getRect : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_setOffsetInPixels(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setOffsetInPixels : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setOffsetInPixels : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setOffsetInPixels(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("offsetInPixels");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setOffsetInPixels : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_getRectInPixels(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_getRectInPixels : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Rect& ret = cobj->getRectInPixels();
				value = ccrect_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_getRectInPixels : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_setOriginalSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setOriginalSize : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Size arg0;
			ok &= rb_value_to_ccsize(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setOriginalSize : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setOriginalSize(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("originalSize");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setOriginalSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_getOriginalSizeInPixels(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_getOriginalSizeInPixels : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Size& ret = cobj->getOriginalSizeInPixels();
				value = ccsize_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_getOriginalSizeInPixels : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_setOriginalSizeInPixels(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setOriginalSizeInPixels : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Size arg0;
			ok &= rb_value_to_ccsize(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setOriginalSizeInPixels : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setOriginalSizeInPixels(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("originalSizeInPixels");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setOriginalSizeInPixels : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_setOffset(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setOffset : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setOffset : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setOffset(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("offset");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setOffset : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_isRotated(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_isRotated : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isRotated();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_isRotated : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_setRect(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setRect : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Rect arg0;
			ok &= rb_value_to_ccrect(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setRect : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRect(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("rect");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_setRect : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_getOffsetInPixels(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_getOffsetInPixels : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec2& ret = cobj->getOffsetInPixels();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_getOffsetInPixels : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_getOriginalSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrame_getOriginalSize : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Size& ret = cobj->getOriginalSize();
				value = ccsize_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_getOriginalSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 5) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Rect arg1;
			ok &= rb_value_to_ccrect(argv[1], &arg1);
			if (!ok) { break; }
			bool arg2;
			ok &= rb_value_to_bool(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::Vec2 arg3;
			ok &= rb_value_to_vec2(argv[3], &arg3);
			if (!ok) { break; }
			cocos2d::Size arg4;
			ok &= rb_value_to_ccsize(argv[4], &arg4);
			if (!ok) { break; }
			cocos2d::SpriteFrame* ret = cocos2d::SpriteFrame::create(arg0, arg1, arg2, arg3, arg4);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 2) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Rect arg1;
			ok &= rb_value_to_ccrect(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::SpriteFrame* ret = cocos2d::SpriteFrame::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_create : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrame_createWithTexture(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 5) {
			cocos2d::Texture2D* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) { break; }
			cocos2d::Rect arg1;
			ok &= rb_value_to_ccrect(argv[1], &arg1);
			if (!ok) { break; }
			bool arg2;
			ok &= rb_value_to_bool(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::Vec2 arg3;
			ok &= rb_value_to_vec2(argv[3], &arg3);
			if (!ok) { break; }
			cocos2d::Size arg4;
			ok &= rb_value_to_ccsize(argv[4], &arg4);
			if (!ok) { break; }
			cocos2d::SpriteFrame* ret = cocos2d::SpriteFrame::createWithTexture(arg0, arg1, arg2, arg3, arg4);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 2) {
			cocos2d::Texture2D* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) { break; }
			cocos2d::Rect arg1;
			ok &= rb_value_to_ccrect(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::SpriteFrame* ret = cocos2d::SpriteFrame::createWithTexture(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_SpriteFrame_createWithTexture : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_SpriteFrame() {
		
	RBVAL classValue=rb_define_class_bridge("SpriteFrame",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"clone",RB_FUNC(rb_cocos2dx_SpriteFrame_clone));

	

	rb_define_method_bridge(classValue,"setRotated",RB_FUNC(rb_cocos2dx_SpriteFrame_setRotated));

    rb_define_method_bridge(classValue,"rotated=",RB_FUNC(rb_cocos2dx_SpriteFrame_setRotated));
	

	rb_define_method_bridge(classValue,"setTexture",RB_FUNC(rb_cocos2dx_SpriteFrame_setTexture));

    rb_define_method_bridge(classValue,"texture=",RB_FUNC(rb_cocos2dx_SpriteFrame_setTexture));
	

	rb_define_method_bridge(classValue,"getOffset",RB_FUNC(rb_cocos2dx_SpriteFrame_getOffset));

   rb_define_method_bridge(classValue,"offset",RB_FUNC(rb_cocos2dx_SpriteFrame_getOffset));
	

	rb_define_method_bridge(classValue,"setRectInPixels",RB_FUNC(rb_cocos2dx_SpriteFrame_setRectInPixels));

    rb_define_method_bridge(classValue,"rectInPixels=",RB_FUNC(rb_cocos2dx_SpriteFrame_setRectInPixels));
	

	rb_define_method_bridge(classValue,"getTexture",RB_FUNC(rb_cocos2dx_SpriteFrame_getTexture));

   rb_define_method_bridge(classValue,"texture",RB_FUNC(rb_cocos2dx_SpriteFrame_getTexture));
	

	rb_define_method_bridge(classValue,"getRect",RB_FUNC(rb_cocos2dx_SpriteFrame_getRect));

   rb_define_method_bridge(classValue,"rect",RB_FUNC(rb_cocos2dx_SpriteFrame_getRect));
	

	rb_define_method_bridge(classValue,"setOffsetInPixels",RB_FUNC(rb_cocos2dx_SpriteFrame_setOffsetInPixels));

    rb_define_method_bridge(classValue,"offsetInPixels=",RB_FUNC(rb_cocos2dx_SpriteFrame_setOffsetInPixels));
	

	rb_define_method_bridge(classValue,"getRectInPixels",RB_FUNC(rb_cocos2dx_SpriteFrame_getRectInPixels));

   rb_define_method_bridge(classValue,"rectInPixels",RB_FUNC(rb_cocos2dx_SpriteFrame_getRectInPixels));
	

	rb_define_method_bridge(classValue,"setOriginalSize",RB_FUNC(rb_cocos2dx_SpriteFrame_setOriginalSize));

    rb_define_method_bridge(classValue,"originalSize=",RB_FUNC(rb_cocos2dx_SpriteFrame_setOriginalSize));
	

	rb_define_method_bridge(classValue,"getOriginalSizeInPixels",RB_FUNC(rb_cocos2dx_SpriteFrame_getOriginalSizeInPixels));

   rb_define_method_bridge(classValue,"originalSizeInPixels",RB_FUNC(rb_cocos2dx_SpriteFrame_getOriginalSizeInPixels));
	

	rb_define_method_bridge(classValue,"setOriginalSizeInPixels",RB_FUNC(rb_cocos2dx_SpriteFrame_setOriginalSizeInPixels));

    rb_define_method_bridge(classValue,"originalSizeInPixels=",RB_FUNC(rb_cocos2dx_SpriteFrame_setOriginalSizeInPixels));
	

	rb_define_method_bridge(classValue,"setOffset",RB_FUNC(rb_cocos2dx_SpriteFrame_setOffset));

    rb_define_method_bridge(classValue,"offset=",RB_FUNC(rb_cocos2dx_SpriteFrame_setOffset));
	

	rb_define_method_bridge(classValue,"isRotated",RB_FUNC(rb_cocos2dx_SpriteFrame_isRotated));

	

	rb_define_method_bridge(classValue,"setRect",RB_FUNC(rb_cocos2dx_SpriteFrame_setRect));

    rb_define_method_bridge(classValue,"rect=",RB_FUNC(rb_cocos2dx_SpriteFrame_setRect));
	

	rb_define_method_bridge(classValue,"getOffsetInPixels",RB_FUNC(rb_cocos2dx_SpriteFrame_getOffsetInPixels));

   rb_define_method_bridge(classValue,"offsetInPixels",RB_FUNC(rb_cocos2dx_SpriteFrame_getOffsetInPixels));
	

	rb_define_method_bridge(classValue,"getOriginalSize",RB_FUNC(rb_cocos2dx_SpriteFrame_getOriginalSize));

   rb_define_method_bridge(classValue,"originalSize",RB_FUNC(rb_cocos2dx_SpriteFrame_getOriginalSize));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_SpriteFrame_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTexture",RB_FUNC(rb_cocos2dx_SpriteFrame_createWithTexture));

	


	TypeTest<cocos2d::SpriteFrame> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::SpriteFrame",classValue);
}
RBVAL rb_cocos2dx_AnimationFrame_setSpriteFrame(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AnimationFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationFrame_setSpriteFrame : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::SpriteFrame* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationFrame_setSpriteFrame : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setSpriteFrame(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("spriteFrame");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AnimationFrame_setSpriteFrame : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AnimationFrame_getUserInfo(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::AnimationFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationFrame_getUserInfo : self ptr is null");return RBNil();}
	do {
		if (argc == 0) {
			cocos2d::ValueMap& ret = cobj->getUserInfo();
			RBVAL value = RBNil();
			value = ccvaluemap_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 0) {
			const cocos2d::ValueMap& ret = cobj->getUserInfo();
			RBVAL value = RBNil();
			value = ccvaluemap_to_rb_value(ret);
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_AnimationFrame_getUserInfo : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AnimationFrame_setDelayUnits(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AnimationFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationFrame_setDelayUnits : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationFrame_setDelayUnits : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDelayUnits(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("delayUnits");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AnimationFrame_setDelayUnits : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AnimationFrame_clone(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AnimationFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationFrame_clone : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::AnimationFrame* ret = cobj->clone();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::AnimationFrame>((cocos2d::AnimationFrame*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AnimationFrame_clone : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AnimationFrame_getSpriteFrame(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AnimationFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationFrame_getSpriteFrame : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::SpriteFrame* ret = cobj->getSpriteFrame();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AnimationFrame_getSpriteFrame : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AnimationFrame_getDelayUnits(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AnimationFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationFrame_getDelayUnits : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getDelayUnits();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AnimationFrame_getDelayUnits : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AnimationFrame_setUserInfo(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AnimationFrame* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationFrame_setUserInfo : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ValueMap arg0;
			ok &= rb_value_to_ccvaluemap(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationFrame_setUserInfo : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setUserInfo(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("userInfo");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AnimationFrame_setUserInfo : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AnimationFrame_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 3) {
		cocos2d::SpriteFrame* arg0;
		float arg1;
		cocos2d::ValueMap arg2;
		ok &= rb_value_get_ptr(argv[0],&arg0);
		ok &= rb_value_to_float(argv[1], &arg1);
		ok &= rb_value_to_ccvaluemap(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationFrame_create : Error processing arguments");return RBNil();}
		cocos2d::AnimationFrame* ret = cocos2d::AnimationFrame::create(arg0, arg1, arg2);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::AnimationFrame>((cocos2d::AnimationFrame*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_AnimationFrame_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_AnimationFrame() {
		
	RBVAL classValue=rb_define_class_bridge("AnimationFrame",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"setSpriteFrame",RB_FUNC(rb_cocos2dx_AnimationFrame_setSpriteFrame));

    rb_define_method_bridge(classValue,"spriteFrame=",RB_FUNC(rb_cocos2dx_AnimationFrame_setSpriteFrame));
	

	rb_define_method_bridge(classValue,"getUserInfo",RB_FUNC(rb_cocos2dx_AnimationFrame_getUserInfo));

   rb_define_method_bridge(classValue,"userInfo",RB_FUNC(rb_cocos2dx_AnimationFrame_getUserInfo));
	

	rb_define_method_bridge(classValue,"setDelayUnits",RB_FUNC(rb_cocos2dx_AnimationFrame_setDelayUnits));

    rb_define_method_bridge(classValue,"delayUnits=",RB_FUNC(rb_cocos2dx_AnimationFrame_setDelayUnits));
	

	rb_define_method_bridge(classValue,"clone",RB_FUNC(rb_cocos2dx_AnimationFrame_clone));

	

	rb_define_method_bridge(classValue,"getSpriteFrame",RB_FUNC(rb_cocos2dx_AnimationFrame_getSpriteFrame));

   rb_define_method_bridge(classValue,"spriteFrame",RB_FUNC(rb_cocos2dx_AnimationFrame_getSpriteFrame));
	

	rb_define_method_bridge(classValue,"getDelayUnits",RB_FUNC(rb_cocos2dx_AnimationFrame_getDelayUnits));

   rb_define_method_bridge(classValue,"delayUnits",RB_FUNC(rb_cocos2dx_AnimationFrame_getDelayUnits));
	

	rb_define_method_bridge(classValue,"setUserInfo",RB_FUNC(rb_cocos2dx_AnimationFrame_setUserInfo));

    rb_define_method_bridge(classValue,"userInfo=",RB_FUNC(rb_cocos2dx_AnimationFrame_setUserInfo));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_AnimationFrame_create));

	


	TypeTest<cocos2d::AnimationFrame> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::AnimationFrame",classValue);
}
RBVAL rb_cocos2dx_Animation_getLoops(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Animation* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_getLoops : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					unsigned int ret = cobj->getLoops();
				value = uint_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Animation_getLoops : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animation_addSpriteFrame(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Animation* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_addSpriteFrame : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::SpriteFrame* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_addSpriteFrame : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addSpriteFrame(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Animation_addSpriteFrame : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animation_setRestoreOriginalFrame(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Animation* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_setRestoreOriginalFrame : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_setRestoreOriginalFrame : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRestoreOriginalFrame(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("restoreOriginalFrame");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Animation_setRestoreOriginalFrame : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animation_clone(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Animation* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_clone : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Animation* ret = cobj->clone();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Animation>((cocos2d::Animation*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Animation_clone : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animation_getDuration(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Animation* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_getDuration : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getDuration();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Animation_getDuration : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animation_setFrames(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Animation* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_setFrames : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vector<cocos2d::AnimationFrame *> arg0;
			ok &= rb_value_to_ccvector(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_setFrames : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setFrames(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("frames");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Animation_setFrames : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animation_getFrames(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Animation* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_getFrames : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vector<cocos2d::AnimationFrame *>& ret = cobj->getFrames();
				value = ccvector_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Animation_getFrames : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animation_setLoops(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Animation* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_setLoops : self ptr is null");return RBNil();}
		if (argc == 1) {
			unsigned int arg0;
			ok &= rb_value_to_uint(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_setLoops : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setLoops(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("loops");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Animation_setLoops : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animation_setDelayPerUnit(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Animation* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_setDelayPerUnit : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_setDelayPerUnit : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDelayPerUnit(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("delayPerUnit");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Animation_setDelayPerUnit : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animation_addSpriteFrameWithFile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Animation* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_addSpriteFrameWithFile : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_addSpriteFrameWithFile : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addSpriteFrameWithFile(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Animation_addSpriteFrameWithFile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animation_getTotalDelayUnits(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Animation* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_getTotalDelayUnits : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getTotalDelayUnits();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Animation_getTotalDelayUnits : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animation_getDelayPerUnit(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Animation* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_getDelayPerUnit : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getDelayPerUnit();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Animation_getDelayPerUnit : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animation_getRestoreOriginalFrame(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Animation* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_getRestoreOriginalFrame : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->getRestoreOriginalFrame();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Animation_getRestoreOriginalFrame : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animation_addSpriteFrameWithTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Animation* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_addSpriteFrameWithTexture : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::Texture2D* arg0;
			cocos2d::Rect arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_ccrect(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_addSpriteFrameWithTexture : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addSpriteFrameWithTexture(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Animation_addSpriteFrameWithTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animation_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 2) {
			cocos2d::Vector<cocos2d::AnimationFrame *> arg0;
			ok &= rb_value_to_ccvector(argv[0], &arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::Animation* ret = cocos2d::Animation::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::Animation>((cocos2d::Animation*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	do {
		if (argc == 3) {
			cocos2d::Vector<cocos2d::AnimationFrame *> arg0;
			ok &= rb_value_to_ccvector(argv[0], &arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			unsigned int arg2;
			ok &= rb_value_to_uint(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::Animation* ret = cocos2d::Animation::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::Animation>((cocos2d::Animation*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 0) {
			cocos2d::Animation* ret = cocos2d::Animation::create();
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::Animation>((cocos2d::Animation*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_Animation_create : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animation_createWithSpriteFrames(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::Vector<cocos2d::SpriteFrame *> arg0;
		ok &= rb_value_to_ccvector(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_createWithSpriteFrames : Error processing arguments");return RBNil();}
		cocos2d::Animation* ret = cocos2d::Animation::createWithSpriteFrames(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Animation>((cocos2d::Animation*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	if (argc == 2) {
		cocos2d::Vector<cocos2d::SpriteFrame *> arg0;
		float arg1;
		ok &= rb_value_to_ccvector(argv[0], &arg0);
		ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_createWithSpriteFrames : Error processing arguments");return RBNil();}
		cocos2d::Animation* ret = cocos2d::Animation::createWithSpriteFrames(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Animation>((cocos2d::Animation*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	if (argc == 3) {
		cocos2d::Vector<cocos2d::SpriteFrame *> arg0;
		float arg1;
		unsigned int arg2;
		ok &= rb_value_to_ccvector(argv[0], &arg0);
		ok &= rb_value_to_float(argv[1], &arg1);
		ok &= rb_value_to_uint(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animation_createWithSpriteFrames : Error processing arguments");return RBNil();}
		cocos2d::Animation* ret = cocos2d::Animation::createWithSpriteFrames(arg0, arg1, arg2);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Animation>((cocos2d::Animation*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Animation_createWithSpriteFrames : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Animation() {
		
	RBVAL classValue=rb_define_class_bridge("Animation",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"getLoops",RB_FUNC(rb_cocos2dx_Animation_getLoops));

   rb_define_method_bridge(classValue,"loops",RB_FUNC(rb_cocos2dx_Animation_getLoops));
	

	rb_define_method_bridge(classValue,"addSpriteFrame",RB_FUNC(rb_cocos2dx_Animation_addSpriteFrame));

	

	rb_define_method_bridge(classValue,"setRestoreOriginalFrame",RB_FUNC(rb_cocos2dx_Animation_setRestoreOriginalFrame));

    rb_define_method_bridge(classValue,"restoreOriginalFrame=",RB_FUNC(rb_cocos2dx_Animation_setRestoreOriginalFrame));
	

	rb_define_method_bridge(classValue,"clone",RB_FUNC(rb_cocos2dx_Animation_clone));

	

	rb_define_method_bridge(classValue,"getDuration",RB_FUNC(rb_cocos2dx_Animation_getDuration));

   rb_define_method_bridge(classValue,"duration",RB_FUNC(rb_cocos2dx_Animation_getDuration));
	

	rb_define_method_bridge(classValue,"setFrames",RB_FUNC(rb_cocos2dx_Animation_setFrames));

    rb_define_method_bridge(classValue,"frames=",RB_FUNC(rb_cocos2dx_Animation_setFrames));
	

	rb_define_method_bridge(classValue,"getFrames",RB_FUNC(rb_cocos2dx_Animation_getFrames));

   rb_define_method_bridge(classValue,"frames",RB_FUNC(rb_cocos2dx_Animation_getFrames));
	

	rb_define_method_bridge(classValue,"setLoops",RB_FUNC(rb_cocos2dx_Animation_setLoops));

    rb_define_method_bridge(classValue,"loops=",RB_FUNC(rb_cocos2dx_Animation_setLoops));
	

	rb_define_method_bridge(classValue,"setDelayPerUnit",RB_FUNC(rb_cocos2dx_Animation_setDelayPerUnit));

    rb_define_method_bridge(classValue,"delayPerUnit=",RB_FUNC(rb_cocos2dx_Animation_setDelayPerUnit));
	

	rb_define_method_bridge(classValue,"addSpriteFrameWithFile",RB_FUNC(rb_cocos2dx_Animation_addSpriteFrameWithFile));

	

	rb_define_method_bridge(classValue,"getTotalDelayUnits",RB_FUNC(rb_cocos2dx_Animation_getTotalDelayUnits));

   rb_define_method_bridge(classValue,"totalDelayUnits",RB_FUNC(rb_cocos2dx_Animation_getTotalDelayUnits));
	

	rb_define_method_bridge(classValue,"getDelayPerUnit",RB_FUNC(rb_cocos2dx_Animation_getDelayPerUnit));

   rb_define_method_bridge(classValue,"delayPerUnit",RB_FUNC(rb_cocos2dx_Animation_getDelayPerUnit));
	

	rb_define_method_bridge(classValue,"getRestoreOriginalFrame",RB_FUNC(rb_cocos2dx_Animation_getRestoreOriginalFrame));

   rb_define_method_bridge(classValue,"restoreOriginalFrame",RB_FUNC(rb_cocos2dx_Animation_getRestoreOriginalFrame));
	

	rb_define_method_bridge(classValue,"addSpriteFrameWithTexture",RB_FUNC(rb_cocos2dx_Animation_addSpriteFrameWithTexture));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Animation_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithSpriteFrames",RB_FUNC(rb_cocos2dx_Animation_createWithSpriteFrames));

	


	TypeTest<cocos2d::Animation> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Animation",classValue);
}
RBVAL rb_cocos2dx_ActionInterval_getAmplitudeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionInterval* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionInterval_getAmplitudeRate : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAmplitudeRate();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionInterval_getAmplitudeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionInterval_setAmplitudeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionInterval* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionInterval_setAmplitudeRate : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionInterval_setAmplitudeRate : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAmplitudeRate(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("amplitudeRate");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionInterval_setAmplitudeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionInterval_getElapsed(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionInterval* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionInterval_getElapsed : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getElapsed();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionInterval_getElapsed : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_ActionInterval() {
		
	RBVAL classValue=rb_define_class_bridge("ActionInterval",rb_get_class_value("cocos2d::FiniteTimeAction"),true);

	rb_define_method_bridge(classValue,"getAmplitudeRate",RB_FUNC(rb_cocos2dx_ActionInterval_getAmplitudeRate));

   rb_define_method_bridge(classValue,"amplitudeRate",RB_FUNC(rb_cocos2dx_ActionInterval_getAmplitudeRate));
	

	rb_define_method_bridge(classValue,"setAmplitudeRate",RB_FUNC(rb_cocos2dx_ActionInterval_setAmplitudeRate));

    rb_define_method_bridge(classValue,"amplitudeRate=",RB_FUNC(rb_cocos2dx_ActionInterval_setAmplitudeRate));
	

	rb_define_method_bridge(classValue,"getElapsed",RB_FUNC(rb_cocos2dx_ActionInterval_getElapsed));

   rb_define_method_bridge(classValue,"elapsed",RB_FUNC(rb_cocos2dx_ActionInterval_getElapsed));
	



	TypeTest<cocos2d::ActionInterval> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ActionInterval",classValue);
}


void rb_register_cocos2dx_Sequence() {
		
	RBVAL classValue=rb_define_class_bridge("Sequence",rb_get_class_value("cocos2d::ActionInterval"),true);



	TypeTest<cocos2d::Sequence> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Sequence",classValue);
}
RBVAL rb_cocos2dx_Repeat_setInnerAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Repeat* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Repeat_setInnerAction : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::FiniteTimeAction* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Repeat_setInnerAction : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setInnerAction(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("innerAction");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Repeat_setInnerAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Repeat_getInnerAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Repeat* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Repeat_getInnerAction : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::FiniteTimeAction* ret = cobj->getInnerAction();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::FiniteTimeAction>((cocos2d::FiniteTimeAction*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Repeat_getInnerAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Repeat_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		cocos2d::FiniteTimeAction* arg0;
		unsigned int arg1;
		ok &= rb_value_get_ptr(argv[0],&arg0);
		ok &= rb_value_to_uint(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Repeat_create : Error processing arguments");return RBNil();}
		cocos2d::Repeat* ret = cocos2d::Repeat::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Repeat>((cocos2d::Repeat*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Repeat_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Repeat() {
		
	RBVAL classValue=rb_define_class_bridge("Repeat",rb_get_class_value("cocos2d::ActionInterval"),true);

	rb_define_method_bridge(classValue,"setInnerAction",RB_FUNC(rb_cocos2dx_Repeat_setInnerAction));

    rb_define_method_bridge(classValue,"innerAction=",RB_FUNC(rb_cocos2dx_Repeat_setInnerAction));
	

	rb_define_method_bridge(classValue,"getInnerAction",RB_FUNC(rb_cocos2dx_Repeat_getInnerAction));

   rb_define_method_bridge(classValue,"innerAction",RB_FUNC(rb_cocos2dx_Repeat_getInnerAction));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Repeat_create));

	


	TypeTest<cocos2d::Repeat> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Repeat",classValue);
}
RBVAL rb_cocos2dx_RepeatForever_setInnerAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RepeatForever* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RepeatForever_setInnerAction : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ActionInterval* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RepeatForever_setInnerAction : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setInnerAction(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("innerAction");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RepeatForever_setInnerAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RepeatForever_getInnerAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RepeatForever* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RepeatForever_getInnerAction : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->getInnerAction();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RepeatForever_getInnerAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RepeatForever_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RepeatForever_create : Error processing arguments");return RBNil();}
		cocos2d::RepeatForever* ret = cocos2d::RepeatForever::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::RepeatForever>((cocos2d::RepeatForever*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_RepeatForever_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_RepeatForever() {
		
	RBVAL classValue=rb_define_class_bridge("RepeatForever",rb_get_class_value("cocos2d::ActionInterval"),true);

	rb_define_method_bridge(classValue,"setInnerAction",RB_FUNC(rb_cocos2dx_RepeatForever_setInnerAction));

    rb_define_method_bridge(classValue,"innerAction=",RB_FUNC(rb_cocos2dx_RepeatForever_setInnerAction));
	

	rb_define_method_bridge(classValue,"getInnerAction",RB_FUNC(rb_cocos2dx_RepeatForever_getInnerAction));

   rb_define_method_bridge(classValue,"innerAction",RB_FUNC(rb_cocos2dx_RepeatForever_getInnerAction));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_RepeatForever_create));

	


	TypeTest<cocos2d::RepeatForever> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::RepeatForever",classValue);
}


void rb_register_cocos2dx_Spawn() {
		
	RBVAL classValue=rb_define_class_bridge("Spawn",rb_get_class_value("cocos2d::ActionInterval"),true);



	TypeTest<cocos2d::Spawn> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Spawn",classValue);
}
RBVAL rb_cocos2dx_RotateTo_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 2) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::RotateTo* ret = cocos2d::RotateTo::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::RotateTo>((cocos2d::RotateTo*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 3) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::RotateTo* ret = cocos2d::RotateTo::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::RotateTo>((cocos2d::RotateTo*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 2) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Vec3 arg1;
			ok &= rb_value_to_vec3(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::RotateTo* ret = cocos2d::RotateTo::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::RotateTo>((cocos2d::RotateTo*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_RotateTo_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_RotateTo() {
		
	RBVAL classValue=rb_define_class_bridge("RotateTo",rb_get_class_value("cocos2d::ActionInterval"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_RotateTo_create));

	


	TypeTest<cocos2d::RotateTo> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::RotateTo",classValue);
}
RBVAL rb_cocos2dx_RotateBy_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 3) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::RotateBy* ret = cocos2d::RotateBy::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::RotateBy>((cocos2d::RotateBy*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 2) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::RotateBy* ret = cocos2d::RotateBy::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::RotateBy>((cocos2d::RotateBy*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 2) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Vec3 arg1;
			ok &= rb_value_to_vec3(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::RotateBy* ret = cocos2d::RotateBy::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::RotateBy>((cocos2d::RotateBy*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_RotateBy_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_RotateBy() {
		
	RBVAL classValue=rb_define_class_bridge("RotateBy",rb_get_class_value("cocos2d::ActionInterval"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_RotateBy_create));

	


	TypeTest<cocos2d::RotateBy> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::RotateBy",classValue);
}
RBVAL rb_cocos2dx_MoveBy_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Vec2 arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_vec2(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MoveBy_create : Error processing arguments");return RBNil();}
		cocos2d::MoveBy* ret = cocos2d::MoveBy::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::MoveBy>((cocos2d::MoveBy*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_MoveBy_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_MoveBy() {
		
	RBVAL classValue=rb_define_class_bridge("MoveBy",rb_get_class_value("cocos2d::ActionInterval"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_MoveBy_create));

	


	TypeTest<cocos2d::MoveBy> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::MoveBy",classValue);
}
RBVAL rb_cocos2dx_MoveTo_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Vec2 arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_vec2(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MoveTo_create : Error processing arguments");return RBNil();}
		cocos2d::MoveTo* ret = cocos2d::MoveTo::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::MoveTo>((cocos2d::MoveTo*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_MoveTo_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_MoveTo() {
		
	RBVAL classValue=rb_define_class_bridge("MoveTo",rb_get_class_value("cocos2d::MoveBy"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_MoveTo_create));

	


	TypeTest<cocos2d::MoveTo> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::MoveTo",classValue);
}
RBVAL rb_cocos2dx_SkewTo_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 3) {
		float arg0;
		float arg1;
		float arg2;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_float(argv[1], &arg1);
		ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SkewTo_create : Error processing arguments");return RBNil();}
		cocos2d::SkewTo* ret = cocos2d::SkewTo::create(arg0, arg1, arg2);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::SkewTo>((cocos2d::SkewTo*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_SkewTo_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_SkewTo() {
		
	RBVAL classValue=rb_define_class_bridge("SkewTo",rb_get_class_value("cocos2d::ActionInterval"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_SkewTo_create));

	


	TypeTest<cocos2d::SkewTo> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::SkewTo",classValue);
}
RBVAL rb_cocos2dx_SkewBy_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 3) {
		float arg0;
		float arg1;
		float arg2;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_float(argv[1], &arg1);
		ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SkewBy_create : Error processing arguments");return RBNil();}
		cocos2d::SkewBy* ret = cocos2d::SkewBy::create(arg0, arg1, arg2);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::SkewBy>((cocos2d::SkewBy*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_SkewBy_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_SkewBy() {
		
	RBVAL classValue=rb_define_class_bridge("SkewBy",rb_get_class_value("cocos2d::SkewTo"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_SkewBy_create));

	


	TypeTest<cocos2d::SkewBy> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::SkewBy",classValue);
}
RBVAL rb_cocos2dx_JumpBy_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 4) {
		float arg0;
		cocos2d::Vec2 arg1;
		float arg2;
		int arg3;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_vec2(argv[1], &arg1);
		ok &= rb_value_to_float(argv[2], &arg2);
		ok &= rb_value_to_int(argv[3], (int *)&arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_JumpBy_create : Error processing arguments");return RBNil();}
		cocos2d::JumpBy* ret = cocos2d::JumpBy::create(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::JumpBy>((cocos2d::JumpBy*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_JumpBy_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_JumpBy() {
		
	RBVAL classValue=rb_define_class_bridge("JumpBy",rb_get_class_value("cocos2d::ActionInterval"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_JumpBy_create));

	


	TypeTest<cocos2d::JumpBy> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::JumpBy",classValue);
}
RBVAL rb_cocos2dx_JumpTo_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 4) {
		float arg0;
		cocos2d::Vec2 arg1;
		float arg2;
		int arg3;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_vec2(argv[1], &arg1);
		ok &= rb_value_to_float(argv[2], &arg2);
		ok &= rb_value_to_int(argv[3], (int *)&arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_JumpTo_create : Error processing arguments");return RBNil();}
		cocos2d::JumpTo* ret = cocos2d::JumpTo::create(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::JumpTo>((cocos2d::JumpTo*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_JumpTo_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_JumpTo() {
		
	RBVAL classValue=rb_define_class_bridge("JumpTo",rb_get_class_value("cocos2d::JumpBy"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_JumpTo_create));

	


	TypeTest<cocos2d::JumpTo> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::JumpTo",classValue);
}


void rb_register_cocos2dx_BezierBy() {
		
	RBVAL classValue=rb_define_class_bridge("BezierBy",rb_get_class_value("cocos2d::ActionInterval"),true);



	TypeTest<cocos2d::BezierBy> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::BezierBy",classValue);
}


void rb_register_cocos2dx_BezierTo() {
		
	RBVAL classValue=rb_define_class_bridge("BezierTo",rb_get_class_value("cocos2d::BezierBy"),true);



	TypeTest<cocos2d::BezierTo> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::BezierTo",classValue);
}
RBVAL rb_cocos2dx_ScaleTo_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 3) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::ScaleTo* ret = cocos2d::ScaleTo::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::ScaleTo>((cocos2d::ScaleTo*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 2) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::ScaleTo* ret = cocos2d::ScaleTo::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::ScaleTo>((cocos2d::ScaleTo*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 4) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) { break; }
			float arg3;
			ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) { break; }
			cocos2d::ScaleTo* ret = cocos2d::ScaleTo::create(arg0, arg1, arg2, arg3);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::ScaleTo>((cocos2d::ScaleTo*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_ScaleTo_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_ScaleTo() {
		
	RBVAL classValue=rb_define_class_bridge("ScaleTo",rb_get_class_value("cocos2d::ActionInterval"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ScaleTo_create));

	


	TypeTest<cocos2d::ScaleTo> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ScaleTo",classValue);
}
RBVAL rb_cocos2dx_ScaleBy_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 3) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::ScaleBy* ret = cocos2d::ScaleBy::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::ScaleBy>((cocos2d::ScaleBy*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 2) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::ScaleBy* ret = cocos2d::ScaleBy::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::ScaleBy>((cocos2d::ScaleBy*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 4) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) { break; }
			float arg3;
			ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) { break; }
			cocos2d::ScaleBy* ret = cocos2d::ScaleBy::create(arg0, arg1, arg2, arg3);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::ScaleBy>((cocos2d::ScaleBy*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_ScaleBy_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_ScaleBy() {
		
	RBVAL classValue=rb_define_class_bridge("ScaleBy",rb_get_class_value("cocos2d::ScaleTo"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ScaleBy_create));

	


	TypeTest<cocos2d::ScaleBy> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ScaleBy",classValue);
}
RBVAL rb_cocos2dx_Blink_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		int arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Blink_create : Error processing arguments");return RBNil();}
		cocos2d::Blink* ret = cocos2d::Blink::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Blink>((cocos2d::Blink*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Blink_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Blink() {
		
	RBVAL classValue=rb_define_class_bridge("Blink",rb_get_class_value("cocos2d::ActionInterval"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Blink_create));

	


	TypeTest<cocos2d::Blink> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Blink",classValue);
}
RBVAL rb_cocos2dx_FadeTo_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		unsigned char arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_uint16(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeTo_create : Error processing arguments");return RBNil();}
		cocos2d::FadeTo* ret = cocos2d::FadeTo::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::FadeTo>((cocos2d::FadeTo*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_FadeTo_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_FadeTo() {
		
	RBVAL classValue=rb_define_class_bridge("FadeTo",rb_get_class_value("cocos2d::ActionInterval"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_FadeTo_create));

	


	TypeTest<cocos2d::FadeTo> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::FadeTo",classValue);
}
RBVAL rb_cocos2dx_FadeIn_setReverseAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FadeIn* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeIn_setReverseAction : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::FadeTo* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeIn_setReverseAction : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setReverseAction(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("reverseAction");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FadeIn_setReverseAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FadeIn_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		float arg0;
		ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeIn_create : Error processing arguments");return RBNil();}
		cocos2d::FadeIn* ret = cocos2d::FadeIn::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::FadeIn>((cocos2d::FadeIn*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_FadeIn_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_FadeIn() {
		
	RBVAL classValue=rb_define_class_bridge("FadeIn",rb_get_class_value("cocos2d::FadeTo"),true);

	rb_define_method_bridge(classValue,"setReverseAction",RB_FUNC(rb_cocos2dx_FadeIn_setReverseAction));

    rb_define_method_bridge(classValue,"reverseAction=",RB_FUNC(rb_cocos2dx_FadeIn_setReverseAction));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_FadeIn_create));

	


	TypeTest<cocos2d::FadeIn> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::FadeIn",classValue);
}
RBVAL rb_cocos2dx_FadeOut_setReverseAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FadeOut* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOut_setReverseAction : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::FadeTo* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOut_setReverseAction : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setReverseAction(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("reverseAction");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FadeOut_setReverseAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FadeOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		float arg0;
		ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOut_create : Error processing arguments");return RBNil();}
		cocos2d::FadeOut* ret = cocos2d::FadeOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::FadeOut>((cocos2d::FadeOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_FadeOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_FadeOut() {
		
	RBVAL classValue=rb_define_class_bridge("FadeOut",rb_get_class_value("cocos2d::FadeTo"),true);

	rb_define_method_bridge(classValue,"setReverseAction",RB_FUNC(rb_cocos2dx_FadeOut_setReverseAction));

    rb_define_method_bridge(classValue,"reverseAction=",RB_FUNC(rb_cocos2dx_FadeOut_setReverseAction));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_FadeOut_create));

	


	TypeTest<cocos2d::FadeOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::FadeOut",classValue);
}
RBVAL rb_cocos2dx_TintTo_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 4) {
		float arg0;
		unsigned char arg1;
		unsigned char arg2;
		unsigned char arg3;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_uint16(argv[1], &arg1);
		ok &= rb_value_to_uint16(argv[2], &arg2);
		ok &= rb_value_to_uint16(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TintTo_create : Error processing arguments");return RBNil();}
		cocos2d::TintTo* ret = cocos2d::TintTo::create(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TintTo>((cocos2d::TintTo*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TintTo_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TintTo() {
		
	RBVAL classValue=rb_define_class_bridge("TintTo",rb_get_class_value("cocos2d::ActionInterval"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TintTo_create));

	


	TypeTest<cocos2d::TintTo> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TintTo",classValue);
}
RBVAL rb_cocos2dx_TintBy_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 4) {
		float arg0;
		short arg1;
		short arg2;
		short arg3;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_int32(argv[1], &arg1);
		ok &= rb_value_to_int32(argv[2], &arg2);
		ok &= rb_value_to_int32(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TintBy_create : Error processing arguments");return RBNil();}
		cocos2d::TintBy* ret = cocos2d::TintBy::create(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TintBy>((cocos2d::TintBy*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TintBy_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TintBy() {
		
	RBVAL classValue=rb_define_class_bridge("TintBy",rb_get_class_value("cocos2d::ActionInterval"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TintBy_create));

	


	TypeTest<cocos2d::TintBy> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TintBy",classValue);
}
RBVAL rb_cocos2dx_DelayTime_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		float arg0;
		ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DelayTime_create : Error processing arguments");return RBNil();}
		cocos2d::DelayTime* ret = cocos2d::DelayTime::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::DelayTime>((cocos2d::DelayTime*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_DelayTime_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_DelayTime() {
		
	RBVAL classValue=rb_define_class_bridge("DelayTime",rb_get_class_value("cocos2d::ActionInterval"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_DelayTime_create));

	


	TypeTest<cocos2d::DelayTime> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::DelayTime",classValue);
}
RBVAL rb_cocos2dx_Animate_getAnimation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Animate* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animate_getAnimation : self ptr is null");return RBNil();}
	do {
		if (argc == 0) {
			const cocos2d::Animation* ret = cobj->getAnimation();
			RBVAL value = RBNil();
						if (ret) {
				value = rbb_get_or_create_value<cocos2d::Animation>((cocos2d::Animation*)ret);
			} else {
				value = RBNil();
			};
			return value;
		}
	} while(0);

	do {
		if (argc == 0) {
			cocos2d::Animation* ret = cobj->getAnimation();
			RBVAL value = RBNil();
						if (ret) {
				value = rbb_get_or_create_value<cocos2d::Animation>((cocos2d::Animation*)ret);
			} else {
				value = RBNil();
			};
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Animate_getAnimation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animate_setAnimation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Animate* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animate_setAnimation : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Animation* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animate_setAnimation : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAnimation(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("animation");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Animate_setAnimation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Animate_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::Animation* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Animate_create : Error processing arguments");return RBNil();}
		cocos2d::Animate* ret = cocos2d::Animate::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Animate>((cocos2d::Animate*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Animate_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Animate() {
		
	RBVAL classValue=rb_define_class_bridge("Animate",rb_get_class_value("cocos2d::ActionInterval"),true);

	rb_define_method_bridge(classValue,"getAnimation",RB_FUNC(rb_cocos2dx_Animate_getAnimation));

   rb_define_method_bridge(classValue,"animation",RB_FUNC(rb_cocos2dx_Animate_getAnimation));
	

	rb_define_method_bridge(classValue,"setAnimation",RB_FUNC(rb_cocos2dx_Animate_setAnimation));

    rb_define_method_bridge(classValue,"animation=",RB_FUNC(rb_cocos2dx_Animate_setAnimation));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Animate_create));

	


	TypeTest<cocos2d::Animate> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Animate",classValue);
}
RBVAL rb_cocos2dx_TargetedAction_getForcedTarget(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::TargetedAction* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TargetedAction_getForcedTarget : self ptr is null");return RBNil();}
	do {
		if (argc == 0) {
			const cocos2d::Node* ret = cobj->getForcedTarget();
			RBVAL value = RBNil();
						if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
			return value;
		}
	} while(0);

	do {
		if (argc == 0) {
			cocos2d::Node* ret = cobj->getForcedTarget();
			RBVAL value = RBNil();
						if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_TargetedAction_getForcedTarget : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TargetedAction_setForcedTarget(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TargetedAction* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TargetedAction_setForcedTarget : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TargetedAction_setForcedTarget : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setForcedTarget(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("forcedTarget");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TargetedAction_setForcedTarget : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TargetedAction_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		cocos2d::Node* arg0;
		cocos2d::FiniteTimeAction* arg1;
		ok &= rb_value_get_ptr(argv[0],&arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TargetedAction_create : Error processing arguments");return RBNil();}
		cocos2d::TargetedAction* ret = cocos2d::TargetedAction::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TargetedAction>((cocos2d::TargetedAction*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TargetedAction_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TargetedAction() {
		
	RBVAL classValue=rb_define_class_bridge("TargetedAction",rb_get_class_value("cocos2d::ActionInterval"),true);

	rb_define_method_bridge(classValue,"getForcedTarget",RB_FUNC(rb_cocos2dx_TargetedAction_getForcedTarget));

   rb_define_method_bridge(classValue,"forcedTarget",RB_FUNC(rb_cocos2dx_TargetedAction_getForcedTarget));
	

	rb_define_method_bridge(classValue,"setForcedTarget",RB_FUNC(rb_cocos2dx_TargetedAction_setForcedTarget));

    rb_define_method_bridge(classValue,"forcedTarget=",RB_FUNC(rb_cocos2dx_TargetedAction_setForcedTarget));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TargetedAction_create));

	


	TypeTest<cocos2d::TargetedAction> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TargetedAction",classValue);
}
RBVAL rb_cocos2dx_ActionCamera_setEye(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::ActionCamera* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionCamera_setEye : self ptr is null");return RBNil();}
	do {
		if (argc == 3) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionCamera_setEye : Error processing argument 1 ( 3 )");return RBNil(); }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionCamera_setEye : Error processing argument 2 ( 3 )");return RBNil(); }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionCamera_setEye : Error processing argument 3 ( 3 )");return RBNil(); }
			cobj->setEye(arg0, arg1, arg2);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 1) {
			cocos2d::Vec3 arg0;
			ok &= rb_value_to_vec3(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionCamera_setEye : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->setEye(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("eye");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_ActionCamera_setEye : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionCamera_getEye(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionCamera* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionCamera_getEye : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec3& ret = cobj->getEye();
				value = vec3_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionCamera_getEye : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionCamera_setUp(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionCamera* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionCamera_setUp : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec3 arg0;
			ok &= rb_value_to_vec3(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionCamera_setUp : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setUp(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("up");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionCamera_setUp : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionCamera_getCenter(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionCamera* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionCamera_getCenter : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec3& ret = cobj->getCenter();
				value = vec3_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionCamera_getCenter : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionCamera_setCenter(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionCamera* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionCamera_setCenter : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec3 arg0;
			ok &= rb_value_to_vec3(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionCamera_setCenter : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setCenter(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("center");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionCamera_setCenter : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionCamera_getUp(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionCamera* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionCamera_getUp : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec3& ret = cobj->getUp();
				value = vec3_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionCamera_getUp : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionCamera_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::ActionCamera> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::ActionCamera* cobj = new cocos2d::ActionCamera();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionCamera_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ActionCamera() {
		
	RBVAL classValue=rb_define_class_bridge("ActionCamera",rb_get_class_value("cocos2d::ActionInterval"),true);

	rb_define_method_bridge(classValue,"setEye",RB_FUNC(rb_cocos2dx_ActionCamera_setEye));

    rb_define_method_bridge(classValue,"eye=",RB_FUNC(rb_cocos2dx_ActionCamera_setEye));
	

	rb_define_method_bridge(classValue,"getEye",RB_FUNC(rb_cocos2dx_ActionCamera_getEye));

   rb_define_method_bridge(classValue,"eye",RB_FUNC(rb_cocos2dx_ActionCamera_getEye));
	

	rb_define_method_bridge(classValue,"setUp",RB_FUNC(rb_cocos2dx_ActionCamera_setUp));

    rb_define_method_bridge(classValue,"up=",RB_FUNC(rb_cocos2dx_ActionCamera_setUp));
	

	rb_define_method_bridge(classValue,"getCenter",RB_FUNC(rb_cocos2dx_ActionCamera_getCenter));

   rb_define_method_bridge(classValue,"center",RB_FUNC(rb_cocos2dx_ActionCamera_getCenter));
	

	rb_define_method_bridge(classValue,"setCenter",RB_FUNC(rb_cocos2dx_ActionCamera_setCenter));

    rb_define_method_bridge(classValue,"center=",RB_FUNC(rb_cocos2dx_ActionCamera_setCenter));
	

	rb_define_method_bridge(classValue,"getUp",RB_FUNC(rb_cocos2dx_ActionCamera_getUp));

   rb_define_method_bridge(classValue,"up",RB_FUNC(rb_cocos2dx_ActionCamera_getUp));
	


	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_ActionCamera_constructor));

	TypeTest<cocos2d::ActionCamera> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ActionCamera",classValue);
}
RBVAL rb_cocos2dx_OrbitCamera_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 7) {
		float arg0;
		float arg1;
		float arg2;
		float arg3;
		float arg4;
		float arg5;
		float arg6;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_float(argv[1], &arg1);
		ok &= rb_value_to_float(argv[2], &arg2);
		ok &= rb_value_to_float(argv[3], &arg3);
		ok &= rb_value_to_float(argv[4], &arg4);
		ok &= rb_value_to_float(argv[5], &arg5);
		ok &= rb_value_to_float(argv[6], &arg6);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_OrbitCamera_create : Error processing arguments");return RBNil();}
		cocos2d::OrbitCamera* ret = cocos2d::OrbitCamera::create(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::OrbitCamera>((cocos2d::OrbitCamera*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_OrbitCamera_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_OrbitCamera() {
		
	RBVAL classValue=rb_define_class_bridge("OrbitCamera",rb_get_class_value("cocos2d::ActionCamera"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_OrbitCamera_create));

	


	TypeTest<cocos2d::OrbitCamera> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::OrbitCamera",classValue);
}
RBVAL rb_cocos2dx_ActionManager_getActionByTag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionManager* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_getActionByTag : self ptr is null");return RBNil();}
		if (argc == 2) {
			int arg0;
			const cocos2d::Node* arg1;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_getActionByTag : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Action* ret = cobj->getActionByTag(arg0, arg1);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Action>((cocos2d::Action*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionManager_getActionByTag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionManager_removeActionByTag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionManager* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_removeActionByTag : self ptr is null");return RBNil();}
		if (argc == 2) {
			int arg0;
			cocos2d::Node* arg1;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_removeActionByTag : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeActionByTag(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionManager_removeActionByTag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionManager_removeAllActions(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionManager* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_removeAllActions : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->removeAllActions();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionManager_removeAllActions : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionManager_addAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionManager* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_addAction : self ptr is null");return RBNil();}
		if (argc == 3) {
			cocos2d::Action* arg0;
			cocos2d::Node* arg1;
			bool arg2;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_get_ptr(argv[1],&arg1);
			ok &= rb_value_to_bool(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_addAction : Error processing argument 3 ( 3 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addAction(arg0, arg1, arg2);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionManager_addAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionManager_resumeTarget(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionManager* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_resumeTarget : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_resumeTarget : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->resumeTarget(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionManager_resumeTarget : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionManager_update(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionManager* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_update : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_update : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->update(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionManager_update : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionManager_pauseTarget(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionManager* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_pauseTarget : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_pauseTarget : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->pauseTarget(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionManager_pauseTarget : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionManager* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget : self ptr is null");return RBNil();}
		if (argc == 1) {
			const cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					ssize_t ret = cobj->getNumberOfRunningActionsInTarget(arg0);
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionManager_removeAllActionsFromTarget(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionManager* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_removeAllActionsFromTarget : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_removeAllActionsFromTarget : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeAllActionsFromTarget(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionManager_removeAllActionsFromTarget : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionManager_resumeTargets(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionManager* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_resumeTargets : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vector<cocos2d::Node *> arg0;
			ok &= rb_value_to_ccvector(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_resumeTargets : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->resumeTargets(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionManager_resumeTargets : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionManager_removeAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionManager* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_removeAction : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Action* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_removeAction : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeAction(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionManager_removeAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionManager_removeAllActionsByTag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionManager* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_removeAllActionsByTag : self ptr is null");return RBNil();}
		if (argc == 2) {
			int arg0;
			cocos2d::Node* arg1;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_removeAllActionsByTag : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeAllActionsByTag(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionManager_removeAllActionsByTag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionManager_pauseAllRunningActions(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionManager* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionManager_pauseAllRunningActions : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vector<cocos2d::Node *> ret = cobj->pauseAllRunningActions();
				value = ccvector_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionManager_pauseAllRunningActions : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ActionManager_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::ActionManager> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::ActionManager* cobj = new cocos2d::ActionManager();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionManager_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ActionManager() {
		
	RBVAL classValue=rb_define_class_bridge("ActionManager",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"getActionByTag",RB_FUNC(rb_cocos2dx_ActionManager_getActionByTag));

   rb_define_method_bridge(classValue,"actionByTag",RB_FUNC(rb_cocos2dx_ActionManager_getActionByTag));
	

	rb_define_method_bridge(classValue,"removeActionByTag",RB_FUNC(rb_cocos2dx_ActionManager_removeActionByTag));

	

	rb_define_method_bridge(classValue,"removeAllActions",RB_FUNC(rb_cocos2dx_ActionManager_removeAllActions));

	

	rb_define_method_bridge(classValue,"addAction",RB_FUNC(rb_cocos2dx_ActionManager_addAction));

	

	rb_define_method_bridge(classValue,"resumeTarget",RB_FUNC(rb_cocos2dx_ActionManager_resumeTarget));

	

	rb_define_method_bridge(classValue,"update",RB_FUNC(rb_cocos2dx_ActionManager_update));

	

	rb_define_method_bridge(classValue,"pauseTarget",RB_FUNC(rb_cocos2dx_ActionManager_pauseTarget));

	

	rb_define_method_bridge(classValue,"getNumberOfRunningActionsInTarget",RB_FUNC(rb_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget));

   rb_define_method_bridge(classValue,"numberOfRunningActionsInTarget",RB_FUNC(rb_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget));
	

	rb_define_method_bridge(classValue,"removeAllActionsFromTarget",RB_FUNC(rb_cocos2dx_ActionManager_removeAllActionsFromTarget));

	

	rb_define_method_bridge(classValue,"resumeTargets",RB_FUNC(rb_cocos2dx_ActionManager_resumeTargets));

	

	rb_define_method_bridge(classValue,"removeAction",RB_FUNC(rb_cocos2dx_ActionManager_removeAction));

	

	rb_define_method_bridge(classValue,"removeAllActionsByTag",RB_FUNC(rb_cocos2dx_ActionManager_removeAllActionsByTag));

	

	rb_define_method_bridge(classValue,"pauseAllRunningActions",RB_FUNC(rb_cocos2dx_ActionManager_pauseAllRunningActions));

	


	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_ActionManager_constructor));

	TypeTest<cocos2d::ActionManager> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ActionManager",classValue);
}
RBVAL rb_cocos2dx_ActionEase_getInnerAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ActionEase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionEase_getInnerAction : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->getInnerAction();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ActionEase_getInnerAction : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_ActionEase() {
		
	RBVAL classValue=rb_define_class_bridge("ActionEase",rb_get_class_value("cocos2d::ActionInterval"),true);

	rb_define_method_bridge(classValue,"getInnerAction",RB_FUNC(rb_cocos2dx_ActionEase_getInnerAction));

   rb_define_method_bridge(classValue,"innerAction",RB_FUNC(rb_cocos2dx_ActionEase_getInnerAction));
	



	TypeTest<cocos2d::ActionEase> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ActionEase",classValue);
}
RBVAL rb_cocos2dx_EaseRateAction_setRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EaseRateAction* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseRateAction_setRate : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseRateAction_setRate : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRate(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("rate");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EaseRateAction_setRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EaseRateAction_getRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EaseRateAction* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseRateAction_getRate : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getRate();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EaseRateAction_getRate : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_EaseRateAction() {
		
	RBVAL classValue=rb_define_class_bridge("EaseRateAction",rb_get_class_value("cocos2d::ActionEase"),true);

	rb_define_method_bridge(classValue,"setRate",RB_FUNC(rb_cocos2dx_EaseRateAction_setRate));

    rb_define_method_bridge(classValue,"rate=",RB_FUNC(rb_cocos2dx_EaseRateAction_setRate));
	

	rb_define_method_bridge(classValue,"getRate",RB_FUNC(rb_cocos2dx_EaseRateAction_getRate));

   rb_define_method_bridge(classValue,"rate",RB_FUNC(rb_cocos2dx_EaseRateAction_getRate));
	



	TypeTest<cocos2d::EaseRateAction> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseRateAction",classValue);
}
RBVAL rb_cocos2dx_EaseIn_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		cocos2d::ActionInterval* arg0;
		float arg1;
		ok &= rb_value_get_ptr(argv[0],&arg0);
		ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseIn_create : Error processing arguments");return RBNil();}
		cocos2d::EaseIn* ret = cocos2d::EaseIn::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseIn>((cocos2d::EaseIn*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseIn_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseIn() {
		
	RBVAL classValue=rb_define_class_bridge("EaseIn",rb_get_class_value("cocos2d::EaseRateAction"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseIn_create));

	


	TypeTest<cocos2d::EaseIn> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseIn",classValue);
}
RBVAL rb_cocos2dx_EaseOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		cocos2d::ActionInterval* arg0;
		float arg1;
		ok &= rb_value_get_ptr(argv[0],&arg0);
		ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseOut* ret = cocos2d::EaseOut::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseOut>((cocos2d::EaseOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseOut",rb_get_class_value("cocos2d::EaseRateAction"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseOut_create));

	


	TypeTest<cocos2d::EaseOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseOut",classValue);
}
RBVAL rb_cocos2dx_EaseInOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		cocos2d::ActionInterval* arg0;
		float arg1;
		ok &= rb_value_get_ptr(argv[0],&arg0);
		ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseInOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseInOut* ret = cocos2d::EaseInOut::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseInOut>((cocos2d::EaseInOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseInOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseInOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseInOut",rb_get_class_value("cocos2d::EaseRateAction"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseInOut_create));

	


	TypeTest<cocos2d::EaseInOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseInOut",classValue);
}
RBVAL rb_cocos2dx_EaseExponentialIn_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseExponentialIn_create : Error processing arguments");return RBNil();}
		cocos2d::EaseExponentialIn* ret = cocos2d::EaseExponentialIn::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseExponentialIn>((cocos2d::EaseExponentialIn*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseExponentialIn_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseExponentialIn() {
		
	RBVAL classValue=rb_define_class_bridge("EaseExponentialIn",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseExponentialIn_create));

	


	TypeTest<cocos2d::EaseExponentialIn> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseExponentialIn",classValue);
}
RBVAL rb_cocos2dx_EaseExponentialOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseExponentialOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseExponentialOut* ret = cocos2d::EaseExponentialOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseExponentialOut>((cocos2d::EaseExponentialOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseExponentialOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseExponentialOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseExponentialOut",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseExponentialOut_create));

	


	TypeTest<cocos2d::EaseExponentialOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseExponentialOut",classValue);
}
RBVAL rb_cocos2dx_EaseExponentialInOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseExponentialInOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseExponentialInOut* ret = cocos2d::EaseExponentialInOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseExponentialInOut>((cocos2d::EaseExponentialInOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseExponentialInOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseExponentialInOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseExponentialInOut",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseExponentialInOut_create));

	


	TypeTest<cocos2d::EaseExponentialInOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseExponentialInOut",classValue);
}
RBVAL rb_cocos2dx_EaseSineIn_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseSineIn_create : Error processing arguments");return RBNil();}
		cocos2d::EaseSineIn* ret = cocos2d::EaseSineIn::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseSineIn>((cocos2d::EaseSineIn*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseSineIn_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseSineIn() {
		
	RBVAL classValue=rb_define_class_bridge("EaseSineIn",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseSineIn_create));

	


	TypeTest<cocos2d::EaseSineIn> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseSineIn",classValue);
}
RBVAL rb_cocos2dx_EaseSineOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseSineOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseSineOut* ret = cocos2d::EaseSineOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseSineOut>((cocos2d::EaseSineOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseSineOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseSineOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseSineOut",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseSineOut_create));

	


	TypeTest<cocos2d::EaseSineOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseSineOut",classValue);
}
RBVAL rb_cocos2dx_EaseSineInOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseSineInOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseSineInOut* ret = cocos2d::EaseSineInOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseSineInOut>((cocos2d::EaseSineInOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseSineInOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseSineInOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseSineInOut",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseSineInOut_create));

	


	TypeTest<cocos2d::EaseSineInOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseSineInOut",classValue);
}
RBVAL rb_cocos2dx_EaseElastic_setPeriod(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EaseElastic* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseElastic_setPeriod : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseElastic_setPeriod : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setPeriod(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("period");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EaseElastic_setPeriod : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EaseElastic_getPeriod(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EaseElastic* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseElastic_getPeriod : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getPeriod();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EaseElastic_getPeriod : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_EaseElastic() {
		
	RBVAL classValue=rb_define_class_bridge("EaseElastic",rb_get_class_value("cocos2d::ActionEase"),true);

	rb_define_method_bridge(classValue,"setPeriod",RB_FUNC(rb_cocos2dx_EaseElastic_setPeriod));

    rb_define_method_bridge(classValue,"period=",RB_FUNC(rb_cocos2dx_EaseElastic_setPeriod));
	

	rb_define_method_bridge(classValue,"getPeriod",RB_FUNC(rb_cocos2dx_EaseElastic_getPeriod));

   rb_define_method_bridge(classValue,"period",RB_FUNC(rb_cocos2dx_EaseElastic_getPeriod));
	



	TypeTest<cocos2d::EaseElastic> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseElastic",classValue);
}
RBVAL rb_cocos2dx_EaseElasticIn_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 1) {
			cocos2d::ActionInterval* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) { break; }
			cocos2d::EaseElasticIn* ret = cocos2d::EaseElasticIn::create(arg0);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::EaseElasticIn>((cocos2d::EaseElasticIn*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 2) {
			cocos2d::ActionInterval* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::EaseElasticIn* ret = cocos2d::EaseElasticIn::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::EaseElasticIn>((cocos2d::EaseElasticIn*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_EaseElasticIn_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_EaseElasticIn() {
		
	RBVAL classValue=rb_define_class_bridge("EaseElasticIn",rb_get_class_value("cocos2d::EaseElastic"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseElasticIn_create));

	


	TypeTest<cocos2d::EaseElasticIn> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseElasticIn",classValue);
}
RBVAL rb_cocos2dx_EaseElasticOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 1) {
			cocos2d::ActionInterval* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) { break; }
			cocos2d::EaseElasticOut* ret = cocos2d::EaseElasticOut::create(arg0);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::EaseElasticOut>((cocos2d::EaseElasticOut*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 2) {
			cocos2d::ActionInterval* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::EaseElasticOut* ret = cocos2d::EaseElasticOut::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::EaseElasticOut>((cocos2d::EaseElasticOut*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_EaseElasticOut_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_EaseElasticOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseElasticOut",rb_get_class_value("cocos2d::EaseElastic"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseElasticOut_create));

	


	TypeTest<cocos2d::EaseElasticOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseElasticOut",classValue);
}
RBVAL rb_cocos2dx_EaseElasticInOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 1) {
			cocos2d::ActionInterval* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) { break; }
			cocos2d::EaseElasticInOut* ret = cocos2d::EaseElasticInOut::create(arg0);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::EaseElasticInOut>((cocos2d::EaseElasticInOut*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 2) {
			cocos2d::ActionInterval* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::EaseElasticInOut* ret = cocos2d::EaseElasticInOut::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::EaseElasticInOut>((cocos2d::EaseElasticInOut*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_EaseElasticInOut_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_EaseElasticInOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseElasticInOut",rb_get_class_value("cocos2d::EaseElastic"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseElasticInOut_create));

	


	TypeTest<cocos2d::EaseElasticInOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseElasticInOut",classValue);
}


void rb_register_cocos2dx_EaseBounce() {
		
	RBVAL classValue=rb_define_class_bridge("EaseBounce",rb_get_class_value("cocos2d::ActionEase"),true);



	TypeTest<cocos2d::EaseBounce> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseBounce",classValue);
}
RBVAL rb_cocos2dx_EaseBounceIn_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseBounceIn_create : Error processing arguments");return RBNil();}
		cocos2d::EaseBounceIn* ret = cocos2d::EaseBounceIn::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseBounceIn>((cocos2d::EaseBounceIn*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseBounceIn_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseBounceIn() {
		
	RBVAL classValue=rb_define_class_bridge("EaseBounceIn",rb_get_class_value("cocos2d::EaseBounce"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseBounceIn_create));

	


	TypeTest<cocos2d::EaseBounceIn> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseBounceIn",classValue);
}
RBVAL rb_cocos2dx_EaseBounceOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseBounceOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseBounceOut* ret = cocos2d::EaseBounceOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseBounceOut>((cocos2d::EaseBounceOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseBounceOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseBounceOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseBounceOut",rb_get_class_value("cocos2d::EaseBounce"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseBounceOut_create));

	


	TypeTest<cocos2d::EaseBounceOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseBounceOut",classValue);
}
RBVAL rb_cocos2dx_EaseBounceInOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseBounceInOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseBounceInOut* ret = cocos2d::EaseBounceInOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseBounceInOut>((cocos2d::EaseBounceInOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseBounceInOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseBounceInOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseBounceInOut",rb_get_class_value("cocos2d::EaseBounce"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseBounceInOut_create));

	


	TypeTest<cocos2d::EaseBounceInOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseBounceInOut",classValue);
}
RBVAL rb_cocos2dx_EaseBackIn_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseBackIn_create : Error processing arguments");return RBNil();}
		cocos2d::EaseBackIn* ret = cocos2d::EaseBackIn::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseBackIn>((cocos2d::EaseBackIn*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseBackIn_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseBackIn() {
		
	RBVAL classValue=rb_define_class_bridge("EaseBackIn",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseBackIn_create));

	


	TypeTest<cocos2d::EaseBackIn> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseBackIn",classValue);
}
RBVAL rb_cocos2dx_EaseBackOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseBackOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseBackOut* ret = cocos2d::EaseBackOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseBackOut>((cocos2d::EaseBackOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseBackOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseBackOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseBackOut",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseBackOut_create));

	


	TypeTest<cocos2d::EaseBackOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseBackOut",classValue);
}
RBVAL rb_cocos2dx_EaseBackInOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseBackInOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseBackInOut* ret = cocos2d::EaseBackInOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseBackInOut>((cocos2d::EaseBackInOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseBackInOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseBackInOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseBackInOut",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseBackInOut_create));

	


	TypeTest<cocos2d::EaseBackInOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseBackInOut",classValue);
}
RBVAL rb_cocos2dx_EaseBezierAction_setBezierParamer(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::EaseBezierAction* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseBezierAction_setBezierParamer : self ptr is null");return RBNil();}
		if (argc == 4) {
			float arg0;
			float arg1;
			float arg2;
			float arg3;
			ok &= rb_value_to_float(argv[0], &arg0);
			ok &= rb_value_to_float(argv[1], &arg1);
			ok &= rb_value_to_float(argv[2], &arg2);
			ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseBezierAction_setBezierParamer : Error processing argument 4 ( 4 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setBezierParamer(arg0, arg1, arg2, arg3);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_EaseBezierAction_setBezierParamer : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_EaseBezierAction_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseBezierAction_create : Error processing arguments");return RBNil();}
		cocos2d::EaseBezierAction* ret = cocos2d::EaseBezierAction::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseBezierAction>((cocos2d::EaseBezierAction*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseBezierAction_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseBezierAction() {
		
	RBVAL classValue=rb_define_class_bridge("EaseBezierAction",rb_get_class_value("cocos2d::ActionEase"),true);

	rb_define_method_bridge(classValue,"setBezierParamer",RB_FUNC(rb_cocos2dx_EaseBezierAction_setBezierParamer));

    rb_define_method_bridge(classValue,"bezierParamer=",RB_FUNC(rb_cocos2dx_EaseBezierAction_setBezierParamer));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseBezierAction_create));

	


	TypeTest<cocos2d::EaseBezierAction> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseBezierAction",classValue);
}
RBVAL rb_cocos2dx_EaseQuadraticActionIn_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseQuadraticActionIn_create : Error processing arguments");return RBNil();}
		cocos2d::EaseQuadraticActionIn* ret = cocos2d::EaseQuadraticActionIn::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseQuadraticActionIn>((cocos2d::EaseQuadraticActionIn*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseQuadraticActionIn_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseQuadraticActionIn() {
		
	RBVAL classValue=rb_define_class_bridge("EaseQuadraticActionIn",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseQuadraticActionIn_create));

	


	TypeTest<cocos2d::EaseQuadraticActionIn> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseQuadraticActionIn",classValue);
}
RBVAL rb_cocos2dx_EaseQuadraticActionOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseQuadraticActionOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseQuadraticActionOut* ret = cocos2d::EaseQuadraticActionOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseQuadraticActionOut>((cocos2d::EaseQuadraticActionOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseQuadraticActionOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseQuadraticActionOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseQuadraticActionOut",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseQuadraticActionOut_create));

	


	TypeTest<cocos2d::EaseQuadraticActionOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseQuadraticActionOut",classValue);
}
RBVAL rb_cocos2dx_EaseQuadraticActionInOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseQuadraticActionInOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseQuadraticActionInOut* ret = cocos2d::EaseQuadraticActionInOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseQuadraticActionInOut>((cocos2d::EaseQuadraticActionInOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseQuadraticActionInOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseQuadraticActionInOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseQuadraticActionInOut",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseQuadraticActionInOut_create));

	


	TypeTest<cocos2d::EaseQuadraticActionInOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseQuadraticActionInOut",classValue);
}
RBVAL rb_cocos2dx_EaseQuarticActionIn_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseQuarticActionIn_create : Error processing arguments");return RBNil();}
		cocos2d::EaseQuarticActionIn* ret = cocos2d::EaseQuarticActionIn::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseQuarticActionIn>((cocos2d::EaseQuarticActionIn*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseQuarticActionIn_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseQuarticActionIn() {
		
	RBVAL classValue=rb_define_class_bridge("EaseQuarticActionIn",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseQuarticActionIn_create));

	


	TypeTest<cocos2d::EaseQuarticActionIn> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseQuarticActionIn",classValue);
}
RBVAL rb_cocos2dx_EaseQuarticActionOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseQuarticActionOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseQuarticActionOut* ret = cocos2d::EaseQuarticActionOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseQuarticActionOut>((cocos2d::EaseQuarticActionOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseQuarticActionOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseQuarticActionOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseQuarticActionOut",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseQuarticActionOut_create));

	


	TypeTest<cocos2d::EaseQuarticActionOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseQuarticActionOut",classValue);
}
RBVAL rb_cocos2dx_EaseQuarticActionInOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseQuarticActionInOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseQuarticActionInOut* ret = cocos2d::EaseQuarticActionInOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseQuarticActionInOut>((cocos2d::EaseQuarticActionInOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseQuarticActionInOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseQuarticActionInOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseQuarticActionInOut",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseQuarticActionInOut_create));

	


	TypeTest<cocos2d::EaseQuarticActionInOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseQuarticActionInOut",classValue);
}
RBVAL rb_cocos2dx_EaseQuinticActionIn_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseQuinticActionIn_create : Error processing arguments");return RBNil();}
		cocos2d::EaseQuinticActionIn* ret = cocos2d::EaseQuinticActionIn::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseQuinticActionIn>((cocos2d::EaseQuinticActionIn*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseQuinticActionIn_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseQuinticActionIn() {
		
	RBVAL classValue=rb_define_class_bridge("EaseQuinticActionIn",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseQuinticActionIn_create));

	


	TypeTest<cocos2d::EaseQuinticActionIn> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseQuinticActionIn",classValue);
}
RBVAL rb_cocos2dx_EaseQuinticActionOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseQuinticActionOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseQuinticActionOut* ret = cocos2d::EaseQuinticActionOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseQuinticActionOut>((cocos2d::EaseQuinticActionOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseQuinticActionOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseQuinticActionOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseQuinticActionOut",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseQuinticActionOut_create));

	


	TypeTest<cocos2d::EaseQuinticActionOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseQuinticActionOut",classValue);
}
RBVAL rb_cocos2dx_EaseQuinticActionInOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseQuinticActionInOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseQuinticActionInOut* ret = cocos2d::EaseQuinticActionInOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseQuinticActionInOut>((cocos2d::EaseQuinticActionInOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseQuinticActionInOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseQuinticActionInOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseQuinticActionInOut",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseQuinticActionInOut_create));

	


	TypeTest<cocos2d::EaseQuinticActionInOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseQuinticActionInOut",classValue);
}
RBVAL rb_cocos2dx_EaseCircleActionIn_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseCircleActionIn_create : Error processing arguments");return RBNil();}
		cocos2d::EaseCircleActionIn* ret = cocos2d::EaseCircleActionIn::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseCircleActionIn>((cocos2d::EaseCircleActionIn*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseCircleActionIn_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseCircleActionIn() {
		
	RBVAL classValue=rb_define_class_bridge("EaseCircleActionIn",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseCircleActionIn_create));

	


	TypeTest<cocos2d::EaseCircleActionIn> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseCircleActionIn",classValue);
}
RBVAL rb_cocos2dx_EaseCircleActionOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseCircleActionOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseCircleActionOut* ret = cocos2d::EaseCircleActionOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseCircleActionOut>((cocos2d::EaseCircleActionOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseCircleActionOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseCircleActionOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseCircleActionOut",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseCircleActionOut_create));

	


	TypeTest<cocos2d::EaseCircleActionOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseCircleActionOut",classValue);
}
RBVAL rb_cocos2dx_EaseCircleActionInOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseCircleActionInOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseCircleActionInOut* ret = cocos2d::EaseCircleActionInOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseCircleActionInOut>((cocos2d::EaseCircleActionInOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseCircleActionInOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseCircleActionInOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseCircleActionInOut",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseCircleActionInOut_create));

	


	TypeTest<cocos2d::EaseCircleActionInOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseCircleActionInOut",classValue);
}
RBVAL rb_cocos2dx_EaseCubicActionIn_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseCubicActionIn_create : Error processing arguments");return RBNil();}
		cocos2d::EaseCubicActionIn* ret = cocos2d::EaseCubicActionIn::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseCubicActionIn>((cocos2d::EaseCubicActionIn*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseCubicActionIn_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseCubicActionIn() {
		
	RBVAL classValue=rb_define_class_bridge("EaseCubicActionIn",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseCubicActionIn_create));

	


	TypeTest<cocos2d::EaseCubicActionIn> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseCubicActionIn",classValue);
}
RBVAL rb_cocos2dx_EaseCubicActionOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseCubicActionOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseCubicActionOut* ret = cocos2d::EaseCubicActionOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseCubicActionOut>((cocos2d::EaseCubicActionOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseCubicActionOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseCubicActionOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseCubicActionOut",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseCubicActionOut_create));

	


	TypeTest<cocos2d::EaseCubicActionOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseCubicActionOut",classValue);
}
RBVAL rb_cocos2dx_EaseCubicActionInOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::ActionInterval* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_EaseCubicActionInOut_create : Error processing arguments");return RBNil();}
		cocos2d::EaseCubicActionInOut* ret = cocos2d::EaseCubicActionInOut::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::EaseCubicActionInOut>((cocos2d::EaseCubicActionInOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_EaseCubicActionInOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_EaseCubicActionInOut() {
		
	RBVAL classValue=rb_define_class_bridge("EaseCubicActionInOut",rb_get_class_value("cocos2d::ActionEase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_EaseCubicActionInOut_create));

	


	TypeTest<cocos2d::EaseCubicActionInOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::EaseCubicActionInOut",classValue);
}


void rb_register_cocos2dx_ActionInstant() {
		
	RBVAL classValue=rb_define_class_bridge("ActionInstant",rb_get_class_value("cocos2d::FiniteTimeAction"),true);



	TypeTest<cocos2d::ActionInstant> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ActionInstant",classValue);
}
RBVAL rb_cocos2dx_Show_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::Show* ret = cocos2d::Show::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Show>((cocos2d::Show*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Show_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Show() {
		
	RBVAL classValue=rb_define_class_bridge("Show",rb_get_class_value("cocos2d::ActionInstant"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Show_create));

	


	TypeTest<cocos2d::Show> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Show",classValue);
}
RBVAL rb_cocos2dx_Hide_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::Hide* ret = cocos2d::Hide::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Hide>((cocos2d::Hide*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Hide_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Hide() {
		
	RBVAL classValue=rb_define_class_bridge("Hide",rb_get_class_value("cocos2d::ActionInstant"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Hide_create));

	


	TypeTest<cocos2d::Hide> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Hide",classValue);
}
RBVAL rb_cocos2dx_ToggleVisibility_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::ToggleVisibility* ret = cocos2d::ToggleVisibility::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ToggleVisibility>((cocos2d::ToggleVisibility*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ToggleVisibility_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ToggleVisibility() {
		
	RBVAL classValue=rb_define_class_bridge("ToggleVisibility",rb_get_class_value("cocos2d::ActionInstant"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ToggleVisibility_create));

	


	TypeTest<cocos2d::ToggleVisibility> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ToggleVisibility",classValue);
}
RBVAL rb_cocos2dx_RemoveSelf_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 0) {
		cocos2d::RemoveSelf* ret = cocos2d::RemoveSelf::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::RemoveSelf>((cocos2d::RemoveSelf*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	if (argc == 1) {
		bool arg0;
		ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RemoveSelf_create : Error processing arguments");return RBNil();}
		cocos2d::RemoveSelf* ret = cocos2d::RemoveSelf::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::RemoveSelf>((cocos2d::RemoveSelf*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_RemoveSelf_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_RemoveSelf() {
		
	RBVAL classValue=rb_define_class_bridge("RemoveSelf",rb_get_class_value("cocos2d::ActionInstant"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_RemoveSelf_create));

	


	TypeTest<cocos2d::RemoveSelf> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::RemoveSelf",classValue);
}
RBVAL rb_cocos2dx_FlipX_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		bool arg0;
		ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FlipX_create : Error processing arguments");return RBNil();}
		cocos2d::FlipX* ret = cocos2d::FlipX::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::FlipX>((cocos2d::FlipX*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_FlipX_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_FlipX() {
		
	RBVAL classValue=rb_define_class_bridge("FlipX",rb_get_class_value("cocos2d::ActionInstant"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_FlipX_create));

	


	TypeTest<cocos2d::FlipX> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::FlipX",classValue);
}
RBVAL rb_cocos2dx_FlipY_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		bool arg0;
		ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FlipY_create : Error processing arguments");return RBNil();}
		cocos2d::FlipY* ret = cocos2d::FlipY::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::FlipY>((cocos2d::FlipY*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_FlipY_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_FlipY() {
		
	RBVAL classValue=rb_define_class_bridge("FlipY",rb_get_class_value("cocos2d::ActionInstant"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_FlipY_create));

	


	TypeTest<cocos2d::FlipY> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::FlipY",classValue);
}
RBVAL rb_cocos2dx_Place_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::Vec2 arg0;
		ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Place_create : Error processing arguments");return RBNil();}
		cocos2d::Place* ret = cocos2d::Place::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Place>((cocos2d::Place*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Place_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Place() {
		
	RBVAL classValue=rb_define_class_bridge("Place",rb_get_class_value("cocos2d::ActionInstant"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Place_create));

	


	TypeTest<cocos2d::Place> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Place",classValue);
}
RBVAL rb_cocos2dx_CallFunc_execute(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::CallFunc* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_CallFunc_execute : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->execute();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_CallFunc_execute : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_CallFunc_getTargetCallback(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::CallFunc* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_CallFunc_getTargetCallback : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Ref* ret = cobj->getTargetCallback();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Ref>((cocos2d::Ref*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_CallFunc_getTargetCallback : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_CallFunc_setTargetCallback(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::CallFunc* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_CallFunc_setTargetCallback : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Ref* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_CallFunc_setTargetCallback : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTargetCallback(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("targetCallback");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_CallFunc_setTargetCallback : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_CallFunc() {
		
	RBVAL classValue=rb_define_class_bridge("CallFunc",rb_get_class_value("cocos2d::ActionInstant"),true);

	rb_define_method_bridge(classValue,"execute",RB_FUNC(rb_cocos2dx_CallFunc_execute));

	

	rb_define_method_bridge(classValue,"getTargetCallback",RB_FUNC(rb_cocos2dx_CallFunc_getTargetCallback));

   rb_define_method_bridge(classValue,"targetCallback",RB_FUNC(rb_cocos2dx_CallFunc_getTargetCallback));
	

	rb_define_method_bridge(classValue,"setTargetCallback",RB_FUNC(rb_cocos2dx_CallFunc_setTargetCallback));

    rb_define_method_bridge(classValue,"targetCallback=",RB_FUNC(rb_cocos2dx_CallFunc_setTargetCallback));
	



	TypeTest<cocos2d::CallFunc> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::CallFunc",classValue);
}
RBVAL rb_cocos2dx_GridAction_getGrid(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridAction* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridAction_getGrid : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::GridBase* ret = cobj->getGrid();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::GridBase>((cocos2d::GridBase*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridAction_getGrid : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_GridAction() {
		
	RBVAL classValue=rb_define_class_bridge("GridAction",rb_get_class_value("cocos2d::ActionInterval"),true);

	rb_define_method_bridge(classValue,"getGrid",RB_FUNC(rb_cocos2dx_GridAction_getGrid));

   rb_define_method_bridge(classValue,"grid",RB_FUNC(rb_cocos2dx_GridAction_getGrid));
	



	TypeTest<cocos2d::GridAction> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::GridAction",classValue);
}
RBVAL rb_cocos2dx_Grid3DAction_getGrid(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Grid3DAction* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Grid3DAction_getGrid : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::GridBase* ret = cobj->getGrid();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::GridBase>((cocos2d::GridBase*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Grid3DAction_getGrid : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_Grid3DAction() {
		
	RBVAL classValue=rb_define_class_bridge("Grid3DAction",rb_get_class_value("cocos2d::GridAction"),true);

	rb_define_method_bridge(classValue,"getGrid",RB_FUNC(rb_cocos2dx_Grid3DAction_getGrid));

   rb_define_method_bridge(classValue,"grid",RB_FUNC(rb_cocos2dx_Grid3DAction_getGrid));
	



	TypeTest<cocos2d::Grid3DAction> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Grid3DAction",classValue);
}
RBVAL rb_cocos2dx_TiledGrid3DAction_getGrid(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TiledGrid3DAction* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TiledGrid3DAction_getGrid : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::GridBase* ret = cobj->getGrid();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::GridBase>((cocos2d::GridBase*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TiledGrid3DAction_getGrid : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_TiledGrid3DAction() {
		
	RBVAL classValue=rb_define_class_bridge("TiledGrid3DAction",rb_get_class_value("cocos2d::GridAction"),true);

	rb_define_method_bridge(classValue,"getGrid",RB_FUNC(rb_cocos2dx_TiledGrid3DAction_getGrid));

   rb_define_method_bridge(classValue,"grid",RB_FUNC(rb_cocos2dx_TiledGrid3DAction_getGrid));
	



	TypeTest<cocos2d::TiledGrid3DAction> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TiledGrid3DAction",classValue);
}
RBVAL rb_cocos2dx_StopGrid_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::StopGrid* ret = cocos2d::StopGrid::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::StopGrid>((cocos2d::StopGrid*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_StopGrid_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_StopGrid() {
		
	RBVAL classValue=rb_define_class_bridge("StopGrid",rb_get_class_value("cocos2d::ActionInstant"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_StopGrid_create));

	


	TypeTest<cocos2d::StopGrid> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::StopGrid",classValue);
}
RBVAL rb_cocos2dx_ReuseGrid_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		int arg0;
		ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ReuseGrid_create : Error processing arguments");return RBNil();}
		cocos2d::ReuseGrid* ret = cocos2d::ReuseGrid::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ReuseGrid>((cocos2d::ReuseGrid*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ReuseGrid_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ReuseGrid() {
		
	RBVAL classValue=rb_define_class_bridge("ReuseGrid",rb_get_class_value("cocos2d::ActionInstant"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ReuseGrid_create));

	


	TypeTest<cocos2d::ReuseGrid> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ReuseGrid",classValue);
}
RBVAL rb_cocos2dx_Waves3D_getAmplitudeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Waves3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Waves3D_getAmplitudeRate : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAmplitudeRate();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Waves3D_getAmplitudeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Waves3D_setAmplitude(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Waves3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Waves3D_setAmplitude : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Waves3D_setAmplitude : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAmplitude(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("amplitude");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Waves3D_setAmplitude : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Waves3D_setAmplitudeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Waves3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Waves3D_setAmplitudeRate : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Waves3D_setAmplitudeRate : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAmplitudeRate(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("amplitudeRate");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Waves3D_setAmplitudeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Waves3D_getAmplitude(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Waves3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Waves3D_getAmplitude : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAmplitude();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Waves3D_getAmplitude : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Waves3D_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 4) {
		float arg0;
		cocos2d::Size arg1;
		unsigned int arg2;
		float arg3;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
		ok &= rb_value_to_uint(argv[2], &arg2);
		ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Waves3D_create : Error processing arguments");return RBNil();}
		cocos2d::Waves3D* ret = cocos2d::Waves3D::create(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Waves3D>((cocos2d::Waves3D*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Waves3D_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Waves3D() {
		
	RBVAL classValue=rb_define_class_bridge("Waves3D",rb_get_class_value("cocos2d::Grid3DAction"),true);

	rb_define_method_bridge(classValue,"getAmplitudeRate",RB_FUNC(rb_cocos2dx_Waves3D_getAmplitudeRate));

   rb_define_method_bridge(classValue,"amplitudeRate",RB_FUNC(rb_cocos2dx_Waves3D_getAmplitudeRate));
	

	rb_define_method_bridge(classValue,"setAmplitude",RB_FUNC(rb_cocos2dx_Waves3D_setAmplitude));

    rb_define_method_bridge(classValue,"amplitude=",RB_FUNC(rb_cocos2dx_Waves3D_setAmplitude));
	

	rb_define_method_bridge(classValue,"setAmplitudeRate",RB_FUNC(rb_cocos2dx_Waves3D_setAmplitudeRate));

    rb_define_method_bridge(classValue,"amplitudeRate=",RB_FUNC(rb_cocos2dx_Waves3D_setAmplitudeRate));
	

	rb_define_method_bridge(classValue,"getAmplitude",RB_FUNC(rb_cocos2dx_Waves3D_getAmplitude));

   rb_define_method_bridge(classValue,"amplitude",RB_FUNC(rb_cocos2dx_Waves3D_getAmplitude));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Waves3D_create));

	


	TypeTest<cocos2d::Waves3D> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Waves3D",classValue);
}
RBVAL rb_cocos2dx_FlipX3D_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		float arg0;
		ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FlipX3D_create : Error processing arguments");return RBNil();}
		cocos2d::FlipX3D* ret = cocos2d::FlipX3D::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::FlipX3D>((cocos2d::FlipX3D*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_FlipX3D_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_FlipX3D() {
		
	RBVAL classValue=rb_define_class_bridge("FlipX3D",rb_get_class_value("cocos2d::Grid3DAction"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_FlipX3D_create));

	


	TypeTest<cocos2d::FlipX3D> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::FlipX3D",classValue);
}
RBVAL rb_cocos2dx_FlipY3D_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		float arg0;
		ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FlipY3D_create : Error processing arguments");return RBNil();}
		cocos2d::FlipY3D* ret = cocos2d::FlipY3D::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::FlipY3D>((cocos2d::FlipY3D*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_FlipY3D_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_FlipY3D() {
		
	RBVAL classValue=rb_define_class_bridge("FlipY3D",rb_get_class_value("cocos2d::FlipX3D"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_FlipY3D_create));

	


	TypeTest<cocos2d::FlipY3D> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::FlipY3D",classValue);
}
RBVAL rb_cocos2dx_Lens3D_setPosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Lens3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Lens3D_setPosition : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Lens3D_setPosition : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setPosition(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("position");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Lens3D_setPosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Lens3D_setConcave(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Lens3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Lens3D_setConcave : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Lens3D_setConcave : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setConcave(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("concave");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Lens3D_setConcave : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Lens3D_setLensEffect(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Lens3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Lens3D_setLensEffect : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Lens3D_setLensEffect : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setLensEffect(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("lensEffect");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Lens3D_setLensEffect : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Lens3D_getPosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Lens3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Lens3D_getPosition : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec2& ret = cobj->getPosition();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Lens3D_getPosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Lens3D_getLensEffect(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Lens3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Lens3D_getLensEffect : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getLensEffect();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Lens3D_getLensEffect : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Lens3D_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 4) {
		float arg0;
		cocos2d::Size arg1;
		cocos2d::Vec2 arg2;
		float arg3;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
		ok &= rb_value_to_vec2(argv[2], &arg2);
		ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Lens3D_create : Error processing arguments");return RBNil();}
		cocos2d::Lens3D* ret = cocos2d::Lens3D::create(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Lens3D>((cocos2d::Lens3D*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Lens3D_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Lens3D() {
		
	RBVAL classValue=rb_define_class_bridge("Lens3D",rb_get_class_value("cocos2d::Grid3DAction"),true);

	rb_define_method_bridge(classValue,"setPosition",RB_FUNC(rb_cocos2dx_Lens3D_setPosition));

    rb_define_method_bridge(classValue,"position=",RB_FUNC(rb_cocos2dx_Lens3D_setPosition));
	

	rb_define_method_bridge(classValue,"setConcave",RB_FUNC(rb_cocos2dx_Lens3D_setConcave));

    rb_define_method_bridge(classValue,"concave=",RB_FUNC(rb_cocos2dx_Lens3D_setConcave));
	

	rb_define_method_bridge(classValue,"setLensEffect",RB_FUNC(rb_cocos2dx_Lens3D_setLensEffect));

    rb_define_method_bridge(classValue,"lensEffect=",RB_FUNC(rb_cocos2dx_Lens3D_setLensEffect));
	

	rb_define_method_bridge(classValue,"getPosition",RB_FUNC(rb_cocos2dx_Lens3D_getPosition));

   rb_define_method_bridge(classValue,"position",RB_FUNC(rb_cocos2dx_Lens3D_getPosition));
	

	rb_define_method_bridge(classValue,"getLensEffect",RB_FUNC(rb_cocos2dx_Lens3D_getLensEffect));

   rb_define_method_bridge(classValue,"lensEffect",RB_FUNC(rb_cocos2dx_Lens3D_getLensEffect));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Lens3D_create));

	


	TypeTest<cocos2d::Lens3D> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Lens3D",classValue);
}
RBVAL rb_cocos2dx_Ripple3D_setAmplitudeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Ripple3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Ripple3D_setAmplitudeRate : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Ripple3D_setAmplitudeRate : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAmplitudeRate(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("amplitudeRate");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Ripple3D_setAmplitudeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Ripple3D_getAmplitudeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Ripple3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Ripple3D_getAmplitudeRate : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAmplitudeRate();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Ripple3D_getAmplitudeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Ripple3D_setAmplitude(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Ripple3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Ripple3D_setAmplitude : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Ripple3D_setAmplitude : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAmplitude(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("amplitude");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Ripple3D_setAmplitude : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Ripple3D_getAmplitude(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Ripple3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Ripple3D_getAmplitude : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAmplitude();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Ripple3D_getAmplitude : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Ripple3D_setPosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Ripple3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Ripple3D_setPosition : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Ripple3D_setPosition : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setPosition(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("position");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Ripple3D_setPosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Ripple3D_getPosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Ripple3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Ripple3D_getPosition : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec2& ret = cobj->getPosition();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Ripple3D_getPosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Ripple3D_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 6) {
		float arg0;
		cocos2d::Size arg1;
		cocos2d::Vec2 arg2;
		float arg3;
		unsigned int arg4;
		float arg5;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
		ok &= rb_value_to_vec2(argv[2], &arg2);
		ok &= rb_value_to_float(argv[3], &arg3);
		ok &= rb_value_to_uint(argv[4], &arg4);
		ok &= rb_value_to_float(argv[5], &arg5);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Ripple3D_create : Error processing arguments");return RBNil();}
		cocos2d::Ripple3D* ret = cocos2d::Ripple3D::create(arg0, arg1, arg2, arg3, arg4, arg5);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Ripple3D>((cocos2d::Ripple3D*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Ripple3D_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Ripple3D() {
		
	RBVAL classValue=rb_define_class_bridge("Ripple3D",rb_get_class_value("cocos2d::Grid3DAction"),true);

	rb_define_method_bridge(classValue,"setAmplitudeRate",RB_FUNC(rb_cocos2dx_Ripple3D_setAmplitudeRate));

    rb_define_method_bridge(classValue,"amplitudeRate=",RB_FUNC(rb_cocos2dx_Ripple3D_setAmplitudeRate));
	

	rb_define_method_bridge(classValue,"getAmplitudeRate",RB_FUNC(rb_cocos2dx_Ripple3D_getAmplitudeRate));

   rb_define_method_bridge(classValue,"amplitudeRate",RB_FUNC(rb_cocos2dx_Ripple3D_getAmplitudeRate));
	

	rb_define_method_bridge(classValue,"setAmplitude",RB_FUNC(rb_cocos2dx_Ripple3D_setAmplitude));

    rb_define_method_bridge(classValue,"amplitude=",RB_FUNC(rb_cocos2dx_Ripple3D_setAmplitude));
	

	rb_define_method_bridge(classValue,"getAmplitude",RB_FUNC(rb_cocos2dx_Ripple3D_getAmplitude));

   rb_define_method_bridge(classValue,"amplitude",RB_FUNC(rb_cocos2dx_Ripple3D_getAmplitude));
	

	rb_define_method_bridge(classValue,"setPosition",RB_FUNC(rb_cocos2dx_Ripple3D_setPosition));

    rb_define_method_bridge(classValue,"position=",RB_FUNC(rb_cocos2dx_Ripple3D_setPosition));
	

	rb_define_method_bridge(classValue,"getPosition",RB_FUNC(rb_cocos2dx_Ripple3D_getPosition));

   rb_define_method_bridge(classValue,"position",RB_FUNC(rb_cocos2dx_Ripple3D_getPosition));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Ripple3D_create));

	


	TypeTest<cocos2d::Ripple3D> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Ripple3D",classValue);
}
RBVAL rb_cocos2dx_Shaky3D_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 4) {
		float arg0;
		cocos2d::Size arg1;
		int arg2;
		bool arg3;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
		ok &= rb_value_to_int(argv[2], (int *)&arg2);
		ok &= rb_value_to_bool(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Shaky3D_create : Error processing arguments");return RBNil();}
		cocos2d::Shaky3D* ret = cocos2d::Shaky3D::create(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Shaky3D>((cocos2d::Shaky3D*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Shaky3D_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Shaky3D() {
		
	RBVAL classValue=rb_define_class_bridge("Shaky3D",rb_get_class_value("cocos2d::Grid3DAction"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Shaky3D_create));

	


	TypeTest<cocos2d::Shaky3D> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Shaky3D",classValue);
}
RBVAL rb_cocos2dx_Liquid_getAmplitudeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Liquid* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Liquid_getAmplitudeRate : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAmplitudeRate();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Liquid_getAmplitudeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Liquid_setAmplitude(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Liquid* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Liquid_setAmplitude : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Liquid_setAmplitude : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAmplitude(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("amplitude");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Liquid_setAmplitude : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Liquid_setAmplitudeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Liquid* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Liquid_setAmplitudeRate : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Liquid_setAmplitudeRate : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAmplitudeRate(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("amplitudeRate");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Liquid_setAmplitudeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Liquid_getAmplitude(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Liquid* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Liquid_getAmplitude : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAmplitude();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Liquid_getAmplitude : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Liquid_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 4) {
		float arg0;
		cocos2d::Size arg1;
		unsigned int arg2;
		float arg3;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
		ok &= rb_value_to_uint(argv[2], &arg2);
		ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Liquid_create : Error processing arguments");return RBNil();}
		cocos2d::Liquid* ret = cocos2d::Liquid::create(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Liquid>((cocos2d::Liquid*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Liquid_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Liquid() {
		
	RBVAL classValue=rb_define_class_bridge("Liquid",rb_get_class_value("cocos2d::Grid3DAction"),true);

	rb_define_method_bridge(classValue,"getAmplitudeRate",RB_FUNC(rb_cocos2dx_Liquid_getAmplitudeRate));

   rb_define_method_bridge(classValue,"amplitudeRate",RB_FUNC(rb_cocos2dx_Liquid_getAmplitudeRate));
	

	rb_define_method_bridge(classValue,"setAmplitude",RB_FUNC(rb_cocos2dx_Liquid_setAmplitude));

    rb_define_method_bridge(classValue,"amplitude=",RB_FUNC(rb_cocos2dx_Liquid_setAmplitude));
	

	rb_define_method_bridge(classValue,"setAmplitudeRate",RB_FUNC(rb_cocos2dx_Liquid_setAmplitudeRate));

    rb_define_method_bridge(classValue,"amplitudeRate=",RB_FUNC(rb_cocos2dx_Liquid_setAmplitudeRate));
	

	rb_define_method_bridge(classValue,"getAmplitude",RB_FUNC(rb_cocos2dx_Liquid_getAmplitude));

   rb_define_method_bridge(classValue,"amplitude",RB_FUNC(rb_cocos2dx_Liquid_getAmplitude));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Liquid_create));

	


	TypeTest<cocos2d::Liquid> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Liquid",classValue);
}
RBVAL rb_cocos2dx_Waves_getAmplitudeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Waves* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Waves_getAmplitudeRate : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAmplitudeRate();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Waves_getAmplitudeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Waves_setAmplitude(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Waves* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Waves_setAmplitude : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Waves_setAmplitude : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAmplitude(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("amplitude");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Waves_setAmplitude : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Waves_setAmplitudeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Waves* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Waves_setAmplitudeRate : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Waves_setAmplitudeRate : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAmplitudeRate(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("amplitudeRate");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Waves_setAmplitudeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Waves_getAmplitude(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Waves* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Waves_getAmplitude : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAmplitude();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Waves_getAmplitude : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Waves_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 6) {
		float arg0;
		cocos2d::Size arg1;
		unsigned int arg2;
		float arg3;
		bool arg4;
		bool arg5;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
		ok &= rb_value_to_uint(argv[2], &arg2);
		ok &= rb_value_to_float(argv[3], &arg3);
		ok &= rb_value_to_bool(argv[4], &arg4);
		ok &= rb_value_to_bool(argv[5], &arg5);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Waves_create : Error processing arguments");return RBNil();}
		cocos2d::Waves* ret = cocos2d::Waves::create(arg0, arg1, arg2, arg3, arg4, arg5);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Waves>((cocos2d::Waves*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Waves_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Waves() {
		
	RBVAL classValue=rb_define_class_bridge("Waves",rb_get_class_value("cocos2d::Grid3DAction"),true);

	rb_define_method_bridge(classValue,"getAmplitudeRate",RB_FUNC(rb_cocos2dx_Waves_getAmplitudeRate));

   rb_define_method_bridge(classValue,"amplitudeRate",RB_FUNC(rb_cocos2dx_Waves_getAmplitudeRate));
	

	rb_define_method_bridge(classValue,"setAmplitude",RB_FUNC(rb_cocos2dx_Waves_setAmplitude));

    rb_define_method_bridge(classValue,"amplitude=",RB_FUNC(rb_cocos2dx_Waves_setAmplitude));
	

	rb_define_method_bridge(classValue,"setAmplitudeRate",RB_FUNC(rb_cocos2dx_Waves_setAmplitudeRate));

    rb_define_method_bridge(classValue,"amplitudeRate=",RB_FUNC(rb_cocos2dx_Waves_setAmplitudeRate));
	

	rb_define_method_bridge(classValue,"getAmplitude",RB_FUNC(rb_cocos2dx_Waves_getAmplitude));

   rb_define_method_bridge(classValue,"amplitude",RB_FUNC(rb_cocos2dx_Waves_getAmplitude));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Waves_create));

	


	TypeTest<cocos2d::Waves> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Waves",classValue);
}
RBVAL rb_cocos2dx_Twirl_setAmplitudeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Twirl* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Twirl_setAmplitudeRate : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Twirl_setAmplitudeRate : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAmplitudeRate(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("amplitudeRate");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Twirl_setAmplitudeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Twirl_getAmplitudeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Twirl* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Twirl_getAmplitudeRate : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAmplitudeRate();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Twirl_getAmplitudeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Twirl_setAmplitude(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Twirl* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Twirl_setAmplitude : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Twirl_setAmplitude : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAmplitude(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("amplitude");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Twirl_setAmplitude : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Twirl_getAmplitude(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Twirl* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Twirl_getAmplitude : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAmplitude();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Twirl_getAmplitude : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Twirl_setPosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Twirl* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Twirl_setPosition : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Twirl_setPosition : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setPosition(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("position");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Twirl_setPosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Twirl_getPosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Twirl* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Twirl_getPosition : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec2& ret = cobj->getPosition();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Twirl_getPosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Twirl_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 5) {
		float arg0;
		cocos2d::Size arg1;
		cocos2d::Vec2 arg2;
		unsigned int arg3;
		float arg4;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
		ok &= rb_value_to_vec2(argv[2], &arg2);
		ok &= rb_value_to_uint(argv[3], &arg3);
		ok &= rb_value_to_float(argv[4], &arg4);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Twirl_create : Error processing arguments");return RBNil();}
		cocos2d::Twirl* ret = cocos2d::Twirl::create(arg0, arg1, arg2, arg3, arg4);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Twirl>((cocos2d::Twirl*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Twirl_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Twirl() {
		
	RBVAL classValue=rb_define_class_bridge("Twirl",rb_get_class_value("cocos2d::Grid3DAction"),true);

	rb_define_method_bridge(classValue,"setAmplitudeRate",RB_FUNC(rb_cocos2dx_Twirl_setAmplitudeRate));

    rb_define_method_bridge(classValue,"amplitudeRate=",RB_FUNC(rb_cocos2dx_Twirl_setAmplitudeRate));
	

	rb_define_method_bridge(classValue,"getAmplitudeRate",RB_FUNC(rb_cocos2dx_Twirl_getAmplitudeRate));

   rb_define_method_bridge(classValue,"amplitudeRate",RB_FUNC(rb_cocos2dx_Twirl_getAmplitudeRate));
	

	rb_define_method_bridge(classValue,"setAmplitude",RB_FUNC(rb_cocos2dx_Twirl_setAmplitude));

    rb_define_method_bridge(classValue,"amplitude=",RB_FUNC(rb_cocos2dx_Twirl_setAmplitude));
	

	rb_define_method_bridge(classValue,"getAmplitude",RB_FUNC(rb_cocos2dx_Twirl_getAmplitude));

   rb_define_method_bridge(classValue,"amplitude",RB_FUNC(rb_cocos2dx_Twirl_getAmplitude));
	

	rb_define_method_bridge(classValue,"setPosition",RB_FUNC(rb_cocos2dx_Twirl_setPosition));

    rb_define_method_bridge(classValue,"position=",RB_FUNC(rb_cocos2dx_Twirl_setPosition));
	

	rb_define_method_bridge(classValue,"getPosition",RB_FUNC(rb_cocos2dx_Twirl_getPosition));

   rb_define_method_bridge(classValue,"position",RB_FUNC(rb_cocos2dx_Twirl_getPosition));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Twirl_create));

	


	TypeTest<cocos2d::Twirl> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Twirl",classValue);
}
RBVAL rb_cocos2dx_PageTurn3D_getGrid(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::PageTurn3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_PageTurn3D_getGrid : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::GridBase* ret = cobj->getGrid();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::GridBase>((cocos2d::GridBase*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_PageTurn3D_getGrid : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_PageTurn3D_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Size arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_PageTurn3D_create : Error processing arguments");return RBNil();}
		cocos2d::PageTurn3D* ret = cocos2d::PageTurn3D::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::PageTurn3D>((cocos2d::PageTurn3D*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_PageTurn3D_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_PageTurn3D() {
		
	RBVAL classValue=rb_define_class_bridge("PageTurn3D",rb_get_class_value("cocos2d::Grid3DAction"),true);

	rb_define_method_bridge(classValue,"getGrid",RB_FUNC(rb_cocos2dx_PageTurn3D_getGrid));

   rb_define_method_bridge(classValue,"grid",RB_FUNC(rb_cocos2dx_PageTurn3D_getGrid));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_PageTurn3D_create));

	


	TypeTest<cocos2d::PageTurn3D> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::PageTurn3D",classValue);
}
RBVAL rb_cocos2dx_ProgressTo_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		float arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTo_create : Error processing arguments");return RBNil();}
		cocos2d::ProgressTo* ret = cocos2d::ProgressTo::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ProgressTo>((cocos2d::ProgressTo*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ProgressTo_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ProgressTo() {
		
	RBVAL classValue=rb_define_class_bridge("ProgressTo",rb_get_class_value("cocos2d::ActionInterval"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ProgressTo_create));

	


	TypeTest<cocos2d::ProgressTo> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ProgressTo",classValue);
}
RBVAL rb_cocos2dx_ProgressFromTo_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 3) {
		float arg0;
		float arg1;
		float arg2;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_float(argv[1], &arg1);
		ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressFromTo_create : Error processing arguments");return RBNil();}
		cocos2d::ProgressFromTo* ret = cocos2d::ProgressFromTo::create(arg0, arg1, arg2);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ProgressFromTo>((cocos2d::ProgressFromTo*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ProgressFromTo_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ProgressFromTo() {
		
	RBVAL classValue=rb_define_class_bridge("ProgressFromTo",rb_get_class_value("cocos2d::ActionInterval"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ProgressFromTo_create));

	


	TypeTest<cocos2d::ProgressFromTo> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ProgressFromTo",classValue);
}
RBVAL rb_cocos2dx_ShakyTiles3D_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 4) {
		float arg0;
		cocos2d::Size arg1;
		int arg2;
		bool arg3;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
		ok &= rb_value_to_int(argv[2], (int *)&arg2);
		ok &= rb_value_to_bool(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ShakyTiles3D_create : Error processing arguments");return RBNil();}
		cocos2d::ShakyTiles3D* ret = cocos2d::ShakyTiles3D::create(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ShakyTiles3D>((cocos2d::ShakyTiles3D*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ShakyTiles3D_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ShakyTiles3D() {
		
	RBVAL classValue=rb_define_class_bridge("ShakyTiles3D",rb_get_class_value("cocos2d::TiledGrid3DAction"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ShakyTiles3D_create));

	


	TypeTest<cocos2d::ShakyTiles3D> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ShakyTiles3D",classValue);
}
RBVAL rb_cocos2dx_ShatteredTiles3D_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 4) {
		float arg0;
		cocos2d::Size arg1;
		int arg2;
		bool arg3;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
		ok &= rb_value_to_int(argv[2], (int *)&arg2);
		ok &= rb_value_to_bool(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ShatteredTiles3D_create : Error processing arguments");return RBNil();}
		cocos2d::ShatteredTiles3D* ret = cocos2d::ShatteredTiles3D::create(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ShatteredTiles3D>((cocos2d::ShatteredTiles3D*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ShatteredTiles3D_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ShatteredTiles3D() {
		
	RBVAL classValue=rb_define_class_bridge("ShatteredTiles3D",rb_get_class_value("cocos2d::TiledGrid3DAction"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ShatteredTiles3D_create));

	


	TypeTest<cocos2d::ShatteredTiles3D> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ShatteredTiles3D",classValue);
}
RBVAL rb_cocos2dx_ShuffleTiles_getDelta(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ShuffleTiles* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ShuffleTiles_getDelta : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Size arg0;
			ok &= rb_value_to_ccsize(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ShuffleTiles_getDelta : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Size ret = cobj->getDelta(arg0);
				value = ccsize_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ShuffleTiles_getDelta : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ShuffleTiles_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 3) {
		float arg0;
		cocos2d::Size arg1;
		unsigned int arg2;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
		ok &= rb_value_to_uint(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ShuffleTiles_create : Error processing arguments");return RBNil();}
		cocos2d::ShuffleTiles* ret = cocos2d::ShuffleTiles::create(arg0, arg1, arg2);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ShuffleTiles>((cocos2d::ShuffleTiles*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ShuffleTiles_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ShuffleTiles() {
		
	RBVAL classValue=rb_define_class_bridge("ShuffleTiles",rb_get_class_value("cocos2d::TiledGrid3DAction"),true);

	rb_define_method_bridge(classValue,"getDelta",RB_FUNC(rb_cocos2dx_ShuffleTiles_getDelta));

   rb_define_method_bridge(classValue,"delta",RB_FUNC(rb_cocos2dx_ShuffleTiles_getDelta));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ShuffleTiles_create));

	


	TypeTest<cocos2d::ShuffleTiles> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ShuffleTiles",classValue);
}
RBVAL rb_cocos2dx_FadeOutTRTiles_turnOnTile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FadeOutTRTiles* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOutTRTiles_turnOnTile : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOutTRTiles_turnOnTile : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->turnOnTile(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FadeOutTRTiles_turnOnTile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FadeOutTRTiles_turnOffTile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FadeOutTRTiles* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOutTRTiles_turnOffTile : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOutTRTiles_turnOffTile : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->turnOffTile(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FadeOutTRTiles_turnOffTile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FadeOutTRTiles_transformTile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FadeOutTRTiles* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOutTRTiles_transformTile : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::Vec2 arg0;
			float arg1;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOutTRTiles_transformTile : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->transformTile(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FadeOutTRTiles_transformTile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FadeOutTRTiles_testFunc(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FadeOutTRTiles* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOutTRTiles_testFunc : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::Size arg0;
			float arg1;
			ok &= rb_value_to_ccsize(argv[0], &arg0);
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOutTRTiles_testFunc : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
					float ret = cobj->testFunc(arg0, arg1);
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FadeOutTRTiles_testFunc : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FadeOutTRTiles_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Size arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOutTRTiles_create : Error processing arguments");return RBNil();}
		cocos2d::FadeOutTRTiles* ret = cocos2d::FadeOutTRTiles::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::FadeOutTRTiles>((cocos2d::FadeOutTRTiles*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_FadeOutTRTiles_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_FadeOutTRTiles() {
		
	RBVAL classValue=rb_define_class_bridge("FadeOutTRTiles",rb_get_class_value("cocos2d::TiledGrid3DAction"),true);

	rb_define_method_bridge(classValue,"turnOnTile",RB_FUNC(rb_cocos2dx_FadeOutTRTiles_turnOnTile));

	

	rb_define_method_bridge(classValue,"turnOffTile",RB_FUNC(rb_cocos2dx_FadeOutTRTiles_turnOffTile));

	

	rb_define_method_bridge(classValue,"transformTile",RB_FUNC(rb_cocos2dx_FadeOutTRTiles_transformTile));

	

	rb_define_method_bridge(classValue,"testFunc",RB_FUNC(rb_cocos2dx_FadeOutTRTiles_testFunc));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_FadeOutTRTiles_create));

	


	TypeTest<cocos2d::FadeOutTRTiles> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::FadeOutTRTiles",classValue);
}
RBVAL rb_cocos2dx_FadeOutBLTiles_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Size arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOutBLTiles_create : Error processing arguments");return RBNil();}
		cocos2d::FadeOutBLTiles* ret = cocos2d::FadeOutBLTiles::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::FadeOutBLTiles>((cocos2d::FadeOutBLTiles*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_FadeOutBLTiles_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_FadeOutBLTiles() {
		
	RBVAL classValue=rb_define_class_bridge("FadeOutBLTiles",rb_get_class_value("cocos2d::FadeOutTRTiles"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_FadeOutBLTiles_create));

	


	TypeTest<cocos2d::FadeOutBLTiles> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::FadeOutBLTiles",classValue);
}
RBVAL rb_cocos2dx_FadeOutUpTiles_transformTile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::FadeOutUpTiles* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOutUpTiles_transformTile : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::Vec2 arg0;
			float arg1;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOutUpTiles_transformTile : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->transformTile(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_FadeOutUpTiles_transformTile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_FadeOutUpTiles_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Size arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOutUpTiles_create : Error processing arguments");return RBNil();}
		cocos2d::FadeOutUpTiles* ret = cocos2d::FadeOutUpTiles::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::FadeOutUpTiles>((cocos2d::FadeOutUpTiles*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_FadeOutUpTiles_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_FadeOutUpTiles() {
		
	RBVAL classValue=rb_define_class_bridge("FadeOutUpTiles",rb_get_class_value("cocos2d::FadeOutTRTiles"),true);

	rb_define_method_bridge(classValue,"transformTile",RB_FUNC(rb_cocos2dx_FadeOutUpTiles_transformTile));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_FadeOutUpTiles_create));

	


	TypeTest<cocos2d::FadeOutUpTiles> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::FadeOutUpTiles",classValue);
}
RBVAL rb_cocos2dx_FadeOutDownTiles_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Size arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_FadeOutDownTiles_create : Error processing arguments");return RBNil();}
		cocos2d::FadeOutDownTiles* ret = cocos2d::FadeOutDownTiles::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::FadeOutDownTiles>((cocos2d::FadeOutDownTiles*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_FadeOutDownTiles_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_FadeOutDownTiles() {
		
	RBVAL classValue=rb_define_class_bridge("FadeOutDownTiles",rb_get_class_value("cocos2d::FadeOutUpTiles"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_FadeOutDownTiles_create));

	


	TypeTest<cocos2d::FadeOutDownTiles> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::FadeOutDownTiles",classValue);
}
RBVAL rb_cocos2dx_TurnOffTiles_turnOnTile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TurnOffTiles* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TurnOffTiles_turnOnTile : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TurnOffTiles_turnOnTile : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->turnOnTile(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TurnOffTiles_turnOnTile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TurnOffTiles_turnOffTile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TurnOffTiles* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TurnOffTiles_turnOffTile : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TurnOffTiles_turnOffTile : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->turnOffTile(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TurnOffTiles_turnOffTile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TurnOffTiles_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 3) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Size arg1;
			ok &= rb_value_to_ccsize(argv[1], &arg1);
			if (!ok) { break; }
			unsigned int arg2;
			ok &= rb_value_to_uint(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::TurnOffTiles* ret = cocos2d::TurnOffTiles::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TurnOffTiles>((cocos2d::TurnOffTiles*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 2) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Size arg1;
			ok &= rb_value_to_ccsize(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::TurnOffTiles* ret = cocos2d::TurnOffTiles::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TurnOffTiles>((cocos2d::TurnOffTiles*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_TurnOffTiles_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_TurnOffTiles() {
		
	RBVAL classValue=rb_define_class_bridge("TurnOffTiles",rb_get_class_value("cocos2d::TiledGrid3DAction"),true);

	rb_define_method_bridge(classValue,"turnOnTile",RB_FUNC(rb_cocos2dx_TurnOffTiles_turnOnTile));

	

	rb_define_method_bridge(classValue,"turnOffTile",RB_FUNC(rb_cocos2dx_TurnOffTiles_turnOffTile));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TurnOffTiles_create));

	


	TypeTest<cocos2d::TurnOffTiles> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TurnOffTiles",classValue);
}
RBVAL rb_cocos2dx_WavesTiles3D_getAmplitudeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::WavesTiles3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_WavesTiles3D_getAmplitudeRate : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAmplitudeRate();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_WavesTiles3D_getAmplitudeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_WavesTiles3D_setAmplitude(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::WavesTiles3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_WavesTiles3D_setAmplitude : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_WavesTiles3D_setAmplitude : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAmplitude(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("amplitude");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_WavesTiles3D_setAmplitude : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_WavesTiles3D_setAmplitudeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::WavesTiles3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_WavesTiles3D_setAmplitudeRate : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_WavesTiles3D_setAmplitudeRate : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAmplitudeRate(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("amplitudeRate");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_WavesTiles3D_setAmplitudeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_WavesTiles3D_getAmplitude(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::WavesTiles3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_WavesTiles3D_getAmplitude : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAmplitude();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_WavesTiles3D_getAmplitude : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_WavesTiles3D_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 4) {
		float arg0;
		cocos2d::Size arg1;
		unsigned int arg2;
		float arg3;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
		ok &= rb_value_to_uint(argv[2], &arg2);
		ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_WavesTiles3D_create : Error processing arguments");return RBNil();}
		cocos2d::WavesTiles3D* ret = cocos2d::WavesTiles3D::create(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::WavesTiles3D>((cocos2d::WavesTiles3D*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_WavesTiles3D_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_WavesTiles3D() {
		
	RBVAL classValue=rb_define_class_bridge("WavesTiles3D",rb_get_class_value("cocos2d::TiledGrid3DAction"),true);

	rb_define_method_bridge(classValue,"getAmplitudeRate",RB_FUNC(rb_cocos2dx_WavesTiles3D_getAmplitudeRate));

   rb_define_method_bridge(classValue,"amplitudeRate",RB_FUNC(rb_cocos2dx_WavesTiles3D_getAmplitudeRate));
	

	rb_define_method_bridge(classValue,"setAmplitude",RB_FUNC(rb_cocos2dx_WavesTiles3D_setAmplitude));

    rb_define_method_bridge(classValue,"amplitude=",RB_FUNC(rb_cocos2dx_WavesTiles3D_setAmplitude));
	

	rb_define_method_bridge(classValue,"setAmplitudeRate",RB_FUNC(rb_cocos2dx_WavesTiles3D_setAmplitudeRate));

    rb_define_method_bridge(classValue,"amplitudeRate=",RB_FUNC(rb_cocos2dx_WavesTiles3D_setAmplitudeRate));
	

	rb_define_method_bridge(classValue,"getAmplitude",RB_FUNC(rb_cocos2dx_WavesTiles3D_getAmplitude));

   rb_define_method_bridge(classValue,"amplitude",RB_FUNC(rb_cocos2dx_WavesTiles3D_getAmplitude));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_WavesTiles3D_create));

	


	TypeTest<cocos2d::WavesTiles3D> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::WavesTiles3D",classValue);
}
RBVAL rb_cocos2dx_JumpTiles3D_getAmplitudeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::JumpTiles3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_JumpTiles3D_getAmplitudeRate : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAmplitudeRate();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_JumpTiles3D_getAmplitudeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_JumpTiles3D_setAmplitude(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::JumpTiles3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_JumpTiles3D_setAmplitude : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_JumpTiles3D_setAmplitude : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAmplitude(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("amplitude");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_JumpTiles3D_setAmplitude : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_JumpTiles3D_setAmplitudeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::JumpTiles3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_JumpTiles3D_setAmplitudeRate : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_JumpTiles3D_setAmplitudeRate : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAmplitudeRate(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("amplitudeRate");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_JumpTiles3D_setAmplitudeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_JumpTiles3D_getAmplitude(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::JumpTiles3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_JumpTiles3D_getAmplitude : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAmplitude();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_JumpTiles3D_getAmplitude : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_JumpTiles3D_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 4) {
		float arg0;
		cocos2d::Size arg1;
		unsigned int arg2;
		float arg3;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_ccsize(argv[1], &arg1);
		ok &= rb_value_to_uint(argv[2], &arg2);
		ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_JumpTiles3D_create : Error processing arguments");return RBNil();}
		cocos2d::JumpTiles3D* ret = cocos2d::JumpTiles3D::create(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::JumpTiles3D>((cocos2d::JumpTiles3D*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_JumpTiles3D_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_JumpTiles3D() {
		
	RBVAL classValue=rb_define_class_bridge("JumpTiles3D",rb_get_class_value("cocos2d::TiledGrid3DAction"),true);

	rb_define_method_bridge(classValue,"getAmplitudeRate",RB_FUNC(rb_cocos2dx_JumpTiles3D_getAmplitudeRate));

   rb_define_method_bridge(classValue,"amplitudeRate",RB_FUNC(rb_cocos2dx_JumpTiles3D_getAmplitudeRate));
	

	rb_define_method_bridge(classValue,"setAmplitude",RB_FUNC(rb_cocos2dx_JumpTiles3D_setAmplitude));

    rb_define_method_bridge(classValue,"amplitude=",RB_FUNC(rb_cocos2dx_JumpTiles3D_setAmplitude));
	

	rb_define_method_bridge(classValue,"setAmplitudeRate",RB_FUNC(rb_cocos2dx_JumpTiles3D_setAmplitudeRate));

    rb_define_method_bridge(classValue,"amplitudeRate=",RB_FUNC(rb_cocos2dx_JumpTiles3D_setAmplitudeRate));
	

	rb_define_method_bridge(classValue,"getAmplitude",RB_FUNC(rb_cocos2dx_JumpTiles3D_getAmplitude));

   rb_define_method_bridge(classValue,"amplitude",RB_FUNC(rb_cocos2dx_JumpTiles3D_getAmplitude));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_JumpTiles3D_create));

	


	TypeTest<cocos2d::JumpTiles3D> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::JumpTiles3D",classValue);
}
RBVAL rb_cocos2dx_SplitRows_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		unsigned int arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_uint(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SplitRows_create : Error processing arguments");return RBNil();}
		cocos2d::SplitRows* ret = cocos2d::SplitRows::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::SplitRows>((cocos2d::SplitRows*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_SplitRows_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_SplitRows() {
		
	RBVAL classValue=rb_define_class_bridge("SplitRows",rb_get_class_value("cocos2d::TiledGrid3DAction"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_SplitRows_create));

	


	TypeTest<cocos2d::SplitRows> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::SplitRows",classValue);
}
RBVAL rb_cocos2dx_SplitCols_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		unsigned int arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_uint(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SplitCols_create : Error processing arguments");return RBNil();}
		cocos2d::SplitCols* ret = cocos2d::SplitCols::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::SplitCols>((cocos2d::SplitCols*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_SplitCols_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_SplitCols() {
		
	RBVAL classValue=rb_define_class_bridge("SplitCols",rb_get_class_value("cocos2d::TiledGrid3DAction"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_SplitCols_create));

	


	TypeTest<cocos2d::SplitCols> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::SplitCols",classValue);
}
RBVAL rb_cocos2dx_ActionTween_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 4) {
		float arg0;
		std::string arg1;
		float arg2;
		float arg3;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_std_string(argv[1], &arg1);
		ok &= rb_value_to_float(argv[2], &arg2);
		ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ActionTween_create : Error processing arguments");return RBNil();}
		cocos2d::ActionTween* ret = cocos2d::ActionTween::create(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ActionTween>((cocos2d::ActionTween*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ActionTween_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ActionTween() {
		
	RBVAL classValue=rb_define_class_bridge("ActionTween",rb_get_class_value("cocos2d::ActionInterval"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ActionTween_create));

	


	TypeTest<cocos2d::ActionTween> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ActionTween",classValue);
}
RBVAL rb_cocos2dx_CardinalSplineTo_getPoints(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::CardinalSplineTo* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_CardinalSplineTo_getPoints : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::PointArray* ret = cobj->getPoints();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::PointArray>((cocos2d::PointArray*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_CardinalSplineTo_getPoints : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_CardinalSplineTo_updatePosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::CardinalSplineTo* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_CardinalSplineTo_updatePosition : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_CardinalSplineTo_updatePosition : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->updatePosition(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_CardinalSplineTo_updatePosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_CardinalSplineTo_initWithDuration(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::CardinalSplineTo* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_CardinalSplineTo_initWithDuration : self ptr is null");return RBNil();}
		if (argc == 3) {
			float arg0;
			cocos2d::PointArray* arg1;
			float arg2;
			ok &= rb_value_to_float(argv[0], &arg0);
			ok &= rb_value_get_ptr(argv[1],&arg1);
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_CardinalSplineTo_initWithDuration : Error processing argument 3 ( 3 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->initWithDuration(arg0, arg1, arg2);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_CardinalSplineTo_initWithDuration : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_CardinalSplineTo_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::CardinalSplineTo> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::CardinalSplineTo* cobj = new cocos2d::CardinalSplineTo();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_CardinalSplineTo_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_CardinalSplineTo() {
		
	RBVAL classValue=rb_define_class_bridge("CardinalSplineTo",rb_get_class_value("cocos2d::ActionInterval"),true);

	rb_define_method_bridge(classValue,"getPoints",RB_FUNC(rb_cocos2dx_CardinalSplineTo_getPoints));

   rb_define_method_bridge(classValue,"points",RB_FUNC(rb_cocos2dx_CardinalSplineTo_getPoints));
	

	rb_define_method_bridge(classValue,"updatePosition",RB_FUNC(rb_cocos2dx_CardinalSplineTo_updatePosition));

	

	rb_define_method_bridge(classValue,"initWithDuration",RB_FUNC(rb_cocos2dx_CardinalSplineTo_initWithDuration));

	


	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_CardinalSplineTo_constructor));

	TypeTest<cocos2d::CardinalSplineTo> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::CardinalSplineTo",classValue);
}
RBVAL rb_cocos2dx_CardinalSplineBy_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::CardinalSplineBy> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::CardinalSplineBy* cobj = new cocos2d::CardinalSplineBy();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_CardinalSplineBy_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_CardinalSplineBy() {
		
	RBVAL classValue=rb_define_class_bridge("CardinalSplineBy",rb_get_class_value("cocos2d::CardinalSplineTo"),true);


	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_CardinalSplineBy_constructor));

	TypeTest<cocos2d::CardinalSplineBy> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::CardinalSplineBy",classValue);
}
RBVAL rb_cocos2dx_CatmullRomTo_initWithDuration(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::CatmullRomTo* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_CatmullRomTo_initWithDuration : self ptr is null");return RBNil();}
		if (argc == 2) {
			float arg0;
			cocos2d::PointArray* arg1;
			ok &= rb_value_to_float(argv[0], &arg0);
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_CatmullRomTo_initWithDuration : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->initWithDuration(arg0, arg1);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_CatmullRomTo_initWithDuration : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_CatmullRomTo() {
		
	RBVAL classValue=rb_define_class_bridge("CatmullRomTo",rb_get_class_value("cocos2d::CardinalSplineTo"),true);

	rb_define_method_bridge(classValue,"initWithDuration",RB_FUNC(rb_cocos2dx_CatmullRomTo_initWithDuration));

	



	TypeTest<cocos2d::CatmullRomTo> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::CatmullRomTo",classValue);
}
RBVAL rb_cocos2dx_CatmullRomBy_initWithDuration(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::CatmullRomBy* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_CatmullRomBy_initWithDuration : self ptr is null");return RBNil();}
		if (argc == 2) {
			float arg0;
			cocos2d::PointArray* arg1;
			ok &= rb_value_to_float(argv[0], &arg0);
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_CatmullRomBy_initWithDuration : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->initWithDuration(arg0, arg1);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_CatmullRomBy_initWithDuration : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_CatmullRomBy() {
		
	RBVAL classValue=rb_define_class_bridge("CatmullRomBy",rb_get_class_value("cocos2d::CardinalSplineBy"),true);

	rb_define_method_bridge(classValue,"initWithDuration",RB_FUNC(rb_cocos2dx_CatmullRomBy_initWithDuration));

	



	TypeTest<cocos2d::CatmullRomBy> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::CatmullRomBy",classValue);
}
RBVAL rb_cocos2dx_ProtectedNode_addProtectedChild(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::ProtectedNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_addProtectedChild : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_addProtectedChild : Error processing argument 1 ( 2 )");return RBNil(); }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_addProtectedChild : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->addProtectedChild(arg0, arg1);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_addProtectedChild : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->addProtectedChild(arg0);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 3) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_addProtectedChild : Error processing argument 1 ( 3 )");return RBNil(); }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_addProtectedChild : Error processing argument 2 ( 3 )");return RBNil(); }
			int arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_addProtectedChild : Error processing argument 3 ( 3 )");return RBNil(); }
			cobj->addProtectedChild(arg0, arg1, arg2);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_ProtectedNode_addProtectedChild : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProtectedNode_disableCascadeColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProtectedNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_disableCascadeColor : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->disableCascadeColor();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProtectedNode_disableCascadeColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProtectedNode_removeProtectedChildByTag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProtectedNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_removeProtectedChildByTag : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_removeProtectedChildByTag : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeProtectedChildByTag(arg0);
		return value;
		}
		if (argc == 2) {
			int arg0;
			bool arg1;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_removeProtectedChildByTag : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeProtectedChildByTag(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProtectedNode_removeProtectedChildByTag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProtectedNode_reorderProtectedChild(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProtectedNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_reorderProtectedChild : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::Node* arg0;
			int arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_reorderProtectedChild : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->reorderProtectedChild(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProtectedNode_reorderProtectedChild : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProtectedNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeAllProtectedChildrenWithCleanup(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProtectedNode_disableCascadeOpacity(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProtectedNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_disableCascadeOpacity : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->disableCascadeOpacity();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProtectedNode_disableCascadeOpacity : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProtectedNode_sortAllProtectedChildren(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProtectedNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_sortAllProtectedChildren : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->sortAllProtectedChildren();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProtectedNode_sortAllProtectedChildren : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProtectedNode_getProtectedChildByTag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProtectedNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_getProtectedChildByTag : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_getProtectedChildByTag : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Node* ret = cobj->getProtectedChildByTag(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProtectedNode_getProtectedChildByTag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProtectedNode_removeProtectedChild(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProtectedNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_removeProtectedChild : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_removeProtectedChild : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeProtectedChild(arg0);
		return value;
		}
		if (argc == 2) {
			cocos2d::Node* arg0;
			bool arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_removeProtectedChild : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeProtectedChild(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProtectedNode_removeProtectedChild : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProtectedNode_removeAllProtectedChildren(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProtectedNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProtectedNode_removeAllProtectedChildren : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->removeAllProtectedChildren();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProtectedNode_removeAllProtectedChildren : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProtectedNode_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::ProtectedNode* ret = cocos2d::ProtectedNode::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ProtectedNode>((cocos2d::ProtectedNode*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ProtectedNode_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ProtectedNode() {
		
	RBVAL classValue=rb_define_class_bridge("ProtectedNode",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"addProtectedChild",RB_FUNC(rb_cocos2dx_ProtectedNode_addProtectedChild));

	

	rb_define_method_bridge(classValue,"disableCascadeColor",RB_FUNC(rb_cocos2dx_ProtectedNode_disableCascadeColor));

	

	rb_define_method_bridge(classValue,"removeProtectedChildByTag",RB_FUNC(rb_cocos2dx_ProtectedNode_removeProtectedChildByTag));

	

	rb_define_method_bridge(classValue,"reorderProtectedChild",RB_FUNC(rb_cocos2dx_ProtectedNode_reorderProtectedChild));

	

	rb_define_method_bridge(classValue,"removeAllProtectedChildrenWithCleanup",RB_FUNC(rb_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup));

	

	rb_define_method_bridge(classValue,"disableCascadeOpacity",RB_FUNC(rb_cocos2dx_ProtectedNode_disableCascadeOpacity));

	

	rb_define_method_bridge(classValue,"sortAllProtectedChildren",RB_FUNC(rb_cocos2dx_ProtectedNode_sortAllProtectedChildren));

	

	rb_define_method_bridge(classValue,"getProtectedChildByTag",RB_FUNC(rb_cocos2dx_ProtectedNode_getProtectedChildByTag));

   rb_define_method_bridge(classValue,"protectedChildByTag",RB_FUNC(rb_cocos2dx_ProtectedNode_getProtectedChildByTag));
	

	rb_define_method_bridge(classValue,"removeProtectedChild",RB_FUNC(rb_cocos2dx_ProtectedNode_removeProtectedChild));

	

	rb_define_method_bridge(classValue,"removeAllProtectedChildren",RB_FUNC(rb_cocos2dx_ProtectedNode_removeAllProtectedChildren));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ProtectedNode_create));

	


	TypeTest<cocos2d::ProtectedNode> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ProtectedNode",classValue);
}
RBVAL rb_cocos2dx_GLProgramState_setUniformTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::GLProgramState* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformTexture : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformTexture : Error processing argument 1 ( 2 )");return RBNil(); }
			unsigned int arg1;
			ok &= rb_value_to_uint(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformTexture : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setUniformTexture(arg0, arg1);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 2) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformTexture : Error processing argument 1 ( 2 )");return RBNil(); }
			cocos2d::Texture2D* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformTexture : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setUniformTexture(arg0, arg1);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 2) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformTexture : Error processing argument 1 ( 2 )");return RBNil(); }
			cocos2d::Texture2D* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformTexture : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setUniformTexture(arg0, arg1);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 2) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformTexture : Error processing argument 1 ( 2 )");return RBNil(); }
			unsigned int arg1;
			ok &= rb_value_to_uint(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformTexture : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setUniformTexture(arg0, arg1);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramState_setUniformMat4(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::GLProgramState* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformMat4 : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformMat4 : Error processing argument 1 ( 2 )");return RBNil(); }
			cocos2d::Mat4 arg1;
			ok &= rb_value_to_mat4(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformMat4 : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setUniformMat4(arg0, arg1);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 2) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformMat4 : Error processing argument 1 ( 2 )");return RBNil(); }
			cocos2d::Mat4 arg1;
			ok &= rb_value_to_mat4(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformMat4 : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setUniformMat4(arg0, arg1);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformMat4 : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramState_applyUniforms(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgramState* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_applyUniforms : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->applyUniforms();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgramState_applyUniforms : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramState_applyGLProgram(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgramState* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_applyGLProgram : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Mat4 arg0;
			ok &= rb_value_to_mat4(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_applyGLProgram : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->applyGLProgram(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgramState_applyGLProgram : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramState_getUniformCount(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgramState* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_getUniformCount : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					ssize_t ret = cobj->getUniformCount();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgramState_getUniformCount : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramState_applyAttributes(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgramState* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_applyAttributes : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->applyAttributes();
		return value;
		}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_applyAttributes : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->applyAttributes(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgramState_applyAttributes : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramState_setUniformFloat(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::GLProgramState* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformFloat : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformFloat : Error processing argument 1 ( 2 )");return RBNil(); }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformFloat : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setUniformFloat(arg0, arg1);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 2) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformFloat : Error processing argument 1 ( 2 )");return RBNil(); }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformFloat : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setUniformFloat(arg0, arg1);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformFloat : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramState_setUniformVec3(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::GLProgramState* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec3 : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec3 : Error processing argument 1 ( 2 )");return RBNil(); }
			cocos2d::Vec3 arg1;
			ok &= rb_value_to_vec3(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec3 : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setUniformVec3(arg0, arg1);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 2) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec3 : Error processing argument 1 ( 2 )");return RBNil(); }
			cocos2d::Vec3 arg1;
			ok &= rb_value_to_vec3(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec3 : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setUniformVec3(arg0, arg1);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec3 : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramState_setUniformInt(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::GLProgramState* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformInt : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformInt : Error processing argument 1 ( 2 )");return RBNil(); }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformInt : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setUniformInt(arg0, arg1);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 2) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformInt : Error processing argument 1 ( 2 )");return RBNil(); }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformInt : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setUniformInt(arg0, arg1);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformInt : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramState_getVertexAttribCount(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgramState* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_getVertexAttribCount : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					ssize_t ret = cobj->getVertexAttribCount();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgramState_getVertexAttribCount : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramState_setUniformVec4(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::GLProgramState* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec4 : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec4 : Error processing argument 1 ( 2 )");return RBNil(); }
			cocos2d::Vec4 arg1;
			ok &= rb_value_to_vec4(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec4 : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setUniformVec4(arg0, arg1);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 2) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec4 : Error processing argument 1 ( 2 )");return RBNil(); }
			cocos2d::Vec4 arg1;
			ok &= rb_value_to_vec4(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec4 : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setUniformVec4(arg0, arg1);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec4 : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramState_setGLProgram(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgramState* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setGLProgram : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::GLProgram* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setGLProgram : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setGLProgram(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("gLProgram");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgramState_setGLProgram : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramState_setUniformVec2(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::GLProgramState* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec2 : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec2 : Error processing argument 1 ( 2 )");return RBNil(); }
			cocos2d::Vec2 arg1;
			ok &= rb_value_to_vec2(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec2 : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setUniformVec2(arg0, arg1);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 2) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec2 : Error processing argument 1 ( 2 )");return RBNil(); }
			cocos2d::Vec2 arg1;
			ok &= rb_value_to_vec2(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec2 : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setUniformVec2(arg0, arg1);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_GLProgramState_setUniformVec2 : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramState_getVertexAttribsFlags(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgramState* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_getVertexAttribsFlags : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					unsigned int ret = cobj->getVertexAttribsFlags();
				value = uint_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgramState_getVertexAttribsFlags : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramState_apply(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgramState* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_apply : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Mat4 arg0;
			ok &= rb_value_to_mat4(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_apply : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->apply(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgramState_apply : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramState_getGLProgram(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgramState* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_getGLProgram : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::GLProgram* ret = cobj->getGLProgram();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::GLProgram>((cocos2d::GLProgram*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgramState_getGLProgram : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramState_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::GLProgram* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_create : Error processing arguments");return RBNil();}
		cocos2d::GLProgramState* ret = cocos2d::GLProgramState::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::GLProgramState>((cocos2d::GLProgramState*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_GLProgramState_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_GLProgramState_getOrCreateWithGLProgramName(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		std::string arg0;
		ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_getOrCreateWithGLProgramName : Error processing arguments");return RBNil();}
		cocos2d::GLProgramState* ret = cocos2d::GLProgramState::getOrCreateWithGLProgramName(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::GLProgramState>((cocos2d::GLProgramState*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_GLProgramState_getOrCreateWithGLProgramName : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_GLProgramState_getOrCreateWithGLProgram(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::GLProgram* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramState_getOrCreateWithGLProgram : Error processing arguments");return RBNil();}
		cocos2d::GLProgramState* ret = cocos2d::GLProgramState::getOrCreateWithGLProgram(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::GLProgramState>((cocos2d::GLProgramState*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_GLProgramState_getOrCreateWithGLProgram : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_GLProgramState() {
		
	RBVAL classValue=rb_define_class_bridge("GLProgramState",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"setUniformTexture",RB_FUNC(rb_cocos2dx_GLProgramState_setUniformTexture));

    rb_define_method_bridge(classValue,"uniformTexture=",RB_FUNC(rb_cocos2dx_GLProgramState_setUniformTexture));
	

	rb_define_method_bridge(classValue,"setUniformMat4",RB_FUNC(rb_cocos2dx_GLProgramState_setUniformMat4));

    rb_define_method_bridge(classValue,"uniformMat4=",RB_FUNC(rb_cocos2dx_GLProgramState_setUniformMat4));
	

	rb_define_method_bridge(classValue,"applyUniforms",RB_FUNC(rb_cocos2dx_GLProgramState_applyUniforms));

	

	rb_define_method_bridge(classValue,"applyGLProgram",RB_FUNC(rb_cocos2dx_GLProgramState_applyGLProgram));

	

	rb_define_method_bridge(classValue,"getUniformCount",RB_FUNC(rb_cocos2dx_GLProgramState_getUniformCount));

   rb_define_method_bridge(classValue,"uniformCount",RB_FUNC(rb_cocos2dx_GLProgramState_getUniformCount));
	

	rb_define_method_bridge(classValue,"applyAttributes",RB_FUNC(rb_cocos2dx_GLProgramState_applyAttributes));

	

	rb_define_method_bridge(classValue,"setUniformFloat",RB_FUNC(rb_cocos2dx_GLProgramState_setUniformFloat));

    rb_define_method_bridge(classValue,"uniformFloat=",RB_FUNC(rb_cocos2dx_GLProgramState_setUniformFloat));
	

	rb_define_method_bridge(classValue,"setUniformVec3",RB_FUNC(rb_cocos2dx_GLProgramState_setUniformVec3));

    rb_define_method_bridge(classValue,"uniformVec3=",RB_FUNC(rb_cocos2dx_GLProgramState_setUniformVec3));
	

	rb_define_method_bridge(classValue,"setUniformInt",RB_FUNC(rb_cocos2dx_GLProgramState_setUniformInt));

    rb_define_method_bridge(classValue,"uniformInt=",RB_FUNC(rb_cocos2dx_GLProgramState_setUniformInt));
	

	rb_define_method_bridge(classValue,"getVertexAttribCount",RB_FUNC(rb_cocos2dx_GLProgramState_getVertexAttribCount));

   rb_define_method_bridge(classValue,"vertexAttribCount",RB_FUNC(rb_cocos2dx_GLProgramState_getVertexAttribCount));
	

	rb_define_method_bridge(classValue,"setUniformVec4",RB_FUNC(rb_cocos2dx_GLProgramState_setUniformVec4));

    rb_define_method_bridge(classValue,"uniformVec4=",RB_FUNC(rb_cocos2dx_GLProgramState_setUniformVec4));
	

	rb_define_method_bridge(classValue,"setGLProgram",RB_FUNC(rb_cocos2dx_GLProgramState_setGLProgram));

    rb_define_method_bridge(classValue,"gLProgram=",RB_FUNC(rb_cocos2dx_GLProgramState_setGLProgram));
	

	rb_define_method_bridge(classValue,"setUniformVec2",RB_FUNC(rb_cocos2dx_GLProgramState_setUniformVec2));

    rb_define_method_bridge(classValue,"uniformVec2=",RB_FUNC(rb_cocos2dx_GLProgramState_setUniformVec2));
	

	rb_define_method_bridge(classValue,"getVertexAttribsFlags",RB_FUNC(rb_cocos2dx_GLProgramState_getVertexAttribsFlags));

   rb_define_method_bridge(classValue,"vertexAttribsFlags",RB_FUNC(rb_cocos2dx_GLProgramState_getVertexAttribsFlags));
	

	rb_define_method_bridge(classValue,"apply",RB_FUNC(rb_cocos2dx_GLProgramState_apply));

	

	rb_define_method_bridge(classValue,"getGLProgram",RB_FUNC(rb_cocos2dx_GLProgramState_getGLProgram));

   rb_define_method_bridge(classValue,"gLProgram",RB_FUNC(rb_cocos2dx_GLProgramState_getGLProgram));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_GLProgramState_create));

	
	

	rb_define_singleton_method_bridge(classValue,"getOrCreateWithGLProgramName",RB_FUNC(rb_cocos2dx_GLProgramState_getOrCreateWithGLProgramName));

   rb_define_singleton_method_bridge(classValue,"orCreateWithGLProgramName",RB_FUNC(rb_cocos2dx_GLProgramState_getOrCreateWithGLProgramName));
	
	

	rb_define_singleton_method_bridge(classValue,"getOrCreateWithGLProgram",RB_FUNC(rb_cocos2dx_GLProgramState_getOrCreateWithGLProgram));

   rb_define_singleton_method_bridge(classValue,"orCreateWithGLProgram",RB_FUNC(rb_cocos2dx_GLProgramState_getOrCreateWithGLProgram));
	


	TypeTest<cocos2d::GLProgramState> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::GLProgramState",classValue);
}
RBVAL rb_cocos2dx_AtlasNode_updateAtlasValues(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AtlasNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AtlasNode_updateAtlasValues : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->updateAtlasValues();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AtlasNode_updateAtlasValues : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AtlasNode_getTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AtlasNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AtlasNode_getTexture : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Texture2D* ret = cobj->getTexture();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Texture2D>((cocos2d::Texture2D*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AtlasNode_getTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AtlasNode_setTextureAtlas(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AtlasNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AtlasNode_setTextureAtlas : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::TextureAtlas* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_AtlasNode_setTextureAtlas : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTextureAtlas(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("textureAtlas");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AtlasNode_setTextureAtlas : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AtlasNode_getTextureAtlas(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AtlasNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AtlasNode_getTextureAtlas : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::TextureAtlas* ret = cobj->getTextureAtlas();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::TextureAtlas>((cocos2d::TextureAtlas*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AtlasNode_getTextureAtlas : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AtlasNode_getQuadsToDraw(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AtlasNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AtlasNode_getQuadsToDraw : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					ssize_t ret = cobj->getQuadsToDraw();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AtlasNode_getQuadsToDraw : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AtlasNode_setTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AtlasNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AtlasNode_setTexture : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Texture2D* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_AtlasNode_setTexture : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTexture(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("texture");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AtlasNode_setTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AtlasNode_setQuadsToDraw(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AtlasNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AtlasNode_setQuadsToDraw : self ptr is null");return RBNil();}
		if (argc == 1) {
			ssize_t arg0;
			ok &= rb_value_to_ssize_t(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_AtlasNode_setQuadsToDraw : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setQuadsToDraw(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("quadsToDraw");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AtlasNode_setQuadsToDraw : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AtlasNode_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 4) {
		std::string arg0;
		int arg1;
		int arg2;
		int arg3;
		ok &= rb_value_to_std_string(argv[0], &arg0);
		ok &= rb_value_to_int(argv[1], (int *)&arg1);
		ok &= rb_value_to_int(argv[2], (int *)&arg2);
		ok &= rb_value_to_int(argv[3], (int *)&arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_AtlasNode_create : Error processing arguments");return RBNil();}
		cocos2d::AtlasNode* ret = cocos2d::AtlasNode::create(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::AtlasNode>((cocos2d::AtlasNode*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_AtlasNode_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_AtlasNode() {
		
	RBVAL classValue=rb_define_class_bridge("AtlasNode",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"updateAtlasValues",RB_FUNC(rb_cocos2dx_AtlasNode_updateAtlasValues));

	

	rb_define_method_bridge(classValue,"getTexture",RB_FUNC(rb_cocos2dx_AtlasNode_getTexture));

   rb_define_method_bridge(classValue,"texture",RB_FUNC(rb_cocos2dx_AtlasNode_getTexture));
	

	rb_define_method_bridge(classValue,"setTextureAtlas",RB_FUNC(rb_cocos2dx_AtlasNode_setTextureAtlas));

    rb_define_method_bridge(classValue,"textureAtlas=",RB_FUNC(rb_cocos2dx_AtlasNode_setTextureAtlas));
	

	rb_define_method_bridge(classValue,"getTextureAtlas",RB_FUNC(rb_cocos2dx_AtlasNode_getTextureAtlas));

   rb_define_method_bridge(classValue,"textureAtlas",RB_FUNC(rb_cocos2dx_AtlasNode_getTextureAtlas));
	

	rb_define_method_bridge(classValue,"getQuadsToDraw",RB_FUNC(rb_cocos2dx_AtlasNode_getQuadsToDraw));

   rb_define_method_bridge(classValue,"quadsToDraw",RB_FUNC(rb_cocos2dx_AtlasNode_getQuadsToDraw));
	

	rb_define_method_bridge(classValue,"setTexture",RB_FUNC(rb_cocos2dx_AtlasNode_setTexture));

    rb_define_method_bridge(classValue,"texture=",RB_FUNC(rb_cocos2dx_AtlasNode_setTexture));
	

	rb_define_method_bridge(classValue,"setQuadsToDraw",RB_FUNC(rb_cocos2dx_AtlasNode_setQuadsToDraw));

    rb_define_method_bridge(classValue,"quadsToDraw=",RB_FUNC(rb_cocos2dx_AtlasNode_setQuadsToDraw));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_AtlasNode_create));

	


	TypeTest<cocos2d::AtlasNode> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::AtlasNode",classValue);
}
RBVAL rb_cocos2dx_DrawNode_drawLine(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::DrawNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawLine : self ptr is null");return RBNil();}
		if (argc == 3) {
			cocos2d::Vec2 arg0;
			cocos2d::Vec2 arg1;
			cocos2d::Color4F arg2;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			ok &= rb_value_to_vec2(argv[1], &arg1);
			ok &= rb_value_to_cccolor4f(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawLine : Error processing argument 3 ( 3 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->drawLine(arg0, arg1, arg2);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_DrawNode_drawLine : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DrawNode_drawRect(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::DrawNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawRect : self ptr is null");return RBNil();}
	do {
		if (argc == 5) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawRect : Error processing argument 1 ( 5 )");return RBNil(); }
			cocos2d::Vec2 arg1;
			ok &= rb_value_to_vec2(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawRect : Error processing argument 2 ( 5 )");return RBNil(); }
			cocos2d::Vec2 arg2;
			ok &= rb_value_to_vec2(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawRect : Error processing argument 3 ( 5 )");return RBNil(); }
			cocos2d::Vec2 arg3;
			ok &= rb_value_to_vec2(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawRect : Error processing argument 4 ( 5 )");return RBNil(); }
			cocos2d::Color4F arg4;
			ok &= rb_value_to_cccolor4f(argv[4], &arg4);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawRect : Error processing argument 5 ( 5 )");return RBNil(); }
			cobj->drawRect(arg0, arg1, arg2, arg3, arg4);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 3) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawRect : Error processing argument 1 ( 3 )");return RBNil(); }
			cocos2d::Vec2 arg1;
			ok &= rb_value_to_vec2(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawRect : Error processing argument 2 ( 3 )");return RBNil(); }
			cocos2d::Color4F arg2;
			ok &= rb_value_to_cccolor4f(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawRect : Error processing argument 3 ( 3 )");return RBNil(); }
			cobj->drawRect(arg0, arg1, arg2);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_DrawNode_drawRect : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DrawNode_drawSolidCircle(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::DrawNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidCircle : self ptr is null");return RBNil();}
	do {
		if (argc == 5) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidCircle : Error processing argument 1 ( 5 )");return RBNil(); }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidCircle : Error processing argument 2 ( 5 )");return RBNil(); }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidCircle : Error processing argument 3 ( 5 )");return RBNil(); }
			unsigned int arg3;
			ok &= rb_value_to_uint(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidCircle : Error processing argument 4 ( 5 )");return RBNil(); }
			cocos2d::Color4F arg4;
			ok &= rb_value_to_cccolor4f(argv[4], &arg4);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidCircle : Error processing argument 5 ( 5 )");return RBNil(); }
			cobj->drawSolidCircle(arg0, arg1, arg2, arg3, arg4);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 7) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidCircle : Error processing argument 1 ( 7 )");return RBNil(); }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidCircle : Error processing argument 2 ( 7 )");return RBNil(); }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidCircle : Error processing argument 3 ( 7 )");return RBNil(); }
			unsigned int arg3;
			ok &= rb_value_to_uint(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidCircle : Error processing argument 4 ( 7 )");return RBNil(); }
			float arg4;
			ok &= rb_value_to_float(argv[4], &arg4);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidCircle : Error processing argument 5 ( 7 )");return RBNil(); }
			float arg5;
			ok &= rb_value_to_float(argv[5], &arg5);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidCircle : Error processing argument 6 ( 7 )");return RBNil(); }
			cocos2d::Color4F arg6;
			ok &= rb_value_to_cccolor4f(argv[6], &arg6);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidCircle : Error processing argument 7 ( 7 )");return RBNil(); }
			cobj->drawSolidCircle(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidCircle : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DrawNode_onDrawGLPoint(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::DrawNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_onDrawGLPoint : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::Mat4 arg0;
			unsigned int arg1;
			ok &= rb_value_to_mat4(argv[0], &arg0);
			ok &= rb_value_to_uint(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_onDrawGLPoint : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->onDrawGLPoint(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_DrawNode_onDrawGLPoint : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DrawNode_drawDot(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::DrawNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawDot : self ptr is null");return RBNil();}
		if (argc == 3) {
			cocos2d::Vec2 arg0;
			float arg1;
			cocos2d::Color4F arg2;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			ok &= rb_value_to_float(argv[1], &arg1);
			ok &= rb_value_to_cccolor4f(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawDot : Error processing argument 3 ( 3 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->drawDot(arg0, arg1, arg2);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_DrawNode_drawDot : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DrawNode_drawSegment(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::DrawNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSegment : self ptr is null");return RBNil();}
		if (argc == 4) {
			cocos2d::Vec2 arg0;
			cocos2d::Vec2 arg1;
			float arg2;
			cocos2d::Color4F arg3;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			ok &= rb_value_to_vec2(argv[1], &arg1);
			ok &= rb_value_to_float(argv[2], &arg2);
			ok &= rb_value_to_cccolor4f(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSegment : Error processing argument 4 ( 4 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->drawSegment(arg0, arg1, arg2, arg3);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSegment : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DrawNode_onDraw(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::DrawNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_onDraw : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::Mat4 arg0;
			unsigned int arg1;
			ok &= rb_value_to_mat4(argv[0], &arg0);
			ok &= rb_value_to_uint(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_onDraw : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->onDraw(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_DrawNode_onDraw : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DrawNode_drawCircle(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::DrawNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCircle : self ptr is null");return RBNil();}
	do {
		if (argc == 6) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCircle : Error processing argument 1 ( 6 )");return RBNil(); }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCircle : Error processing argument 2 ( 6 )");return RBNil(); }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCircle : Error processing argument 3 ( 6 )");return RBNil(); }
			unsigned int arg3;
			ok &= rb_value_to_uint(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCircle : Error processing argument 4 ( 6 )");return RBNil(); }
			bool arg4;
			ok &= rb_value_to_bool(argv[4], &arg4);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCircle : Error processing argument 5 ( 6 )");return RBNil(); }
			cocos2d::Color4F arg5;
			ok &= rb_value_to_cccolor4f(argv[5], &arg5);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCircle : Error processing argument 6 ( 6 )");return RBNil(); }
			cobj->drawCircle(arg0, arg1, arg2, arg3, arg4, arg5);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 8) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCircle : Error processing argument 1 ( 8 )");return RBNil(); }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCircle : Error processing argument 2 ( 8 )");return RBNil(); }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCircle : Error processing argument 3 ( 8 )");return RBNil(); }
			unsigned int arg3;
			ok &= rb_value_to_uint(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCircle : Error processing argument 4 ( 8 )");return RBNil(); }
			bool arg4;
			ok &= rb_value_to_bool(argv[4], &arg4);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCircle : Error processing argument 5 ( 8 )");return RBNil(); }
			float arg5;
			ok &= rb_value_to_float(argv[5], &arg5);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCircle : Error processing argument 6 ( 8 )");return RBNil(); }
			float arg6;
			ok &= rb_value_to_float(argv[6], &arg6);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCircle : Error processing argument 7 ( 8 )");return RBNil(); }
			cocos2d::Color4F arg7;
			ok &= rb_value_to_cccolor4f(argv[7], &arg7);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCircle : Error processing argument 8 ( 8 )");return RBNil(); }
			cobj->drawCircle(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCircle : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DrawNode_drawQuadBezier(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::DrawNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawQuadBezier : self ptr is null");return RBNil();}
		if (argc == 5) {
			cocos2d::Vec2 arg0;
			cocos2d::Vec2 arg1;
			cocos2d::Vec2 arg2;
			unsigned int arg3;
			cocos2d::Color4F arg4;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			ok &= rb_value_to_vec2(argv[1], &arg1);
			ok &= rb_value_to_vec2(argv[2], &arg2);
			ok &= rb_value_to_uint(argv[3], &arg3);
			ok &= rb_value_to_cccolor4f(argv[4], &arg4);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawQuadBezier : Error processing argument 5 ( 5 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->drawQuadBezier(arg0, arg1, arg2, arg3, arg4);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_DrawNode_drawQuadBezier : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DrawNode_onDrawGLLine(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::DrawNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_onDrawGLLine : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::Mat4 arg0;
			unsigned int arg1;
			ok &= rb_value_to_mat4(argv[0], &arg0);
			ok &= rb_value_to_uint(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_onDrawGLLine : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->onDrawGLLine(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_DrawNode_onDrawGLLine : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DrawNode_drawTriangle(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::DrawNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawTriangle : self ptr is null");return RBNil();}
		if (argc == 4) {
			cocos2d::Vec2 arg0;
			cocos2d::Vec2 arg1;
			cocos2d::Vec2 arg2;
			cocos2d::Color4F arg3;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			ok &= rb_value_to_vec2(argv[1], &arg1);
			ok &= rb_value_to_vec2(argv[2], &arg2);
			ok &= rb_value_to_cccolor4f(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawTriangle : Error processing argument 4 ( 4 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->drawTriangle(arg0, arg1, arg2, arg3);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_DrawNode_drawTriangle : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DrawNode_clear(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::DrawNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_clear : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->clear();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_DrawNode_clear : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DrawNode_drawSolidRect(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::DrawNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidRect : self ptr is null");return RBNil();}
		if (argc == 3) {
			cocos2d::Vec2 arg0;
			cocos2d::Vec2 arg1;
			cocos2d::Color4F arg2;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			ok &= rb_value_to_vec2(argv[1], &arg1);
			ok &= rb_value_to_cccolor4f(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidRect : Error processing argument 3 ( 3 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->drawSolidRect(arg0, arg1, arg2);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_DrawNode_drawSolidRect : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DrawNode_drawPoint(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::DrawNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawPoint : self ptr is null");return RBNil();}
		if (argc == 3) {
			cocos2d::Vec2 arg0;
			float arg1;
			cocos2d::Color4F arg2;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			ok &= rb_value_to_float(argv[1], &arg1);
			ok &= rb_value_to_cccolor4f(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawPoint : Error processing argument 3 ( 3 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->drawPoint(arg0, arg1, arg2);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_DrawNode_drawPoint : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DrawNode_drawCubicBezier(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::DrawNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCubicBezier : self ptr is null");return RBNil();}
		if (argc == 6) {
			cocos2d::Vec2 arg0;
			cocos2d::Vec2 arg1;
			cocos2d::Vec2 arg2;
			cocos2d::Vec2 arg3;
			unsigned int arg4;
			cocos2d::Color4F arg5;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			ok &= rb_value_to_vec2(argv[1], &arg1);
			ok &= rb_value_to_vec2(argv[2], &arg2);
			ok &= rb_value_to_vec2(argv[3], &arg3);
			ok &= rb_value_to_uint(argv[4], &arg4);
			ok &= rb_value_to_cccolor4f(argv[5], &arg5);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCubicBezier : Error processing argument 6 ( 6 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->drawCubicBezier(arg0, arg1, arg2, arg3, arg4, arg5);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_DrawNode_drawCubicBezier : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DrawNode_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::DrawNode* ret = cocos2d::DrawNode::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::DrawNode>((cocos2d::DrawNode*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_DrawNode_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_DrawNode() {
		
	RBVAL classValue=rb_define_class_bridge("DrawNode",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"drawLine",RB_FUNC(rb_cocos2dx_DrawNode_drawLine));

	

	rb_define_method_bridge(classValue,"drawRect",RB_FUNC(rb_cocos2dx_DrawNode_drawRect));

	

	rb_define_method_bridge(classValue,"drawSolidCircle",RB_FUNC(rb_cocos2dx_DrawNode_drawSolidCircle));

	

	rb_define_method_bridge(classValue,"onDrawGLPoint",RB_FUNC(rb_cocos2dx_DrawNode_onDrawGLPoint));

	

	rb_define_method_bridge(classValue,"drawDot",RB_FUNC(rb_cocos2dx_DrawNode_drawDot));

	

	rb_define_method_bridge(classValue,"drawSegment",RB_FUNC(rb_cocos2dx_DrawNode_drawSegment));

	

	rb_define_method_bridge(classValue,"onDraw",RB_FUNC(rb_cocos2dx_DrawNode_onDraw));

	

	rb_define_method_bridge(classValue,"drawCircle",RB_FUNC(rb_cocos2dx_DrawNode_drawCircle));

	

	rb_define_method_bridge(classValue,"drawQuadBezier",RB_FUNC(rb_cocos2dx_DrawNode_drawQuadBezier));

	

	rb_define_method_bridge(classValue,"onDrawGLLine",RB_FUNC(rb_cocos2dx_DrawNode_onDrawGLLine));

	

	rb_define_method_bridge(classValue,"drawTriangle",RB_FUNC(rb_cocos2dx_DrawNode_drawTriangle));

	

	rb_define_method_bridge(classValue,"clear",RB_FUNC(rb_cocos2dx_DrawNode_clear));

	

	rb_define_method_bridge(classValue,"drawSolidRect",RB_FUNC(rb_cocos2dx_DrawNode_drawSolidRect));

	

	rb_define_method_bridge(classValue,"drawPoint",RB_FUNC(rb_cocos2dx_DrawNode_drawPoint));

	

	rb_define_method_bridge(classValue,"drawCubicBezier",RB_FUNC(rb_cocos2dx_DrawNode_drawCubicBezier));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_DrawNode_create));

	


	TypeTest<cocos2d::DrawNode> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::DrawNode",classValue);
}
RBVAL rb_cocos2dx_LabelAtlas_setString(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LabelAtlas* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_setString : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_setString : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setString(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("string");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LabelAtlas_setString : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LabelAtlas_initWithString(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::LabelAtlas* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_initWithString : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_initWithString : Error processing argument 1 ( 2 )");return RBNil(); }
			std::string arg1;
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_initWithString : Error processing argument 2 ( 2 )");return RBNil(); }
			bool ret = cobj->initWithString(arg0, arg1);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 5) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_initWithString : Error processing argument 1 ( 5 )");return RBNil(); }
			std::string arg1;
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_initWithString : Error processing argument 2 ( 5 )");return RBNil(); }
			int arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_initWithString : Error processing argument 3 ( 5 )");return RBNil(); }
			int arg3;
			ok &= rb_value_to_int(argv[3], (int *)&arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_initWithString : Error processing argument 4 ( 5 )");return RBNil(); }
			int arg4;
			ok &= rb_value_to_int(argv[4], (int *)&arg4);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_initWithString : Error processing argument 5 ( 5 )");return RBNil(); }
			bool ret = cobj->initWithString(arg0, arg1, arg2, arg3, arg4);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 5) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_initWithString : Error processing argument 1 ( 5 )");return RBNil(); }
			cocos2d::Texture2D* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_initWithString : Error processing argument 2 ( 5 )");return RBNil(); }
			int arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_initWithString : Error processing argument 3 ( 5 )");return RBNil(); }
			int arg3;
			ok &= rb_value_to_int(argv[3], (int *)&arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_initWithString : Error processing argument 4 ( 5 )");return RBNil(); }
			int arg4;
			ok &= rb_value_to_int(argv[4], (int *)&arg4);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_initWithString : Error processing argument 5 ( 5 )");return RBNil(); }
			bool ret = cobj->initWithString(arg0, arg1, arg2, arg3, arg4);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_LabelAtlas_initWithString : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LabelAtlas_updateAtlasValues(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LabelAtlas* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_updateAtlasValues : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->updateAtlasValues();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LabelAtlas_updateAtlasValues : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LabelAtlas_getString(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LabelAtlas* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LabelAtlas_getString : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const std::string& ret = cobj->getString();
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LabelAtlas_getString : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LabelAtlas_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 5) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) { break; }
			std::string arg1;
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) { break; }
			int arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) { break; }
			int arg3;
			ok &= rb_value_to_int(argv[3], (int *)&arg3);
			if (!ok) { break; }
			int arg4;
			ok &= rb_value_to_int(argv[4], (int *)&arg4);
			if (!ok) { break; }
			cocos2d::LabelAtlas* ret = cocos2d::LabelAtlas::create(arg0, arg1, arg2, arg3, arg4);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::LabelAtlas>((cocos2d::LabelAtlas*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 0) {
			cocos2d::LabelAtlas* ret = cocos2d::LabelAtlas::create();
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::LabelAtlas>((cocos2d::LabelAtlas*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 2) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) { break; }
			std::string arg1;
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::LabelAtlas* ret = cocos2d::LabelAtlas::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::LabelAtlas>((cocos2d::LabelAtlas*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_LabelAtlas_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_LabelAtlas() {
		
	RBVAL classValue=rb_define_class_bridge("LabelAtlas",rb_get_class_value("cocos2d::AtlasNode"),true);

	rb_define_method_bridge(classValue,"setString",RB_FUNC(rb_cocos2dx_LabelAtlas_setString));

    rb_define_method_bridge(classValue,"string=",RB_FUNC(rb_cocos2dx_LabelAtlas_setString));
	

	rb_define_method_bridge(classValue,"initWithString",RB_FUNC(rb_cocos2dx_LabelAtlas_initWithString));

	

	rb_define_method_bridge(classValue,"updateAtlasValues",RB_FUNC(rb_cocos2dx_LabelAtlas_updateAtlasValues));

	

	rb_define_method_bridge(classValue,"getString",RB_FUNC(rb_cocos2dx_LabelAtlas_getString));

   rb_define_method_bridge(classValue,"string",RB_FUNC(rb_cocos2dx_LabelAtlas_getString));
	

	

	rb_define_singleton_method_bridge(classValue,"_create",RB_FUNC(rb_cocos2dx_LabelAtlas_create));

	


	TypeTest<cocos2d::LabelAtlas> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::LabelAtlas",classValue);
}
RBVAL rb_cocos2dx_SpriteBatchNode_appendChild(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_appendChild : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Sprite* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_appendChild : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->appendChild(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_appendChild : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad : self ptr is null");return RBNil();}
		if (argc == 3) {
			cocos2d::Sprite* arg0;
			int arg1;
			int arg2;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad : Error processing argument 3 ( 3 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::SpriteBatchNode* ret = cobj->addSpriteWithoutQuad(arg0, arg1, arg2);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::SpriteBatchNode>((cocos2d::SpriteBatchNode*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteBatchNode_reorderBatch(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_reorderBatch : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_reorderBatch : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->reorderBatch(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_reorderBatch : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteBatchNode_removeAllChildrenWithCleanup(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_removeAllChildrenWithCleanup : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_removeAllChildrenWithCleanup : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeAllChildrenWithCleanup(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_removeAllChildrenWithCleanup : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Sprite* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					ssize_t ret = cobj->lowestAtlasIndexInChild(arg0);
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteBatchNode_atlasIndexForChild(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_atlasIndexForChild : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::Sprite* arg0;
			int arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_atlasIndexForChild : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
					ssize_t ret = cobj->atlasIndexForChild(arg0, arg1);
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_atlasIndexForChild : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteBatchNode_setTextureAtlas(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_setTextureAtlas : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::TextureAtlas* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_setTextureAtlas : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTextureAtlas(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("textureAtlas");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_setTextureAtlas : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteBatchNode_getTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_getTexture : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Texture2D* ret = cobj->getTexture();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Texture2D>((cocos2d::Texture2D*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_getTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteBatchNode_increaseAtlasCapacity(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_increaseAtlasCapacity : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->increaseAtlasCapacity();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_increaseAtlasCapacity : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteBatchNode_getTextureAtlas(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_getTextureAtlas : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::TextureAtlas* ret = cobj->getTextureAtlas();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::TextureAtlas>((cocos2d::TextureAtlas*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_getTextureAtlas : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteBatchNode_insertQuadFromSprite(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_insertQuadFromSprite : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::Sprite* arg0;
			ssize_t arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_ssize_t(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_insertQuadFromSprite : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->insertQuadFromSprite(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_insertQuadFromSprite : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteBatchNode_setTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_setTexture : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Texture2D* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_setTexture : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTexture(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("texture");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_setTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteBatchNode_rebuildIndexInOrder(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_rebuildIndexInOrder : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::Sprite* arg0;
			ssize_t arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_ssize_t(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_rebuildIndexInOrder : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
					ssize_t ret = cobj->rebuildIndexInOrder(arg0, arg1);
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_rebuildIndexInOrder : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Sprite* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					ssize_t ret = cobj->highestAtlasIndexInChild(arg0);
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteBatchNode_removeChildAtIndex(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_removeChildAtIndex : self ptr is null");return RBNil();}
		if (argc == 2) {
			ssize_t arg0;
			bool arg1;
			ok &= rb_value_to_ssize_t(argv[0], &arg0);
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_removeChildAtIndex : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeChildAtIndex(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_removeChildAtIndex : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Sprite* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeSpriteFromAtlas(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteBatchNode_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		std::string arg0;
		ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_create : Error processing arguments");return RBNil();}
		cocos2d::SpriteBatchNode* ret = cocos2d::SpriteBatchNode::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::SpriteBatchNode>((cocos2d::SpriteBatchNode*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	if (argc == 2) {
		std::string arg0;
		ssize_t arg1;
		ok &= rb_value_to_std_string(argv[0], &arg0);
		ok &= rb_value_to_ssize_t(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_create : Error processing arguments");return RBNil();}
		cocos2d::SpriteBatchNode* ret = cocos2d::SpriteBatchNode::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::SpriteBatchNode>((cocos2d::SpriteBatchNode*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_SpriteBatchNode_createWithTexture(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::Texture2D* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_createWithTexture : Error processing arguments");return RBNil();}
		cocos2d::SpriteBatchNode* ret = cocos2d::SpriteBatchNode::createWithTexture(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::SpriteBatchNode>((cocos2d::SpriteBatchNode*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	if (argc == 2) {
		cocos2d::Texture2D* arg0;
		ssize_t arg1;
		ok &= rb_value_get_ptr(argv[0],&arg0);
		ok &= rb_value_to_ssize_t(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_createWithTexture : Error processing arguments");return RBNil();}
		cocos2d::SpriteBatchNode* ret = cocos2d::SpriteBatchNode::createWithTexture(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::SpriteBatchNode>((cocos2d::SpriteBatchNode*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_SpriteBatchNode_createWithTexture : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_SpriteBatchNode() {
		
	RBVAL classValue=rb_define_class_bridge("SpriteBatchNode",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"appendChild",RB_FUNC(rb_cocos2dx_SpriteBatchNode_appendChild));

	

	rb_define_method_bridge(classValue,"addSpriteWithoutQuad",RB_FUNC(rb_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad));

	

	rb_define_method_bridge(classValue,"reorderBatch",RB_FUNC(rb_cocos2dx_SpriteBatchNode_reorderBatch));

	

	rb_define_method_bridge(classValue,"removeAllChildrenWithCleanup",RB_FUNC(rb_cocos2dx_SpriteBatchNode_removeAllChildrenWithCleanup));

	

	rb_define_method_bridge(classValue,"lowestAtlasIndexInChild",RB_FUNC(rb_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild));

	

	rb_define_method_bridge(classValue,"atlasIndexForChild",RB_FUNC(rb_cocos2dx_SpriteBatchNode_atlasIndexForChild));

	

	rb_define_method_bridge(classValue,"setTextureAtlas",RB_FUNC(rb_cocos2dx_SpriteBatchNode_setTextureAtlas));

    rb_define_method_bridge(classValue,"textureAtlas=",RB_FUNC(rb_cocos2dx_SpriteBatchNode_setTextureAtlas));
	

	rb_define_method_bridge(classValue,"getTexture",RB_FUNC(rb_cocos2dx_SpriteBatchNode_getTexture));

   rb_define_method_bridge(classValue,"texture",RB_FUNC(rb_cocos2dx_SpriteBatchNode_getTexture));
	

	rb_define_method_bridge(classValue,"increaseAtlasCapacity",RB_FUNC(rb_cocos2dx_SpriteBatchNode_increaseAtlasCapacity));

	

	rb_define_method_bridge(classValue,"getTextureAtlas",RB_FUNC(rb_cocos2dx_SpriteBatchNode_getTextureAtlas));

   rb_define_method_bridge(classValue,"textureAtlas",RB_FUNC(rb_cocos2dx_SpriteBatchNode_getTextureAtlas));
	

	rb_define_method_bridge(classValue,"insertQuadFromSprite",RB_FUNC(rb_cocos2dx_SpriteBatchNode_insertQuadFromSprite));

	

	rb_define_method_bridge(classValue,"setTexture",RB_FUNC(rb_cocos2dx_SpriteBatchNode_setTexture));

    rb_define_method_bridge(classValue,"texture=",RB_FUNC(rb_cocos2dx_SpriteBatchNode_setTexture));
	

	rb_define_method_bridge(classValue,"rebuildIndexInOrder",RB_FUNC(rb_cocos2dx_SpriteBatchNode_rebuildIndexInOrder));

	

	rb_define_method_bridge(classValue,"highestAtlasIndexInChild",RB_FUNC(rb_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild));

	

	rb_define_method_bridge(classValue,"removeChildAtIndex",RB_FUNC(rb_cocos2dx_SpriteBatchNode_removeChildAtIndex));

	

	rb_define_method_bridge(classValue,"removeSpriteFromAtlas",RB_FUNC(rb_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_SpriteBatchNode_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTexture",RB_FUNC(rb_cocos2dx_SpriteBatchNode_createWithTexture));

	


	TypeTest<cocos2d::SpriteBatchNode> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::SpriteBatchNode",classValue);
}
RBVAL rb_cocos2dx_Label_isClipMarginEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_isClipMarginEnabled : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isClipMarginEnabled();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_isClipMarginEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_enableShadow(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_enableShadow : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->enableShadow();
		return value;
		}
		if (argc == 1) {
			cocos2d::Color4B arg0;
			ok &= rb_value_to_cccolor4b(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_enableShadow : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->enableShadow(arg0);
		return value;
		}
		if (argc == 2) {
			cocos2d::Color4B arg0;
			cocos2d::Size arg1;
			ok &= rb_value_to_cccolor4b(argv[0], &arg0);
			ok &= rb_value_to_ccsize(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_enableShadow : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->enableShadow(arg0, arg1);
		return value;
		}
		if (argc == 3) {
			cocos2d::Color4B arg0;
			cocos2d::Size arg1;
			int arg2;
			ok &= rb_value_to_cccolor4b(argv[0], &arg0);
			ok &= rb_value_to_ccsize(argv[1], &arg1);
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_enableShadow : Error processing argument 3 ( 3 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->enableShadow(arg0, arg1, arg2);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_enableShadow : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setDimensions(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setDimensions : self ptr is null");return RBNil();}
		if (argc == 2) {
			unsigned int arg0;
			unsigned int arg1;
			ok &= rb_value_to_uint(argv[0], &arg0);
			ok &= rb_value_to_uint(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setDimensions : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDimensions(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_setDimensions : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getString(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getString : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const std::string& ret = cobj->getString();
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getString : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getHeight(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getHeight : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					unsigned int ret = cobj->getHeight();
				value = uint_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getHeight : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_disableEffect(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_disableEffect : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->disableEffect();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_disableEffect : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setTTFConfig(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setTTFConfig : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::_ttfConfig arg0;
			#pragma warning NO CONVERSION TO NATIVE FOR _ttfConfig
		ok = false;
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setTTFConfig : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->setTTFConfig(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_setTTFConfig : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getTextColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getTextColor : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Color4B& ret = cobj->getTextColor();
				value = cccolor4b_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getTextColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setWidth(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setWidth : self ptr is null");return RBNil();}
		if (argc == 1) {
			unsigned int arg0;
			ok &= rb_value_to_uint(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setWidth : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setWidth(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("width");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_setWidth : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getMaxLineWidth(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getMaxLineWidth : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					unsigned int ret = cobj->getMaxLineWidth();
				value = uint_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getMaxLineWidth : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getHorizontalAlignment(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getHorizontalAlignment : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getHorizontalAlignment();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getHorizontalAlignment : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setClipMarginEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setClipMarginEnabled : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setClipMarginEnabled : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setClipMarginEnabled(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("clipMarginEnabled");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_setClipMarginEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setString(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setString : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setString : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setString(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("string");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_setString : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setSystemFontName(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setSystemFontName : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setSystemFontName : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setSystemFontName(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("systemFontName");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_setSystemFontName : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setBMFontFilePath(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setBMFontFilePath : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setBMFontFilePath : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->setBMFontFilePath(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}
		if (argc == 2) {
			std::string arg0;
			cocos2d::Vec2 arg1;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			ok &= rb_value_to_vec2(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setBMFontFilePath : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->setBMFontFilePath(arg0, arg1);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_setBMFontFilePath : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getFontAtlas(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getFontAtlas : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::FontAtlas* ret = cobj->getFontAtlas();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::FontAtlas>((cocos2d::FontAtlas*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getFontAtlas : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setLineHeight(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setLineHeight : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setLineHeight : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setLineHeight(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("lineHeight");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_setLineHeight : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setSystemFontSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setSystemFontSize : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setSystemFontSize : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setSystemFontSize(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("systemFontSize");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_setSystemFontSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_updateContent(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_updateContent : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->updateContent();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_updateContent : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getStringLength(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getStringLength : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getStringLength();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getStringLength : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setLineBreakWithoutSpace(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setLineBreakWithoutSpace : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setLineBreakWithoutSpace : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setLineBreakWithoutSpace(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("lineBreakWithoutSpace");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_setLineBreakWithoutSpace : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getStringNumLines(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getStringNumLines : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getStringNumLines();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getStringNumLines : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_enableOutline(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_enableOutline : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Color4B arg0;
			ok &= rb_value_to_cccolor4b(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_enableOutline : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->enableOutline(arg0);
		return value;
		}
		if (argc == 2) {
			cocos2d::Color4B arg0;
			int arg1;
			ok &= rb_value_to_cccolor4b(argv[0], &arg0);
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_enableOutline : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->enableOutline(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_enableOutline : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getAdditionalKerning(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getAdditionalKerning : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAdditionalKerning();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getAdditionalKerning : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setCharMap(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setCharMap : self ptr is null");return RBNil();}
	do {
		if (argc == 4) {
			cocos2d::Texture2D* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setCharMap : Error processing argument 1 ( 4 )");return RBNil(); }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setCharMap : Error processing argument 2 ( 4 )");return RBNil(); }
			int arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setCharMap : Error processing argument 3 ( 4 )");return RBNil(); }
			int arg3;
			ok &= rb_value_to_int(argv[3], (int *)&arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setCharMap : Error processing argument 4 ( 4 )");return RBNil(); }
			bool ret = cobj->setCharMap(arg0, arg1, arg2, arg3);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 4) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setCharMap : Error processing argument 1 ( 4 )");return RBNil(); }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setCharMap : Error processing argument 2 ( 4 )");return RBNil(); }
			int arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setCharMap : Error processing argument 3 ( 4 )");return RBNil(); }
			int arg3;
			ok &= rb_value_to_int(argv[3], (int *)&arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setCharMap : Error processing argument 4 ( 4 )");return RBNil(); }
			bool ret = cobj->setCharMap(arg0, arg1, arg2, arg3);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setCharMap : Error processing argument 1 ( 1 )");return RBNil(); }
			bool ret = cobj->setCharMap(arg0);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Label_setCharMap : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getDimensions(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getDimensions : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Size& ret = cobj->getDimensions();
				value = ccsize_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getDimensions : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setMaxLineWidth(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setMaxLineWidth : self ptr is null");return RBNil();}
		if (argc == 1) {
			unsigned int arg0;
			ok &= rb_value_to_uint(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setMaxLineWidth : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setMaxLineWidth(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("maxLineWidth");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_setMaxLineWidth : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getSystemFontName(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getSystemFontName : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const std::string& ret = cobj->getSystemFontName();
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getSystemFontName : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setVerticalAlignment(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setVerticalAlignment : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::TextVAlignment arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setVerticalAlignment : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setVerticalAlignment(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("verticalAlignment");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_setVerticalAlignment : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getLineHeight(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getLineHeight : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getLineHeight();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getLineHeight : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getTTFConfig(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getTTFConfig : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::_ttfConfig& ret = cobj->getTTFConfig();
				#pragma warning NO CONVERSION FROM NATIVE FOR _ttfConfig;
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getTTFConfig : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getVerticalAlignment(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getVerticalAlignment : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getVerticalAlignment();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getVerticalAlignment : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setTextColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setTextColor : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Color4B arg0;
			ok &= rb_value_to_cccolor4b(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setTextColor : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTextColor(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("textColor");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_setTextColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setHeight(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setHeight : self ptr is null");return RBNil();}
		if (argc == 1) {
			unsigned int arg0;
			ok &= rb_value_to_uint(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setHeight : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setHeight(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("height");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_setHeight : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getWidth(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getWidth : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					unsigned int ret = cobj->getWidth();
				value = uint_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getWidth : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_enableGlow(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_enableGlow : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Color4B arg0;
			ok &= rb_value_to_cccolor4b(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_enableGlow : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->enableGlow(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_enableGlow : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getLetter(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getLetter : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getLetter : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Sprite* ret = cobj->getLetter(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Sprite>((cocos2d::Sprite*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getLetter : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setAdditionalKerning(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setAdditionalKerning : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setAdditionalKerning : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAdditionalKerning(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("additionalKerning");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_setAdditionalKerning : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getSystemFontSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getSystemFontSize : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getSystemFontSize();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getSystemFontSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getTextAlignment(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getTextAlignment : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getTextAlignment();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getTextAlignment : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_getBMFontFilePath(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_getBMFontFilePath : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const std::string& ret = cobj->getBMFontFilePath();
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_getBMFontFilePath : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setHorizontalAlignment(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setHorizontalAlignment : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::TextHAlignment arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setHorizontalAlignment : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setHorizontalAlignment(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("horizontalAlignment");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_setHorizontalAlignment : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_setAlignment(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setAlignment : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			cocos2d::TextHAlignment arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setAlignment : Error processing argument 1 ( 2 )");return RBNil(); }
			cocos2d::TextVAlignment arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setAlignment : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->setAlignment(arg0, arg1);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 1) {
			cocos2d::TextHAlignment arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_setAlignment : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->setAlignment(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("alignment");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Label_setAlignment : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_requestSystemFontRefresh(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Label* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_requestSystemFontRefresh : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->requestSystemFontRefresh();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Label_requestSystemFontRefresh : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_createWithBMFont(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		std::string arg0;
		std::string arg1;
		ok &= rb_value_to_std_string(argv[0], &arg0);
		ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_createWithBMFont : Error processing arguments");return RBNil();}
		cocos2d::Label* ret = cocos2d::Label::createWithBMFont(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Label>((cocos2d::Label*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	if (argc == 3) {
		std::string arg0;
		std::string arg1;
		cocos2d::TextHAlignment arg2;
		ok &= rb_value_to_std_string(argv[0], &arg0);
		ok &= rb_value_to_std_string(argv[1], &arg1);
		ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_createWithBMFont : Error processing arguments");return RBNil();}
		cocos2d::Label* ret = cocos2d::Label::createWithBMFont(arg0, arg1, arg2);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Label>((cocos2d::Label*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	if (argc == 4) {
		std::string arg0;
		std::string arg1;
		cocos2d::TextHAlignment arg2;
		int arg3;
		ok &= rb_value_to_std_string(argv[0], &arg0);
		ok &= rb_value_to_std_string(argv[1], &arg1);
		ok &= rb_value_to_int(argv[2], (int *)&arg2);
		ok &= rb_value_to_int(argv[3], (int *)&arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_createWithBMFont : Error processing arguments");return RBNil();}
		cocos2d::Label* ret = cocos2d::Label::createWithBMFont(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Label>((cocos2d::Label*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	if (argc == 5) {
		std::string arg0;
		std::string arg1;
		cocos2d::TextHAlignment arg2;
		int arg3;
		cocos2d::Vec2 arg4;
		ok &= rb_value_to_std_string(argv[0], &arg0);
		ok &= rb_value_to_std_string(argv[1], &arg1);
		ok &= rb_value_to_int(argv[2], (int *)&arg2);
		ok &= rb_value_to_int(argv[3], (int *)&arg3);
		ok &= rb_value_to_vec2(argv[4], &arg4);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_createWithBMFont : Error processing arguments");return RBNil();}
		cocos2d::Label* ret = cocos2d::Label::createWithBMFont(arg0, arg1, arg2, arg3, arg4);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Label>((cocos2d::Label*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Label_createWithBMFont : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_Label_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::Label* ret = cocos2d::Label::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Label>((cocos2d::Label*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Label_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_Label_createWithCharMap(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 4) {
			cocos2d::Texture2D* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) { break; }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) { break; }
			int arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) { break; }
			int arg3;
			ok &= rb_value_to_int(argv[3], (int *)&arg3);
			if (!ok) { break; }
			cocos2d::Label* ret = cocos2d::Label::createWithCharMap(arg0, arg1, arg2, arg3);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::Label>((cocos2d::Label*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 4) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) { break; }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) { break; }
			int arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) { break; }
			int arg3;
			ok &= rb_value_to_int(argv[3], (int *)&arg3);
			if (!ok) { break; }
			cocos2d::Label* ret = cocos2d::Label::createWithCharMap(arg0, arg1, arg2, arg3);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::Label>((cocos2d::Label*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Label* ret = cocos2d::Label::createWithCharMap(arg0);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::Label>((cocos2d::Label*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_Label_createWithCharMap : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Label_createWithSystemFont(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 3) {
		std::string arg0;
		std::string arg1;
		float arg2;
		ok &= rb_value_to_std_string(argv[0], &arg0);
		ok &= rb_value_to_std_string(argv[1], &arg1);
		ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_createWithSystemFont : Error processing arguments");return RBNil();}
		cocos2d::Label* ret = cocos2d::Label::createWithSystemFont(arg0, arg1, arg2);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Label>((cocos2d::Label*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	if (argc == 4) {
		std::string arg0;
		std::string arg1;
		float arg2;
		cocos2d::Size arg3;
		ok &= rb_value_to_std_string(argv[0], &arg0);
		ok &= rb_value_to_std_string(argv[1], &arg1);
		ok &= rb_value_to_float(argv[2], &arg2);
		ok &= rb_value_to_ccsize(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_createWithSystemFont : Error processing arguments");return RBNil();}
		cocos2d::Label* ret = cocos2d::Label::createWithSystemFont(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Label>((cocos2d::Label*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	if (argc == 5) {
		std::string arg0;
		std::string arg1;
		float arg2;
		cocos2d::Size arg3;
		cocos2d::TextHAlignment arg4;
		ok &= rb_value_to_std_string(argv[0], &arg0);
		ok &= rb_value_to_std_string(argv[1], &arg1);
		ok &= rb_value_to_float(argv[2], &arg2);
		ok &= rb_value_to_ccsize(argv[3], &arg3);
		ok &= rb_value_to_int(argv[4], (int *)&arg4);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_createWithSystemFont : Error processing arguments");return RBNil();}
		cocos2d::Label* ret = cocos2d::Label::createWithSystemFont(arg0, arg1, arg2, arg3, arg4);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Label>((cocos2d::Label*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	if (argc == 6) {
		std::string arg0;
		std::string arg1;
		float arg2;
		cocos2d::Size arg3;
		cocos2d::TextHAlignment arg4;
		cocos2d::TextVAlignment arg5;
		ok &= rb_value_to_std_string(argv[0], &arg0);
		ok &= rb_value_to_std_string(argv[1], &arg1);
		ok &= rb_value_to_float(argv[2], &arg2);
		ok &= rb_value_to_ccsize(argv[3], &arg3);
		ok &= rb_value_to_int(argv[4], (int *)&arg4);
		ok &= rb_value_to_int(argv[5], (int *)&arg5);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Label_createWithSystemFont : Error processing arguments");return RBNil();}
		cocos2d::Label* ret = cocos2d::Label::createWithSystemFont(arg0, arg1, arg2, arg3, arg4, arg5);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Label>((cocos2d::Label*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Label_createWithSystemFont : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Label() {
		
	RBVAL classValue=rb_define_class_bridge("Label",rb_get_class_value("cocos2d::SpriteBatchNode"),true);

	rb_define_method_bridge(classValue,"isClipMarginEnabled",RB_FUNC(rb_cocos2dx_Label_isClipMarginEnabled));

	

	rb_define_method_bridge(classValue,"enableShadow",RB_FUNC(rb_cocos2dx_Label_enableShadow));

	

	rb_define_method_bridge(classValue,"setDimensions",RB_FUNC(rb_cocos2dx_Label_setDimensions));

    rb_define_method_bridge(classValue,"dimensions=",RB_FUNC(rb_cocos2dx_Label_setDimensions));
	

	rb_define_method_bridge(classValue,"getString",RB_FUNC(rb_cocos2dx_Label_getString));

   rb_define_method_bridge(classValue,"string",RB_FUNC(rb_cocos2dx_Label_getString));
	

	rb_define_method_bridge(classValue,"getHeight",RB_FUNC(rb_cocos2dx_Label_getHeight));

   rb_define_method_bridge(classValue,"height",RB_FUNC(rb_cocos2dx_Label_getHeight));
	

	rb_define_method_bridge(classValue,"disableEffect",RB_FUNC(rb_cocos2dx_Label_disableEffect));

	

	rb_define_method_bridge(classValue,"setTTFConfig",RB_FUNC(rb_cocos2dx_Label_setTTFConfig));

    rb_define_method_bridge(classValue,"tTFConfig=",RB_FUNC(rb_cocos2dx_Label_setTTFConfig));
	

	rb_define_method_bridge(classValue,"getTextColor",RB_FUNC(rb_cocos2dx_Label_getTextColor));

   rb_define_method_bridge(classValue,"textColor",RB_FUNC(rb_cocos2dx_Label_getTextColor));
	

	rb_define_method_bridge(classValue,"setWidth",RB_FUNC(rb_cocos2dx_Label_setWidth));

    rb_define_method_bridge(classValue,"width=",RB_FUNC(rb_cocos2dx_Label_setWidth));
	

	rb_define_method_bridge(classValue,"getMaxLineWidth",RB_FUNC(rb_cocos2dx_Label_getMaxLineWidth));

   rb_define_method_bridge(classValue,"maxLineWidth",RB_FUNC(rb_cocos2dx_Label_getMaxLineWidth));
	

	rb_define_method_bridge(classValue,"getHorizontalAlignment",RB_FUNC(rb_cocos2dx_Label_getHorizontalAlignment));

   rb_define_method_bridge(classValue,"horizontalAlignment",RB_FUNC(rb_cocos2dx_Label_getHorizontalAlignment));
	

	rb_define_method_bridge(classValue,"setClipMarginEnabled",RB_FUNC(rb_cocos2dx_Label_setClipMarginEnabled));

    rb_define_method_bridge(classValue,"clipMarginEnabled=",RB_FUNC(rb_cocos2dx_Label_setClipMarginEnabled));
	

	rb_define_method_bridge(classValue,"setString",RB_FUNC(rb_cocos2dx_Label_setString));

    rb_define_method_bridge(classValue,"string=",RB_FUNC(rb_cocos2dx_Label_setString));
	

	rb_define_method_bridge(classValue,"setSystemFontName",RB_FUNC(rb_cocos2dx_Label_setSystemFontName));

    rb_define_method_bridge(classValue,"systemFontName=",RB_FUNC(rb_cocos2dx_Label_setSystemFontName));
	

	rb_define_method_bridge(classValue,"setBMFontFilePath",RB_FUNC(rb_cocos2dx_Label_setBMFontFilePath));

    rb_define_method_bridge(classValue,"bMFontFilePath=",RB_FUNC(rb_cocos2dx_Label_setBMFontFilePath));
	

	rb_define_method_bridge(classValue,"getFontAtlas",RB_FUNC(rb_cocos2dx_Label_getFontAtlas));

   rb_define_method_bridge(classValue,"fontAtlas",RB_FUNC(rb_cocos2dx_Label_getFontAtlas));
	

	rb_define_method_bridge(classValue,"setLineHeight",RB_FUNC(rb_cocos2dx_Label_setLineHeight));

    rb_define_method_bridge(classValue,"lineHeight=",RB_FUNC(rb_cocos2dx_Label_setLineHeight));
	

	rb_define_method_bridge(classValue,"setSystemFontSize",RB_FUNC(rb_cocos2dx_Label_setSystemFontSize));

    rb_define_method_bridge(classValue,"systemFontSize=",RB_FUNC(rb_cocos2dx_Label_setSystemFontSize));
	

	rb_define_method_bridge(classValue,"updateContent",RB_FUNC(rb_cocos2dx_Label_updateContent));

	

	rb_define_method_bridge(classValue,"getStringLength",RB_FUNC(rb_cocos2dx_Label_getStringLength));

   rb_define_method_bridge(classValue,"stringLength",RB_FUNC(rb_cocos2dx_Label_getStringLength));
	

	rb_define_method_bridge(classValue,"setLineBreakWithoutSpace",RB_FUNC(rb_cocos2dx_Label_setLineBreakWithoutSpace));

    rb_define_method_bridge(classValue,"lineBreakWithoutSpace=",RB_FUNC(rb_cocos2dx_Label_setLineBreakWithoutSpace));
	

	rb_define_method_bridge(classValue,"getStringNumLines",RB_FUNC(rb_cocos2dx_Label_getStringNumLines));

   rb_define_method_bridge(classValue,"stringNumLines",RB_FUNC(rb_cocos2dx_Label_getStringNumLines));
	

	rb_define_method_bridge(classValue,"enableOutline",RB_FUNC(rb_cocos2dx_Label_enableOutline));

	

	rb_define_method_bridge(classValue,"getAdditionalKerning",RB_FUNC(rb_cocos2dx_Label_getAdditionalKerning));

   rb_define_method_bridge(classValue,"additionalKerning",RB_FUNC(rb_cocos2dx_Label_getAdditionalKerning));
	

	rb_define_method_bridge(classValue,"setCharMap",RB_FUNC(rb_cocos2dx_Label_setCharMap));

    rb_define_method_bridge(classValue,"charMap=",RB_FUNC(rb_cocos2dx_Label_setCharMap));
	

	rb_define_method_bridge(classValue,"getDimensions",RB_FUNC(rb_cocos2dx_Label_getDimensions));

   rb_define_method_bridge(classValue,"dimensions",RB_FUNC(rb_cocos2dx_Label_getDimensions));
	

	rb_define_method_bridge(classValue,"setMaxLineWidth",RB_FUNC(rb_cocos2dx_Label_setMaxLineWidth));

    rb_define_method_bridge(classValue,"maxLineWidth=",RB_FUNC(rb_cocos2dx_Label_setMaxLineWidth));
	

	rb_define_method_bridge(classValue,"getSystemFontName",RB_FUNC(rb_cocos2dx_Label_getSystemFontName));

   rb_define_method_bridge(classValue,"systemFontName",RB_FUNC(rb_cocos2dx_Label_getSystemFontName));
	

	rb_define_method_bridge(classValue,"setVerticalAlignment",RB_FUNC(rb_cocos2dx_Label_setVerticalAlignment));

    rb_define_method_bridge(classValue,"verticalAlignment=",RB_FUNC(rb_cocos2dx_Label_setVerticalAlignment));
	

	rb_define_method_bridge(classValue,"getLineHeight",RB_FUNC(rb_cocos2dx_Label_getLineHeight));

   rb_define_method_bridge(classValue,"lineHeight",RB_FUNC(rb_cocos2dx_Label_getLineHeight));
	

	rb_define_method_bridge(classValue,"getTTFConfig",RB_FUNC(rb_cocos2dx_Label_getTTFConfig));

   rb_define_method_bridge(classValue,"tTFConfig",RB_FUNC(rb_cocos2dx_Label_getTTFConfig));
	

	rb_define_method_bridge(classValue,"getVerticalAlignment",RB_FUNC(rb_cocos2dx_Label_getVerticalAlignment));

   rb_define_method_bridge(classValue,"verticalAlignment",RB_FUNC(rb_cocos2dx_Label_getVerticalAlignment));
	

	rb_define_method_bridge(classValue,"setTextColor",RB_FUNC(rb_cocos2dx_Label_setTextColor));

    rb_define_method_bridge(classValue,"textColor=",RB_FUNC(rb_cocos2dx_Label_setTextColor));
	

	rb_define_method_bridge(classValue,"setHeight",RB_FUNC(rb_cocos2dx_Label_setHeight));

    rb_define_method_bridge(classValue,"height=",RB_FUNC(rb_cocos2dx_Label_setHeight));
	

	rb_define_method_bridge(classValue,"getWidth",RB_FUNC(rb_cocos2dx_Label_getWidth));

   rb_define_method_bridge(classValue,"width",RB_FUNC(rb_cocos2dx_Label_getWidth));
	

	rb_define_method_bridge(classValue,"enableGlow",RB_FUNC(rb_cocos2dx_Label_enableGlow));

	

	rb_define_method_bridge(classValue,"getLetter",RB_FUNC(rb_cocos2dx_Label_getLetter));

   rb_define_method_bridge(classValue,"letter",RB_FUNC(rb_cocos2dx_Label_getLetter));
	

	rb_define_method_bridge(classValue,"setAdditionalKerning",RB_FUNC(rb_cocos2dx_Label_setAdditionalKerning));

    rb_define_method_bridge(classValue,"additionalKerning=",RB_FUNC(rb_cocos2dx_Label_setAdditionalKerning));
	

	rb_define_method_bridge(classValue,"getSystemFontSize",RB_FUNC(rb_cocos2dx_Label_getSystemFontSize));

   rb_define_method_bridge(classValue,"systemFontSize",RB_FUNC(rb_cocos2dx_Label_getSystemFontSize));
	

	rb_define_method_bridge(classValue,"getTextAlignment",RB_FUNC(rb_cocos2dx_Label_getTextAlignment));

   rb_define_method_bridge(classValue,"textAlignment",RB_FUNC(rb_cocos2dx_Label_getTextAlignment));
	

	rb_define_method_bridge(classValue,"getBMFontFilePath",RB_FUNC(rb_cocos2dx_Label_getBMFontFilePath));

   rb_define_method_bridge(classValue,"bMFontFilePath",RB_FUNC(rb_cocos2dx_Label_getBMFontFilePath));
	

	rb_define_method_bridge(classValue,"setHorizontalAlignment",RB_FUNC(rb_cocos2dx_Label_setHorizontalAlignment));

    rb_define_method_bridge(classValue,"horizontalAlignment=",RB_FUNC(rb_cocos2dx_Label_setHorizontalAlignment));
	

	rb_define_method_bridge(classValue,"setAlignment",RB_FUNC(rb_cocos2dx_Label_setAlignment));

    rb_define_method_bridge(classValue,"alignment=",RB_FUNC(rb_cocos2dx_Label_setAlignment));
	

	rb_define_method_bridge(classValue,"requestSystemFontRefresh",RB_FUNC(rb_cocos2dx_Label_requestSystemFontRefresh));

	

	

	rb_define_singleton_method_bridge(classValue,"createWithBMFont",RB_FUNC(rb_cocos2dx_Label_createWithBMFont));

	
	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Label_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithCharMap",RB_FUNC(rb_cocos2dx_Label_createWithCharMap));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithSystemFont",RB_FUNC(rb_cocos2dx_Label_createWithSystemFont));

	


	TypeTest<cocos2d::Label> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Label",classValue);
}
RBVAL rb_cocos2dx_Layer_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::Layer* ret = cocos2d::Layer::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Layer>((cocos2d::Layer*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Layer_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Layer() {
		
	RBVAL classValue=rb_define_class_bridge("LayerVirtual",rb_get_class_value("cocos2d::Node"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Layer_create));

	


	TypeTest<cocos2d::Layer> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Layer",classValue);
}
RBVAL rb_cocos2dx_LayerColor_changeWidthAndHeight(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerColor* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerColor_changeWidthAndHeight : self ptr is null");return RBNil();}
		if (argc == 2) {
			float arg0;
			float arg1;
			ok &= rb_value_to_float(argv[0], &arg0);
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerColor_changeWidthAndHeight : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->changeWidthAndHeight(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerColor_changeWidthAndHeight : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerColor_changeHeight(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerColor* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerColor_changeHeight : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerColor_changeHeight : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->changeHeight(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerColor_changeHeight : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerColor_changeWidth(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerColor* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerColor_changeWidth : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerColor_changeWidth : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->changeWidth(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerColor_changeWidth : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerColor_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 3) {
			cocos2d::Color4B arg0;
			ok &= rb_value_to_cccolor4b(argv[0], &arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::LayerColor* ret = cocos2d::LayerColor::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::LayerColor>((cocos2d::LayerColor*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 0) {
			cocos2d::LayerColor* ret = cocos2d::LayerColor::create();
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::LayerColor>((cocos2d::LayerColor*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 1) {
			cocos2d::Color4B arg0;
			ok &= rb_value_to_cccolor4b(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::LayerColor* ret = cocos2d::LayerColor::create(arg0);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::LayerColor>((cocos2d::LayerColor*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_LayerColor_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_LayerColor() {
		
	RBVAL classValue=rb_define_class_bridge("LayerColor",rb_get_class_value("cocos2d::Layer"),true);

	rb_define_method_bridge(classValue,"changeWidthAndHeight",RB_FUNC(rb_cocos2dx_LayerColor_changeWidthAndHeight));

	

	rb_define_method_bridge(classValue,"changeHeight",RB_FUNC(rb_cocos2dx_LayerColor_changeHeight));

	

	rb_define_method_bridge(classValue,"changeWidth",RB_FUNC(rb_cocos2dx_LayerColor_changeWidth));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_LayerColor_create));

	


	TypeTest<cocos2d::LayerColor> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::LayerColor",classValue);
}
RBVAL rb_cocos2dx_LayerGradient_getStartColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerGradient* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_getStartColor : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Color3B& ret = cobj->getStartColor();
				value = cccolor3b_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerGradient_getStartColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerGradient_isCompressedInterpolation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerGradient* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_isCompressedInterpolation : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isCompressedInterpolation();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerGradient_isCompressedInterpolation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerGradient_getStartOpacity(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerGradient* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_getStartOpacity : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					unsigned char ret = cobj->getStartOpacity();
				value = uint16_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerGradient_getStartOpacity : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerGradient_setVector(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerGradient* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_setVector : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_setVector : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setVector(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("vector");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerGradient_setVector : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerGradient_setStartOpacity(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerGradient* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_setStartOpacity : self ptr is null");return RBNil();}
		if (argc == 1) {
			unsigned char arg0;
			ok &= rb_value_to_uint16(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_setStartOpacity : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setStartOpacity(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("startOpacity");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerGradient_setStartOpacity : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerGradient_setCompressedInterpolation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerGradient* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_setCompressedInterpolation : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_setCompressedInterpolation : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setCompressedInterpolation(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("compressedInterpolation");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerGradient_setCompressedInterpolation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerGradient_setEndOpacity(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerGradient* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_setEndOpacity : self ptr is null");return RBNil();}
		if (argc == 1) {
			unsigned char arg0;
			ok &= rb_value_to_uint16(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_setEndOpacity : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEndOpacity(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("endOpacity");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerGradient_setEndOpacity : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerGradient_getVector(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerGradient* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_getVector : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec2& ret = cobj->getVector();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerGradient_getVector : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerGradient_setEndColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerGradient* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_setEndColor : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Color3B arg0;
			ok &= rb_value_to_cccolor3b(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_setEndColor : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEndColor(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("endColor");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerGradient_setEndColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerGradient_getEndColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerGradient* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_getEndColor : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Color3B& ret = cobj->getEndColor();
				value = cccolor3b_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerGradient_getEndColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerGradient_getEndOpacity(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerGradient* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_getEndOpacity : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					unsigned char ret = cobj->getEndOpacity();
				value = uint16_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerGradient_getEndOpacity : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerGradient_setStartColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerGradient* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_setStartColor : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Color3B arg0;
			ok &= rb_value_to_cccolor3b(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerGradient_setStartColor : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setStartColor(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("startColor");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerGradient_setStartColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerGradient_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 2) {
			cocos2d::Color4B arg0;
			ok &= rb_value_to_cccolor4b(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Color4B arg1;
			ok &= rb_value_to_cccolor4b(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::LayerGradient* ret = cocos2d::LayerGradient::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::LayerGradient>((cocos2d::LayerGradient*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 0) {
			cocos2d::LayerGradient* ret = cocos2d::LayerGradient::create();
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::LayerGradient>((cocos2d::LayerGradient*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 3) {
			cocos2d::Color4B arg0;
			ok &= rb_value_to_cccolor4b(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Color4B arg1;
			ok &= rb_value_to_cccolor4b(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::Vec2 arg2;
			ok &= rb_value_to_vec2(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::LayerGradient* ret = cocos2d::LayerGradient::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::LayerGradient>((cocos2d::LayerGradient*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_LayerGradient_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_LayerGradient() {
		
	RBVAL classValue=rb_define_class_bridge("LayerGradient",rb_get_class_value("cocos2d::LayerColor"),true);

	rb_define_method_bridge(classValue,"getStartColor",RB_FUNC(rb_cocos2dx_LayerGradient_getStartColor));

   rb_define_method_bridge(classValue,"startColor",RB_FUNC(rb_cocos2dx_LayerGradient_getStartColor));
	

	rb_define_method_bridge(classValue,"isCompressedInterpolation",RB_FUNC(rb_cocos2dx_LayerGradient_isCompressedInterpolation));

	

	rb_define_method_bridge(classValue,"getStartOpacity",RB_FUNC(rb_cocos2dx_LayerGradient_getStartOpacity));

   rb_define_method_bridge(classValue,"startOpacity",RB_FUNC(rb_cocos2dx_LayerGradient_getStartOpacity));
	

	rb_define_method_bridge(classValue,"setVector",RB_FUNC(rb_cocos2dx_LayerGradient_setVector));

    rb_define_method_bridge(classValue,"vector=",RB_FUNC(rb_cocos2dx_LayerGradient_setVector));
	

	rb_define_method_bridge(classValue,"setStartOpacity",RB_FUNC(rb_cocos2dx_LayerGradient_setStartOpacity));

    rb_define_method_bridge(classValue,"startOpacity=",RB_FUNC(rb_cocos2dx_LayerGradient_setStartOpacity));
	

	rb_define_method_bridge(classValue,"setCompressedInterpolation",RB_FUNC(rb_cocos2dx_LayerGradient_setCompressedInterpolation));

    rb_define_method_bridge(classValue,"compressedInterpolation=",RB_FUNC(rb_cocos2dx_LayerGradient_setCompressedInterpolation));
	

	rb_define_method_bridge(classValue,"setEndOpacity",RB_FUNC(rb_cocos2dx_LayerGradient_setEndOpacity));

    rb_define_method_bridge(classValue,"endOpacity=",RB_FUNC(rb_cocos2dx_LayerGradient_setEndOpacity));
	

	rb_define_method_bridge(classValue,"getVector",RB_FUNC(rb_cocos2dx_LayerGradient_getVector));

   rb_define_method_bridge(classValue,"vector",RB_FUNC(rb_cocos2dx_LayerGradient_getVector));
	

	rb_define_method_bridge(classValue,"setEndColor",RB_FUNC(rb_cocos2dx_LayerGradient_setEndColor));

    rb_define_method_bridge(classValue,"endColor=",RB_FUNC(rb_cocos2dx_LayerGradient_setEndColor));
	

	rb_define_method_bridge(classValue,"getEndColor",RB_FUNC(rb_cocos2dx_LayerGradient_getEndColor));

   rb_define_method_bridge(classValue,"endColor",RB_FUNC(rb_cocos2dx_LayerGradient_getEndColor));
	

	rb_define_method_bridge(classValue,"getEndOpacity",RB_FUNC(rb_cocos2dx_LayerGradient_getEndOpacity));

   rb_define_method_bridge(classValue,"endOpacity",RB_FUNC(rb_cocos2dx_LayerGradient_getEndOpacity));
	

	rb_define_method_bridge(classValue,"setStartColor",RB_FUNC(rb_cocos2dx_LayerGradient_setStartColor));

    rb_define_method_bridge(classValue,"startColor=",RB_FUNC(rb_cocos2dx_LayerGradient_setStartColor));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_LayerGradient_create));

	


	TypeTest<cocos2d::LayerGradient> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::LayerGradient",classValue);
}
RBVAL rb_cocos2dx_LayerMultiplex_switchToAndReleaseMe(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerMultiplex* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerMultiplex_switchToAndReleaseMe : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerMultiplex_switchToAndReleaseMe : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->switchToAndReleaseMe(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerMultiplex_switchToAndReleaseMe : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerMultiplex_addLayer(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerMultiplex* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerMultiplex_addLayer : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Layer* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerMultiplex_addLayer : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addLayer(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerMultiplex_addLayer : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_LayerMultiplex_switchTo(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::LayerMultiplex* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerMultiplex_switchTo : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_LayerMultiplex_switchTo : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->switchTo(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_LayerMultiplex_switchTo : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_LayerMultiplex() {
		
	RBVAL classValue=rb_define_class_bridge("LayerMultiplex",rb_get_class_value("cocos2d::Layer"),true);

	rb_define_method_bridge(classValue,"switchToAndReleaseMe",RB_FUNC(rb_cocos2dx_LayerMultiplex_switchToAndReleaseMe));

	

	rb_define_method_bridge(classValue,"addLayer",RB_FUNC(rb_cocos2dx_LayerMultiplex_addLayer));

	

	rb_define_method_bridge(classValue,"switchTo",RB_FUNC(rb_cocos2dx_LayerMultiplex_switchTo));

	



	TypeTest<cocos2d::LayerMultiplex> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::LayerMultiplex",classValue);
}
RBVAL rb_cocos2dx_TransitionEaseScene_easeActionWithAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionEaseScene* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionEaseScene_easeActionWithAction : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ActionInterval* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionEaseScene_easeActionWithAction : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->easeActionWithAction(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionEaseScene_easeActionWithAction : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_TransitionEaseScene() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionEaseScene",rb_get_root_class(),true);

	rb_define_method_bridge(classValue,"easeActionWithAction",RB_FUNC(rb_cocos2dx_TransitionEaseScene_easeActionWithAction));

	



	TypeTest<cocos2d::TransitionEaseScene> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionEaseScene",classValue);
}
RBVAL rb_cocos2dx_TransitionScene_finish(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionScene* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionScene_finish : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->finish();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionScene_finish : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionScene_hideOutShowIn(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionScene* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionScene_hideOutShowIn : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->hideOutShowIn();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionScene_hideOutShowIn : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionScene_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionScene_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionScene* ret = cocos2d::TransitionScene::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionScene>((cocos2d::TransitionScene*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionScene_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionScene() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionScene",rb_get_class_value("cocos2d::Scene"),true);

	rb_define_method_bridge(classValue,"finish",RB_FUNC(rb_cocos2dx_TransitionScene_finish));

	

	rb_define_method_bridge(classValue,"hideOutShowIn",RB_FUNC(rb_cocos2dx_TransitionScene_hideOutShowIn));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionScene_create));

	


	TypeTest<cocos2d::TransitionScene> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionScene",classValue);
}
RBVAL rb_cocos2dx_TransitionSceneOriented_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 3) {
		float arg0;
		cocos2d::Scene* arg1;
		cocos2d::TransitionScene::Orientation arg2;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
		ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionSceneOriented_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionSceneOriented* ret = cocos2d::TransitionSceneOriented::create(arg0, arg1, arg2);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionSceneOriented>((cocos2d::TransitionSceneOriented*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionSceneOriented_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionSceneOriented() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionSceneOriented",rb_get_class_value("cocos2d::TransitionScene"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionSceneOriented_create));

	


	TypeTest<cocos2d::TransitionSceneOriented> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionSceneOriented",classValue);
}
RBVAL rb_cocos2dx_TransitionRotoZoom_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionRotoZoom_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionRotoZoom* ret = cocos2d::TransitionRotoZoom::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionRotoZoom>((cocos2d::TransitionRotoZoom*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionRotoZoom_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionRotoZoom() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionRotoZoom",rb_get_class_value("cocos2d::TransitionScene"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionRotoZoom_create));

	


	TypeTest<cocos2d::TransitionRotoZoom> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionRotoZoom",classValue);
}
RBVAL rb_cocos2dx_TransitionJumpZoom_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionJumpZoom_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionJumpZoom* ret = cocos2d::TransitionJumpZoom::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionJumpZoom>((cocos2d::TransitionJumpZoom*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionJumpZoom_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionJumpZoom() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionJumpZoom",rb_get_class_value("cocos2d::TransitionScene"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionJumpZoom_create));

	


	TypeTest<cocos2d::TransitionJumpZoom> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionJumpZoom",classValue);
}
RBVAL rb_cocos2dx_TransitionMoveInL_action(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionMoveInL* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionMoveInL_action : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->action();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionMoveInL_action : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionMoveInL_easeActionWithAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionMoveInL* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionMoveInL_easeActionWithAction : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ActionInterval* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionMoveInL_easeActionWithAction : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->easeActionWithAction(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionMoveInL_easeActionWithAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionMoveInL_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionMoveInL_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionMoveInL* ret = cocos2d::TransitionMoveInL::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionMoveInL>((cocos2d::TransitionMoveInL*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionMoveInL_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionMoveInL() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionMoveInL",rb_get_class_value("cocos2d::TransitionScene"),true);

	rb_define_method_bridge(classValue,"action",RB_FUNC(rb_cocos2dx_TransitionMoveInL_action));

	

	rb_define_method_bridge(classValue,"easeActionWithAction",RB_FUNC(rb_cocos2dx_TransitionMoveInL_easeActionWithAction));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionMoveInL_create));

	


	TypeTest<cocos2d::TransitionMoveInL> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionMoveInL",classValue);
}
RBVAL rb_cocos2dx_TransitionMoveInR_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionMoveInR_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionMoveInR* ret = cocos2d::TransitionMoveInR::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionMoveInR>((cocos2d::TransitionMoveInR*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionMoveInR_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionMoveInR() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionMoveInR",rb_get_class_value("cocos2d::TransitionMoveInL"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionMoveInR_create));

	


	TypeTest<cocos2d::TransitionMoveInR> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionMoveInR",classValue);
}
RBVAL rb_cocos2dx_TransitionMoveInT_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionMoveInT_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionMoveInT* ret = cocos2d::TransitionMoveInT::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionMoveInT>((cocos2d::TransitionMoveInT*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionMoveInT_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionMoveInT() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionMoveInT",rb_get_class_value("cocos2d::TransitionMoveInL"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionMoveInT_create));

	


	TypeTest<cocos2d::TransitionMoveInT> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionMoveInT",classValue);
}
RBVAL rb_cocos2dx_TransitionMoveInB_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionMoveInB_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionMoveInB* ret = cocos2d::TransitionMoveInB::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionMoveInB>((cocos2d::TransitionMoveInB*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionMoveInB_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionMoveInB() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionMoveInB",rb_get_class_value("cocos2d::TransitionMoveInL"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionMoveInB_create));

	


	TypeTest<cocos2d::TransitionMoveInB> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionMoveInB",classValue);
}
RBVAL rb_cocos2dx_TransitionSlideInL_action(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionSlideInL* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionSlideInL_action : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->action();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionSlideInL_action : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionSlideInL_easeActionWithAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionSlideInL* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionSlideInL_easeActionWithAction : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ActionInterval* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionSlideInL_easeActionWithAction : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->easeActionWithAction(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionSlideInL_easeActionWithAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionSlideInL_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionSlideInL_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionSlideInL* ret = cocos2d::TransitionSlideInL::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionSlideInL>((cocos2d::TransitionSlideInL*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionSlideInL_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionSlideInL() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionSlideInL",rb_get_class_value("cocos2d::TransitionScene"),true);

	rb_define_method_bridge(classValue,"action",RB_FUNC(rb_cocos2dx_TransitionSlideInL_action));

	

	rb_define_method_bridge(classValue,"easeActionWithAction",RB_FUNC(rb_cocos2dx_TransitionSlideInL_easeActionWithAction));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionSlideInL_create));

	


	TypeTest<cocos2d::TransitionSlideInL> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionSlideInL",classValue);
}
RBVAL rb_cocos2dx_TransitionSlideInR_action(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionSlideInR* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionSlideInR_action : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->action();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionSlideInR_action : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionSlideInR_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionSlideInR_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionSlideInR* ret = cocos2d::TransitionSlideInR::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionSlideInR>((cocos2d::TransitionSlideInR*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionSlideInR_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionSlideInR() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionSlideInR",rb_get_class_value("cocos2d::TransitionSlideInL"),true);

	rb_define_method_bridge(classValue,"action",RB_FUNC(rb_cocos2dx_TransitionSlideInR_action));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionSlideInR_create));

	


	TypeTest<cocos2d::TransitionSlideInR> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionSlideInR",classValue);
}
RBVAL rb_cocos2dx_TransitionSlideInB_action(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionSlideInB* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionSlideInB_action : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->action();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionSlideInB_action : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionSlideInB_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionSlideInB_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionSlideInB* ret = cocos2d::TransitionSlideInB::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionSlideInB>((cocos2d::TransitionSlideInB*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionSlideInB_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionSlideInB() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionSlideInB",rb_get_class_value("cocos2d::TransitionSlideInL"),true);

	rb_define_method_bridge(classValue,"action",RB_FUNC(rb_cocos2dx_TransitionSlideInB_action));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionSlideInB_create));

	


	TypeTest<cocos2d::TransitionSlideInB> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionSlideInB",classValue);
}
RBVAL rb_cocos2dx_TransitionSlideInT_action(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionSlideInT* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionSlideInT_action : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->action();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionSlideInT_action : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionSlideInT_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionSlideInT_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionSlideInT* ret = cocos2d::TransitionSlideInT::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionSlideInT>((cocos2d::TransitionSlideInT*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionSlideInT_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionSlideInT() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionSlideInT",rb_get_class_value("cocos2d::TransitionSlideInL"),true);

	rb_define_method_bridge(classValue,"action",RB_FUNC(rb_cocos2dx_TransitionSlideInT_action));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionSlideInT_create));

	


	TypeTest<cocos2d::TransitionSlideInT> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionSlideInT",classValue);
}
RBVAL rb_cocos2dx_TransitionShrinkGrow_easeActionWithAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionShrinkGrow* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionShrinkGrow_easeActionWithAction : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ActionInterval* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionShrinkGrow_easeActionWithAction : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->easeActionWithAction(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionShrinkGrow_easeActionWithAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionShrinkGrow_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionShrinkGrow_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionShrinkGrow* ret = cocos2d::TransitionShrinkGrow::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionShrinkGrow>((cocos2d::TransitionShrinkGrow*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionShrinkGrow_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionShrinkGrow() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionShrinkGrow",rb_get_class_value("cocos2d::TransitionScene"),true);

	rb_define_method_bridge(classValue,"easeActionWithAction",RB_FUNC(rb_cocos2dx_TransitionShrinkGrow_easeActionWithAction));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionShrinkGrow_create));

	


	TypeTest<cocos2d::TransitionShrinkGrow> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionShrinkGrow",classValue);
}
RBVAL rb_cocos2dx_TransitionFlipX_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 2) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Scene* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			cocos2d::TransitionFlipX* ret = cocos2d::TransitionFlipX::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TransitionFlipX>((cocos2d::TransitionFlipX*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 3) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Scene* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			cocos2d::TransitionScene::Orientation arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) { break; }
			cocos2d::TransitionFlipX* ret = cocos2d::TransitionFlipX::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TransitionFlipX>((cocos2d::TransitionFlipX*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_TransitionFlipX_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_TransitionFlipX() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionFlipX",rb_get_class_value("cocos2d::TransitionSceneOriented"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionFlipX_create));

	


	TypeTest<cocos2d::TransitionFlipX> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionFlipX",classValue);
}
RBVAL rb_cocos2dx_TransitionFlipY_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 2) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Scene* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			cocos2d::TransitionFlipY* ret = cocos2d::TransitionFlipY::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TransitionFlipY>((cocos2d::TransitionFlipY*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 3) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Scene* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			cocos2d::TransitionScene::Orientation arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) { break; }
			cocos2d::TransitionFlipY* ret = cocos2d::TransitionFlipY::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TransitionFlipY>((cocos2d::TransitionFlipY*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_TransitionFlipY_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_TransitionFlipY() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionFlipY",rb_get_class_value("cocos2d::TransitionSceneOriented"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionFlipY_create));

	


	TypeTest<cocos2d::TransitionFlipY> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionFlipY",classValue);
}
RBVAL rb_cocos2dx_TransitionFlipAngular_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 2) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Scene* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			cocos2d::TransitionFlipAngular* ret = cocos2d::TransitionFlipAngular::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TransitionFlipAngular>((cocos2d::TransitionFlipAngular*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 3) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Scene* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			cocos2d::TransitionScene::Orientation arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) { break; }
			cocos2d::TransitionFlipAngular* ret = cocos2d::TransitionFlipAngular::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TransitionFlipAngular>((cocos2d::TransitionFlipAngular*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_TransitionFlipAngular_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_TransitionFlipAngular() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionFlipAngular",rb_get_class_value("cocos2d::TransitionSceneOriented"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionFlipAngular_create));

	


	TypeTest<cocos2d::TransitionFlipAngular> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionFlipAngular",classValue);
}
RBVAL rb_cocos2dx_TransitionZoomFlipX_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 2) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Scene* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			cocos2d::TransitionZoomFlipX* ret = cocos2d::TransitionZoomFlipX::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TransitionZoomFlipX>((cocos2d::TransitionZoomFlipX*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 3) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Scene* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			cocos2d::TransitionScene::Orientation arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) { break; }
			cocos2d::TransitionZoomFlipX* ret = cocos2d::TransitionZoomFlipX::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TransitionZoomFlipX>((cocos2d::TransitionZoomFlipX*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_TransitionZoomFlipX_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_TransitionZoomFlipX() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionZoomFlipX",rb_get_class_value("cocos2d::TransitionSceneOriented"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionZoomFlipX_create));

	


	TypeTest<cocos2d::TransitionZoomFlipX> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionZoomFlipX",classValue);
}
RBVAL rb_cocos2dx_TransitionZoomFlipY_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 2) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Scene* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			cocos2d::TransitionZoomFlipY* ret = cocos2d::TransitionZoomFlipY::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TransitionZoomFlipY>((cocos2d::TransitionZoomFlipY*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 3) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Scene* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			cocos2d::TransitionScene::Orientation arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) { break; }
			cocos2d::TransitionZoomFlipY* ret = cocos2d::TransitionZoomFlipY::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TransitionZoomFlipY>((cocos2d::TransitionZoomFlipY*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_TransitionZoomFlipY_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_TransitionZoomFlipY() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionZoomFlipY",rb_get_class_value("cocos2d::TransitionSceneOriented"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionZoomFlipY_create));

	


	TypeTest<cocos2d::TransitionZoomFlipY> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionZoomFlipY",classValue);
}
RBVAL rb_cocos2dx_TransitionZoomFlipAngular_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 2) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Scene* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			cocos2d::TransitionZoomFlipAngular* ret = cocos2d::TransitionZoomFlipAngular::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TransitionZoomFlipAngular>((cocos2d::TransitionZoomFlipAngular*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 3) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Scene* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			cocos2d::TransitionScene::Orientation arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) { break; }
			cocos2d::TransitionZoomFlipAngular* ret = cocos2d::TransitionZoomFlipAngular::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TransitionZoomFlipAngular>((cocos2d::TransitionZoomFlipAngular*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_TransitionZoomFlipAngular_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_TransitionZoomFlipAngular() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionZoomFlipAngular",rb_get_class_value("cocos2d::TransitionSceneOriented"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionZoomFlipAngular_create));

	


	TypeTest<cocos2d::TransitionZoomFlipAngular> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionZoomFlipAngular",classValue);
}
RBVAL rb_cocos2dx_TransitionFade_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 2) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Scene* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			cocos2d::TransitionFade* ret = cocos2d::TransitionFade::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TransitionFade>((cocos2d::TransitionFade*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 3) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Scene* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			cocos2d::Color3B arg2;
			ok &= rb_value_to_cccolor3b(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::TransitionFade* ret = cocos2d::TransitionFade::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TransitionFade>((cocos2d::TransitionFade*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_TransitionFade_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_TransitionFade() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionFade",rb_get_class_value("cocos2d::TransitionScene"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionFade_create));

	


	TypeTest<cocos2d::TransitionFade> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionFade",classValue);
}
RBVAL rb_cocos2dx_TransitionCrossFade_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionCrossFade_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionCrossFade* ret = cocos2d::TransitionCrossFade::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionCrossFade>((cocos2d::TransitionCrossFade*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionCrossFade_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionCrossFade() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionCrossFade",rb_get_class_value("cocos2d::TransitionScene"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionCrossFade_create));

	


	TypeTest<cocos2d::TransitionCrossFade> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionCrossFade",classValue);
}
RBVAL rb_cocos2dx_TransitionTurnOffTiles_easeActionWithAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionTurnOffTiles* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionTurnOffTiles_easeActionWithAction : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ActionInterval* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionTurnOffTiles_easeActionWithAction : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->easeActionWithAction(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionTurnOffTiles_easeActionWithAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionTurnOffTiles_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionTurnOffTiles_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionTurnOffTiles* ret = cocos2d::TransitionTurnOffTiles::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionTurnOffTiles>((cocos2d::TransitionTurnOffTiles*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionTurnOffTiles_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionTurnOffTiles() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionTurnOffTiles",rb_get_class_value("cocos2d::TransitionScene"),true);

	rb_define_method_bridge(classValue,"easeActionWithAction",RB_FUNC(rb_cocos2dx_TransitionTurnOffTiles_easeActionWithAction));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionTurnOffTiles_create));

	


	TypeTest<cocos2d::TransitionTurnOffTiles> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionTurnOffTiles",classValue);
}
RBVAL rb_cocos2dx_TransitionSplitCols_action(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionSplitCols* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionSplitCols_action : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->action();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionSplitCols_action : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionSplitCols_easeActionWithAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionSplitCols* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionSplitCols_easeActionWithAction : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ActionInterval* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionSplitCols_easeActionWithAction : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->easeActionWithAction(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionSplitCols_easeActionWithAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionSplitCols_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionSplitCols_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionSplitCols* ret = cocos2d::TransitionSplitCols::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionSplitCols>((cocos2d::TransitionSplitCols*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionSplitCols_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionSplitCols() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionSplitCols",rb_get_class_value("cocos2d::TransitionScene"),true);

	rb_define_method_bridge(classValue,"action",RB_FUNC(rb_cocos2dx_TransitionSplitCols_action));

	

	rb_define_method_bridge(classValue,"easeActionWithAction",RB_FUNC(rb_cocos2dx_TransitionSplitCols_easeActionWithAction));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionSplitCols_create));

	


	TypeTest<cocos2d::TransitionSplitCols> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionSplitCols",classValue);
}
RBVAL rb_cocos2dx_TransitionSplitRows_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionSplitRows_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionSplitRows* ret = cocos2d::TransitionSplitRows::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionSplitRows>((cocos2d::TransitionSplitRows*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionSplitRows_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionSplitRows() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionSplitRows",rb_get_class_value("cocos2d::TransitionSplitCols"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionSplitRows_create));

	


	TypeTest<cocos2d::TransitionSplitRows> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionSplitRows",classValue);
}
RBVAL rb_cocos2dx_TransitionFadeTR_easeActionWithAction(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionFadeTR* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionFadeTR_easeActionWithAction : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ActionInterval* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionFadeTR_easeActionWithAction : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->easeActionWithAction(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionFadeTR_easeActionWithAction : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionFadeTR_actionWithSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionFadeTR* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionFadeTR_actionWithSize : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Size arg0;
			ok &= rb_value_to_ccsize(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionFadeTR_actionWithSize : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->actionWithSize(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionFadeTR_actionWithSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionFadeTR_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionFadeTR_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionFadeTR* ret = cocos2d::TransitionFadeTR::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionFadeTR>((cocos2d::TransitionFadeTR*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionFadeTR_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionFadeTR() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionFadeTR",rb_get_class_value("cocos2d::TransitionScene"),true);

	rb_define_method_bridge(classValue,"easeActionWithAction",RB_FUNC(rb_cocos2dx_TransitionFadeTR_easeActionWithAction));

	

	rb_define_method_bridge(classValue,"actionWithSize",RB_FUNC(rb_cocos2dx_TransitionFadeTR_actionWithSize));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionFadeTR_create));

	


	TypeTest<cocos2d::TransitionFadeTR> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionFadeTR",classValue);
}
RBVAL rb_cocos2dx_TransitionFadeBL_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionFadeBL_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionFadeBL* ret = cocos2d::TransitionFadeBL::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionFadeBL>((cocos2d::TransitionFadeBL*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionFadeBL_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionFadeBL() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionFadeBL",rb_get_class_value("cocos2d::TransitionFadeTR"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionFadeBL_create));

	


	TypeTest<cocos2d::TransitionFadeBL> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionFadeBL",classValue);
}
RBVAL rb_cocos2dx_TransitionFadeUp_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionFadeUp_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionFadeUp* ret = cocos2d::TransitionFadeUp::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionFadeUp>((cocos2d::TransitionFadeUp*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionFadeUp_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionFadeUp() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionFadeUp",rb_get_class_value("cocos2d::TransitionFadeTR"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionFadeUp_create));

	


	TypeTest<cocos2d::TransitionFadeUp> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionFadeUp",classValue);
}
RBVAL rb_cocos2dx_TransitionFadeDown_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionFadeDown_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionFadeDown* ret = cocos2d::TransitionFadeDown::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionFadeDown>((cocos2d::TransitionFadeDown*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionFadeDown_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionFadeDown() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionFadeDown",rb_get_class_value("cocos2d::TransitionFadeTR"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionFadeDown_create));

	


	TypeTest<cocos2d::TransitionFadeDown> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionFadeDown",classValue);
}
RBVAL rb_cocos2dx_TransitionPageTurn_actionWithSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionPageTurn* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionPageTurn_actionWithSize : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Size arg0;
			ok &= rb_value_to_ccsize(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionPageTurn_actionWithSize : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::ActionInterval* ret = cobj->actionWithSize(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ActionInterval>((cocos2d::ActionInterval*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionPageTurn_actionWithSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionPageTurn_initWithDuration(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TransitionPageTurn* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionPageTurn_initWithDuration : self ptr is null");return RBNil();}
		if (argc == 3) {
			float arg0;
			cocos2d::Scene* arg1;
			bool arg2;
			ok &= rb_value_to_float(argv[0], &arg0);
			ok &= rb_value_get_ptr(argv[1],&arg1);
			ok &= rb_value_to_bool(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionPageTurn_initWithDuration : Error processing argument 3 ( 3 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->initWithDuration(arg0, arg1, arg2);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TransitionPageTurn_initWithDuration : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TransitionPageTurn_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 3) {
		float arg0;
		cocos2d::Scene* arg1;
		bool arg2;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
		ok &= rb_value_to_bool(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionPageTurn_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionPageTurn* ret = cocos2d::TransitionPageTurn::create(arg0, arg1, arg2);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionPageTurn>((cocos2d::TransitionPageTurn*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionPageTurn_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionPageTurn() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionPageTurn",rb_get_class_value("cocos2d::TransitionScene"),true);

	rb_define_method_bridge(classValue,"actionWithSize",RB_FUNC(rb_cocos2dx_TransitionPageTurn_actionWithSize));

	

	rb_define_method_bridge(classValue,"initWithDuration",RB_FUNC(rb_cocos2dx_TransitionPageTurn_initWithDuration));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionPageTurn_create));

	


	TypeTest<cocos2d::TransitionPageTurn> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionPageTurn",classValue);
}
RBVAL rb_cocos2dx_TransitionProgress_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionProgress_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionProgress* ret = cocos2d::TransitionProgress::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionProgress>((cocos2d::TransitionProgress*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionProgress_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionProgress() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionProgress",rb_get_class_value("cocos2d::TransitionScene"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionProgress_create));

	


	TypeTest<cocos2d::TransitionProgress> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionProgress",classValue);
}
RBVAL rb_cocos2dx_TransitionProgressRadialCCW_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionProgressRadialCCW_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionProgressRadialCCW* ret = cocos2d::TransitionProgressRadialCCW::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionProgressRadialCCW>((cocos2d::TransitionProgressRadialCCW*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionProgressRadialCCW_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionProgressRadialCCW() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionProgressRadialCCW",rb_get_class_value("cocos2d::TransitionProgress"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionProgressRadialCCW_create));

	


	TypeTest<cocos2d::TransitionProgressRadialCCW> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionProgressRadialCCW",classValue);
}
RBVAL rb_cocos2dx_TransitionProgressRadialCW_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionProgressRadialCW_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionProgressRadialCW* ret = cocos2d::TransitionProgressRadialCW::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionProgressRadialCW>((cocos2d::TransitionProgressRadialCW*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionProgressRadialCW_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionProgressRadialCW() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionProgressRadialCW",rb_get_class_value("cocos2d::TransitionProgress"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionProgressRadialCW_create));

	


	TypeTest<cocos2d::TransitionProgressRadialCW> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionProgressRadialCW",classValue);
}
RBVAL rb_cocos2dx_TransitionProgressHorizontal_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionProgressHorizontal_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionProgressHorizontal* ret = cocos2d::TransitionProgressHorizontal::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionProgressHorizontal>((cocos2d::TransitionProgressHorizontal*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionProgressHorizontal_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionProgressHorizontal() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionProgressHorizontal",rb_get_class_value("cocos2d::TransitionProgress"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionProgressHorizontal_create));

	


	TypeTest<cocos2d::TransitionProgressHorizontal> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionProgressHorizontal",classValue);
}
RBVAL rb_cocos2dx_TransitionProgressVertical_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionProgressVertical_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionProgressVertical* ret = cocos2d::TransitionProgressVertical::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionProgressVertical>((cocos2d::TransitionProgressVertical*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionProgressVertical_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionProgressVertical() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionProgressVertical",rb_get_class_value("cocos2d::TransitionProgress"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionProgressVertical_create));

	


	TypeTest<cocos2d::TransitionProgressVertical> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionProgressVertical",classValue);
}
RBVAL rb_cocos2dx_TransitionProgressInOut_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionProgressInOut_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionProgressInOut* ret = cocos2d::TransitionProgressInOut::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionProgressInOut>((cocos2d::TransitionProgressInOut*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionProgressInOut_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionProgressInOut() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionProgressInOut",rb_get_class_value("cocos2d::TransitionProgress"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionProgressInOut_create));

	


	TypeTest<cocos2d::TransitionProgressInOut> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionProgressInOut",classValue);
}
RBVAL rb_cocos2dx_TransitionProgressOutIn_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		float arg0;
		cocos2d::Scene* arg1;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TransitionProgressOutIn_create : Error processing arguments");return RBNil();}
		cocos2d::TransitionProgressOutIn* ret = cocos2d::TransitionProgressOutIn::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::TransitionProgressOutIn>((cocos2d::TransitionProgressOutIn*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_TransitionProgressOutIn_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TransitionProgressOutIn() {
		
	RBVAL classValue=rb_define_class_bridge("TransitionProgressOutIn",rb_get_class_value("cocos2d::TransitionProgress"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TransitionProgressOutIn_create));

	


	TypeTest<cocos2d::TransitionProgressOutIn> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TransitionProgressOutIn",classValue);
}
RBVAL rb_cocos2dx_MenuItem_setEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItem_setEnabled : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItem_setEnabled : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEnabled(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("enabled");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItem_setEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItem_activate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItem_activate : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->activate();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItem_activate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItem_isEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItem_isEnabled : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isEnabled();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItem_isEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItem_selected(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItem_selected : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->selected();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItem_selected : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItem_isSelected(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItem_isSelected : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isSelected();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItem_isSelected : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItem_unselected(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItem_unselected : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->unselected();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItem_unselected : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItem_rect(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItem_rect : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Rect ret = cobj->rect();
				value = ccrect_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItem_rect : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_MenuItem() {
		
	RBVAL classValue=rb_define_class_bridge("MenuItem",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"setEnabled",RB_FUNC(rb_cocos2dx_MenuItem_setEnabled));

    rb_define_method_bridge(classValue,"enabled=",RB_FUNC(rb_cocos2dx_MenuItem_setEnabled));
	

	rb_define_method_bridge(classValue,"activate",RB_FUNC(rb_cocos2dx_MenuItem_activate));

	

	rb_define_method_bridge(classValue,"isEnabled",RB_FUNC(rb_cocos2dx_MenuItem_isEnabled));

	

	rb_define_method_bridge(classValue,"selected",RB_FUNC(rb_cocos2dx_MenuItem_selected));

	

	rb_define_method_bridge(classValue,"isSelected",RB_FUNC(rb_cocos2dx_MenuItem_isSelected));

	

	rb_define_method_bridge(classValue,"unselected",RB_FUNC(rb_cocos2dx_MenuItem_unselected));

	

	rb_define_method_bridge(classValue,"rect",RB_FUNC(rb_cocos2dx_MenuItem_rect));

	



	TypeTest<cocos2d::MenuItem> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::MenuItem",classValue);
}
RBVAL rb_cocos2dx_MenuItemLabel_getDisabledColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemLabel* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemLabel_getDisabledColor : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Color3B& ret = cobj->getDisabledColor();
				value = cccolor3b_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemLabel_getDisabledColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemLabel_setString(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemLabel* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemLabel_setString : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemLabel_setString : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setString(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("string");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemLabel_setString : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemLabel_setLabel(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemLabel* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemLabel_setLabel : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemLabel_setLabel : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setLabel(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("label");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemLabel_setLabel : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemLabel_setDisabledColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemLabel* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemLabel_setDisabledColor : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Color3B arg0;
			ok &= rb_value_to_cccolor3b(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemLabel_setDisabledColor : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDisabledColor(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("disabledColor");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemLabel_setDisabledColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemLabel_getLabel(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemLabel* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemLabel_getLabel : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Node* ret = cobj->getLabel();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemLabel_getLabel : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_MenuItemLabel() {
		
	RBVAL classValue=rb_define_class_bridge("MenuItemLabel",rb_get_class_value("cocos2d::MenuItem"),true);

	rb_define_method_bridge(classValue,"getDisabledColor",RB_FUNC(rb_cocos2dx_MenuItemLabel_getDisabledColor));

   rb_define_method_bridge(classValue,"disabledColor",RB_FUNC(rb_cocos2dx_MenuItemLabel_getDisabledColor));
	

	rb_define_method_bridge(classValue,"setString",RB_FUNC(rb_cocos2dx_MenuItemLabel_setString));

    rb_define_method_bridge(classValue,"string=",RB_FUNC(rb_cocos2dx_MenuItemLabel_setString));
	

	rb_define_method_bridge(classValue,"setLabel",RB_FUNC(rb_cocos2dx_MenuItemLabel_setLabel));

    rb_define_method_bridge(classValue,"label=",RB_FUNC(rb_cocos2dx_MenuItemLabel_setLabel));
	

	rb_define_method_bridge(classValue,"setDisabledColor",RB_FUNC(rb_cocos2dx_MenuItemLabel_setDisabledColor));

    rb_define_method_bridge(classValue,"disabledColor=",RB_FUNC(rb_cocos2dx_MenuItemLabel_setDisabledColor));
	

	rb_define_method_bridge(classValue,"getLabel",RB_FUNC(rb_cocos2dx_MenuItemLabel_getLabel));

   rb_define_method_bridge(classValue,"label",RB_FUNC(rb_cocos2dx_MenuItemLabel_getLabel));
	



	TypeTest<cocos2d::MenuItemLabel> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::MenuItemLabel",classValue);
}


void rb_register_cocos2dx_MenuItemAtlasFont() {
		
	RBVAL classValue=rb_define_class_bridge("MenuItemAtlasFont",rb_get_class_value("cocos2d::MenuItemLabel"),true);



	TypeTest<cocos2d::MenuItemAtlasFont> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::MenuItemAtlasFont",classValue);
}
RBVAL rb_cocos2dx_MenuItemFont_getFontSizeObj(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemFont* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemFont_getFontSizeObj : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getFontSizeObj();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemFont_getFontSizeObj : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemFont_getFontNameObj(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemFont* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemFont_getFontNameObj : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const std::string& ret = cobj->getFontNameObj();
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemFont_getFontNameObj : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemFont_setFontSizeObj(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemFont* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemFont_setFontSizeObj : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemFont_setFontSizeObj : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setFontSizeObj(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("fontSizeObj");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemFont_setFontSizeObj : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemFont_setFontNameObj(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemFont* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemFont_setFontNameObj : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemFont_setFontNameObj : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setFontNameObj(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("fontNameObj");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemFont_setFontNameObj : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemFont_setFontName(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		std::string arg0;
		ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemFont_setFontName : Error processing arguments");return RBNil();}
		cocos2d::MenuItemFont::setFontName(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("fontName");
				}
				rb_cvar_set_bridge(clazz,propSYM,argv[0]);
		RBVAL value=RBNil();
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_MenuItemFont_setFontName : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_MenuItemFont_getFontSize(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		int ret = cocos2d::MenuItemFont::getFontSize();
		RBVAL value=RBNil();
		value = int_to_rb_value(ret);
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_MenuItemFont_getFontSize : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_MenuItemFont_getFontName(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		const std::string& ret = cocos2d::MenuItemFont::getFontName();
		RBVAL value=RBNil();
		value = std_string_to_rb_value(ret);
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_MenuItemFont_getFontName : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_MenuItemFont_setFontSize(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		int arg0;
		ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemFont_setFontSize : Error processing arguments");return RBNil();}
		cocos2d::MenuItemFont::setFontSize(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("fontSize");
				}
				rb_cvar_set_bridge(clazz,propSYM,argv[0]);
		RBVAL value=RBNil();
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_MenuItemFont_setFontSize : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_MenuItemFont() {
		
	RBVAL classValue=rb_define_class_bridge("MenuItemFont",rb_get_class_value("cocos2d::MenuItemLabel"),true);

	rb_define_method_bridge(classValue,"getFontSizeObj",RB_FUNC(rb_cocos2dx_MenuItemFont_getFontSizeObj));

   rb_define_method_bridge(classValue,"fontSizeObj",RB_FUNC(rb_cocos2dx_MenuItemFont_getFontSizeObj));
	

	rb_define_method_bridge(classValue,"getFontNameObj",RB_FUNC(rb_cocos2dx_MenuItemFont_getFontNameObj));

   rb_define_method_bridge(classValue,"fontNameObj",RB_FUNC(rb_cocos2dx_MenuItemFont_getFontNameObj));
	

	rb_define_method_bridge(classValue,"setFontSizeObj",RB_FUNC(rb_cocos2dx_MenuItemFont_setFontSizeObj));

    rb_define_method_bridge(classValue,"fontSizeObj=",RB_FUNC(rb_cocos2dx_MenuItemFont_setFontSizeObj));
	

	rb_define_method_bridge(classValue,"setFontNameObj",RB_FUNC(rb_cocos2dx_MenuItemFont_setFontNameObj));

    rb_define_method_bridge(classValue,"fontNameObj=",RB_FUNC(rb_cocos2dx_MenuItemFont_setFontNameObj));
	

	

	rb_define_singleton_method_bridge(classValue,"setFontName",RB_FUNC(rb_cocos2dx_MenuItemFont_setFontName));

    rb_define_singleton_method_bridge(classValue,"fontName=",RB_FUNC(rb_cocos2dx_MenuItemFont_setFontName));
	
	

	rb_define_singleton_method_bridge(classValue,"getFontSize",RB_FUNC(rb_cocos2dx_MenuItemFont_getFontSize));

   rb_define_singleton_method_bridge(classValue,"fontSize",RB_FUNC(rb_cocos2dx_MenuItemFont_getFontSize));
	
	

	rb_define_singleton_method_bridge(classValue,"getFontName",RB_FUNC(rb_cocos2dx_MenuItemFont_getFontName));

   rb_define_singleton_method_bridge(classValue,"fontName",RB_FUNC(rb_cocos2dx_MenuItemFont_getFontName));
	
	

	rb_define_singleton_method_bridge(classValue,"setFontSize",RB_FUNC(rb_cocos2dx_MenuItemFont_setFontSize));

    rb_define_singleton_method_bridge(classValue,"fontSize=",RB_FUNC(rb_cocos2dx_MenuItemFont_setFontSize));
	


	TypeTest<cocos2d::MenuItemFont> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::MenuItemFont",classValue);
}
RBVAL rb_cocos2dx_MenuItemSprite_setEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemSprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_setEnabled : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_setEnabled : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEnabled(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("enabled");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_setEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemSprite_selected(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemSprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_selected : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->selected();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_selected : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemSprite_setNormalImage(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemSprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_setNormalImage : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_setNormalImage : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setNormalImage(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("normalImage");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_setNormalImage : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemSprite_setDisabledImage(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemSprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_setDisabledImage : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_setDisabledImage : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDisabledImage(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("disabledImage");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_setDisabledImage : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemSprite_setSelectedImage(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemSprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_setSelectedImage : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_setSelectedImage : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setSelectedImage(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("selectedImage");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_setSelectedImage : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemSprite_getDisabledImage(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemSprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_getDisabledImage : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Node* ret = cobj->getDisabledImage();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_getDisabledImage : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemSprite_getSelectedImage(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemSprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_getSelectedImage : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Node* ret = cobj->getSelectedImage();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_getSelectedImage : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemSprite_getNormalImage(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemSprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_getNormalImage : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Node* ret = cobj->getNormalImage();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_getNormalImage : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemSprite_unselected(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemSprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_unselected : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->unselected();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemSprite_unselected : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_MenuItemSprite() {
		
	RBVAL classValue=rb_define_class_bridge("MenuItemSprite",rb_get_class_value("cocos2d::MenuItem"),true);

	rb_define_method_bridge(classValue,"setEnabled",RB_FUNC(rb_cocos2dx_MenuItemSprite_setEnabled));

    rb_define_method_bridge(classValue,"enabled=",RB_FUNC(rb_cocos2dx_MenuItemSprite_setEnabled));
	

	rb_define_method_bridge(classValue,"selected",RB_FUNC(rb_cocos2dx_MenuItemSprite_selected));

	

	rb_define_method_bridge(classValue,"setNormalImage",RB_FUNC(rb_cocos2dx_MenuItemSprite_setNormalImage));

    rb_define_method_bridge(classValue,"normalImage=",RB_FUNC(rb_cocos2dx_MenuItemSprite_setNormalImage));
	

	rb_define_method_bridge(classValue,"setDisabledImage",RB_FUNC(rb_cocos2dx_MenuItemSprite_setDisabledImage));

    rb_define_method_bridge(classValue,"disabledImage=",RB_FUNC(rb_cocos2dx_MenuItemSprite_setDisabledImage));
	

	rb_define_method_bridge(classValue,"setSelectedImage",RB_FUNC(rb_cocos2dx_MenuItemSprite_setSelectedImage));

    rb_define_method_bridge(classValue,"selectedImage=",RB_FUNC(rb_cocos2dx_MenuItemSprite_setSelectedImage));
	

	rb_define_method_bridge(classValue,"getDisabledImage",RB_FUNC(rb_cocos2dx_MenuItemSprite_getDisabledImage));

   rb_define_method_bridge(classValue,"disabledImage",RB_FUNC(rb_cocos2dx_MenuItemSprite_getDisabledImage));
	

	rb_define_method_bridge(classValue,"getSelectedImage",RB_FUNC(rb_cocos2dx_MenuItemSprite_getSelectedImage));

   rb_define_method_bridge(classValue,"selectedImage",RB_FUNC(rb_cocos2dx_MenuItemSprite_getSelectedImage));
	

	rb_define_method_bridge(classValue,"getNormalImage",RB_FUNC(rb_cocos2dx_MenuItemSprite_getNormalImage));

   rb_define_method_bridge(classValue,"normalImage",RB_FUNC(rb_cocos2dx_MenuItemSprite_getNormalImage));
	

	rb_define_method_bridge(classValue,"unselected",RB_FUNC(rb_cocos2dx_MenuItemSprite_unselected));

	



	TypeTest<cocos2d::MenuItemSprite> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::MenuItemSprite",classValue);
}
RBVAL rb_cocos2dx_MenuItemImage_setDisabledSpriteFrame(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemImage* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemImage_setDisabledSpriteFrame : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::SpriteFrame* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemImage_setDisabledSpriteFrame : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDisabledSpriteFrame(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("disabledSpriteFrame");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemImage_setDisabledSpriteFrame : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemImage_setSelectedSpriteFrame(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemImage* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemImage_setSelectedSpriteFrame : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::SpriteFrame* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemImage_setSelectedSpriteFrame : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setSelectedSpriteFrame(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("selectedSpriteFrame");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemImage_setSelectedSpriteFrame : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemImage_setNormalSpriteFrame(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemImage* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemImage_setNormalSpriteFrame : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::SpriteFrame* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemImage_setNormalSpriteFrame : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setNormalSpriteFrame(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("normalSpriteFrame");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemImage_setNormalSpriteFrame : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_MenuItemImage() {
		
	RBVAL classValue=rb_define_class_bridge("MenuItemImage",rb_get_class_value("cocos2d::MenuItemSprite"),true);

	rb_define_method_bridge(classValue,"setDisabledSpriteFrame",RB_FUNC(rb_cocos2dx_MenuItemImage_setDisabledSpriteFrame));

    rb_define_method_bridge(classValue,"disabledSpriteFrame=",RB_FUNC(rb_cocos2dx_MenuItemImage_setDisabledSpriteFrame));
	

	rb_define_method_bridge(classValue,"setSelectedSpriteFrame",RB_FUNC(rb_cocos2dx_MenuItemImage_setSelectedSpriteFrame));

    rb_define_method_bridge(classValue,"selectedSpriteFrame=",RB_FUNC(rb_cocos2dx_MenuItemImage_setSelectedSpriteFrame));
	

	rb_define_method_bridge(classValue,"setNormalSpriteFrame",RB_FUNC(rb_cocos2dx_MenuItemImage_setNormalSpriteFrame));

    rb_define_method_bridge(classValue,"normalSpriteFrame=",RB_FUNC(rb_cocos2dx_MenuItemImage_setNormalSpriteFrame));
	



	TypeTest<cocos2d::MenuItemImage> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::MenuItemImage",classValue);
}
RBVAL rb_cocos2dx_MenuItemToggle_setSubItems(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemToggle* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemToggle_setSubItems : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vector<cocos2d::MenuItem *> arg0;
			ok &= rb_value_to_ccvector(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemToggle_setSubItems : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setSubItems(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("subItems");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemToggle_setSubItems : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemToggle_getSelectedIndex(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemToggle* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemToggle_getSelectedIndex : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					unsigned int ret = cobj->getSelectedIndex();
				value = uint_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemToggle_getSelectedIndex : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemToggle_addSubItem(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemToggle* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemToggle_addSubItem : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::MenuItem* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemToggle_addSubItem : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addSubItem(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemToggle_addSubItem : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemToggle_getSelectedItem(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemToggle* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemToggle_getSelectedItem : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::MenuItem* ret = cobj->getSelectedItem();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::MenuItem>((cocos2d::MenuItem*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemToggle_getSelectedItem : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MenuItemToggle_setSelectedIndex(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MenuItemToggle* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemToggle_setSelectedIndex : self ptr is null");return RBNil();}
		if (argc == 1) {
			unsigned int arg0;
			ok &= rb_value_to_uint(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MenuItemToggle_setSelectedIndex : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setSelectedIndex(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("selectedIndex");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MenuItemToggle_setSelectedIndex : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_MenuItemToggle() {
		
	RBVAL classValue=rb_define_class_bridge("MenuItemToggle",rb_get_class_value("cocos2d::MenuItem"),true);

	rb_define_method_bridge(classValue,"setSubItems",RB_FUNC(rb_cocos2dx_MenuItemToggle_setSubItems));

    rb_define_method_bridge(classValue,"subItems=",RB_FUNC(rb_cocos2dx_MenuItemToggle_setSubItems));
	

	rb_define_method_bridge(classValue,"getSelectedIndex",RB_FUNC(rb_cocos2dx_MenuItemToggle_getSelectedIndex));

   rb_define_method_bridge(classValue,"selectedIndex",RB_FUNC(rb_cocos2dx_MenuItemToggle_getSelectedIndex));
	

	rb_define_method_bridge(classValue,"addSubItem",RB_FUNC(rb_cocos2dx_MenuItemToggle_addSubItem));

	

	rb_define_method_bridge(classValue,"getSelectedItem",RB_FUNC(rb_cocos2dx_MenuItemToggle_getSelectedItem));

   rb_define_method_bridge(classValue,"selectedItem",RB_FUNC(rb_cocos2dx_MenuItemToggle_getSelectedItem));
	

	rb_define_method_bridge(classValue,"setSelectedIndex",RB_FUNC(rb_cocos2dx_MenuItemToggle_setSelectedIndex));

    rb_define_method_bridge(classValue,"selectedIndex=",RB_FUNC(rb_cocos2dx_MenuItemToggle_setSelectedIndex));
	



	TypeTest<cocos2d::MenuItemToggle> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::MenuItemToggle",classValue);
}
RBVAL rb_cocos2dx_Menu_setEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Menu* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Menu_setEnabled : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Menu_setEnabled : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEnabled(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("enabled");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Menu_setEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Menu_alignItemsVertically(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Menu* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Menu_alignItemsVertically : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->alignItemsVertically();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Menu_alignItemsVertically : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Menu_isEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Menu* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Menu_isEnabled : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isEnabled();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Menu_isEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Menu_alignItemsHorizontally(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Menu* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Menu_alignItemsHorizontally : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->alignItemsHorizontally();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Menu_alignItemsHorizontally : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Menu_alignItemsHorizontallyWithPadding(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Menu* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Menu_alignItemsHorizontallyWithPadding : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Menu_alignItemsHorizontallyWithPadding : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->alignItemsHorizontallyWithPadding(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Menu_alignItemsHorizontallyWithPadding : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Menu_alignItemsVerticallyWithPadding(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Menu* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Menu_alignItemsVerticallyWithPadding : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Menu_alignItemsVerticallyWithPadding : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->alignItemsVerticallyWithPadding(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Menu_alignItemsVerticallyWithPadding : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_Menu() {
		
	RBVAL classValue=rb_define_class_bridge("Menu",rb_get_class_value("cocos2d::Layer"),true);

	rb_define_method_bridge(classValue,"setEnabled",RB_FUNC(rb_cocos2dx_Menu_setEnabled));

    rb_define_method_bridge(classValue,"enabled=",RB_FUNC(rb_cocos2dx_Menu_setEnabled));
	

	rb_define_method_bridge(classValue,"alignItemsVertically",RB_FUNC(rb_cocos2dx_Menu_alignItemsVertically));

	

	rb_define_method_bridge(classValue,"isEnabled",RB_FUNC(rb_cocos2dx_Menu_isEnabled));

	

	rb_define_method_bridge(classValue,"alignItemsHorizontally",RB_FUNC(rb_cocos2dx_Menu_alignItemsHorizontally));

	

	rb_define_method_bridge(classValue,"alignItemsHorizontallyWithPadding",RB_FUNC(rb_cocos2dx_Menu_alignItemsHorizontallyWithPadding));

	

	rb_define_method_bridge(classValue,"alignItemsVerticallyWithPadding",RB_FUNC(rb_cocos2dx_Menu_alignItemsVerticallyWithPadding));

	



	TypeTest<cocos2d::Menu> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Menu",classValue);
}
RBVAL rb_cocos2dx_ClippingNode_hasContent(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ClippingNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ClippingNode_hasContent : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->hasContent();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ClippingNode_hasContent : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ClippingNode_setInverted(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ClippingNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ClippingNode_setInverted : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ClippingNode_setInverted : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setInverted(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("inverted");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ClippingNode_setInverted : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ClippingNode_setStencil(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ClippingNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ClippingNode_setStencil : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ClippingNode_setStencil : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setStencil(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("stencil");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ClippingNode_setStencil : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ClippingNode_getAlphaThreshold(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ClippingNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ClippingNode_getAlphaThreshold : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAlphaThreshold();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ClippingNode_getAlphaThreshold : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ClippingNode_getStencil(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ClippingNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ClippingNode_getStencil : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Node* ret = cobj->getStencil();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ClippingNode_getStencil : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ClippingNode_setAlphaThreshold(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ClippingNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ClippingNode_setAlphaThreshold : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ClippingNode_setAlphaThreshold : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAlphaThreshold(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("alphaThreshold");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ClippingNode_setAlphaThreshold : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ClippingNode_isInverted(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ClippingNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ClippingNode_isInverted : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isInverted();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ClippingNode_isInverted : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ClippingNode_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) { break; }
			cocos2d::ClippingNode* ret = cocos2d::ClippingNode::create(arg0);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::ClippingNode>((cocos2d::ClippingNode*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 0) {
			cocos2d::ClippingNode* ret = cocos2d::ClippingNode::create();
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::ClippingNode>((cocos2d::ClippingNode*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_ClippingNode_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_ClippingNode() {
		
	RBVAL classValue=rb_define_class_bridge("ClippingNode",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"hasContent",RB_FUNC(rb_cocos2dx_ClippingNode_hasContent));

	

	rb_define_method_bridge(classValue,"setInverted",RB_FUNC(rb_cocos2dx_ClippingNode_setInverted));

    rb_define_method_bridge(classValue,"inverted=",RB_FUNC(rb_cocos2dx_ClippingNode_setInverted));
	

	rb_define_method_bridge(classValue,"setStencil",RB_FUNC(rb_cocos2dx_ClippingNode_setStencil));

    rb_define_method_bridge(classValue,"stencil=",RB_FUNC(rb_cocos2dx_ClippingNode_setStencil));
	

	rb_define_method_bridge(classValue,"getAlphaThreshold",RB_FUNC(rb_cocos2dx_ClippingNode_getAlphaThreshold));

   rb_define_method_bridge(classValue,"alphaThreshold",RB_FUNC(rb_cocos2dx_ClippingNode_getAlphaThreshold));
	

	rb_define_method_bridge(classValue,"getStencil",RB_FUNC(rb_cocos2dx_ClippingNode_getStencil));

   rb_define_method_bridge(classValue,"stencil",RB_FUNC(rb_cocos2dx_ClippingNode_getStencil));
	

	rb_define_method_bridge(classValue,"setAlphaThreshold",RB_FUNC(rb_cocos2dx_ClippingNode_setAlphaThreshold));

    rb_define_method_bridge(classValue,"alphaThreshold=",RB_FUNC(rb_cocos2dx_ClippingNode_setAlphaThreshold));
	

	rb_define_method_bridge(classValue,"isInverted",RB_FUNC(rb_cocos2dx_ClippingNode_isInverted));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ClippingNode_create));

	


	TypeTest<cocos2d::ClippingNode> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ClippingNode",classValue);
}
RBVAL rb_cocos2dx_ClippingRectangleNode_isClippingEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ClippingRectangleNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ClippingRectangleNode_isClippingEnabled : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const bool ret = cobj->isClippingEnabled();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ClippingRectangleNode_isClippingEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ClippingRectangleNode_setClippingEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ClippingRectangleNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ClippingRectangleNode_setClippingEnabled : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ClippingRectangleNode_setClippingEnabled : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setClippingEnabled(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("clippingEnabled");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ClippingRectangleNode_setClippingEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ClippingRectangleNode_getClippingRegion(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ClippingRectangleNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ClippingRectangleNode_getClippingRegion : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Rect& ret = cobj->getClippingRegion();
				value = ccrect_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ClippingRectangleNode_getClippingRegion : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ClippingRectangleNode_setClippingRegion(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ClippingRectangleNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ClippingRectangleNode_setClippingRegion : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Rect arg0;
			ok &= rb_value_to_ccrect(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ClippingRectangleNode_setClippingRegion : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setClippingRegion(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("clippingRegion");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ClippingRectangleNode_setClippingRegion : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ClippingRectangleNode_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 0) {
			cocos2d::ClippingRectangleNode* ret = cocos2d::ClippingRectangleNode::create();
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::ClippingRectangleNode>((cocos2d::ClippingRectangleNode*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 1) {
			cocos2d::Rect arg0;
			ok &= rb_value_to_ccrect(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::ClippingRectangleNode* ret = cocos2d::ClippingRectangleNode::create(arg0);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::ClippingRectangleNode>((cocos2d::ClippingRectangleNode*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_ClippingRectangleNode_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_ClippingRectangleNode() {
		
	RBVAL classValue=rb_define_class_bridge("ClippingRectangleNode",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"isClippingEnabled",RB_FUNC(rb_cocos2dx_ClippingRectangleNode_isClippingEnabled));

	

	rb_define_method_bridge(classValue,"setClippingEnabled",RB_FUNC(rb_cocos2dx_ClippingRectangleNode_setClippingEnabled));

    rb_define_method_bridge(classValue,"clippingEnabled=",RB_FUNC(rb_cocos2dx_ClippingRectangleNode_setClippingEnabled));
	

	rb_define_method_bridge(classValue,"getClippingRegion",RB_FUNC(rb_cocos2dx_ClippingRectangleNode_getClippingRegion));

   rb_define_method_bridge(classValue,"clippingRegion",RB_FUNC(rb_cocos2dx_ClippingRectangleNode_getClippingRegion));
	

	rb_define_method_bridge(classValue,"setClippingRegion",RB_FUNC(rb_cocos2dx_ClippingRectangleNode_setClippingRegion));

    rb_define_method_bridge(classValue,"clippingRegion=",RB_FUNC(rb_cocos2dx_ClippingRectangleNode_setClippingRegion));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ClippingRectangleNode_create));

	


	TypeTest<cocos2d::ClippingRectangleNode> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ClippingRectangleNode",classValue);
}
RBVAL rb_cocos2dx_MotionStreak_reset(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MotionStreak* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MotionStreak_reset : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->reset();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MotionStreak_reset : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MotionStreak_setTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MotionStreak* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MotionStreak_setTexture : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Texture2D* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MotionStreak_setTexture : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTexture(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("texture");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MotionStreak_setTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MotionStreak_getTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MotionStreak* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MotionStreak_getTexture : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Texture2D* ret = cobj->getTexture();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Texture2D>((cocos2d::Texture2D*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MotionStreak_getTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MotionStreak_tintWithColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MotionStreak* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MotionStreak_tintWithColor : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Color3B arg0;
			ok &= rb_value_to_cccolor3b(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MotionStreak_tintWithColor : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->tintWithColor(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MotionStreak_tintWithColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MotionStreak_setStartingPositionInitialized(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MotionStreak* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MotionStreak_setStartingPositionInitialized : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MotionStreak_setStartingPositionInitialized : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setStartingPositionInitialized(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("startingPositionInitialized");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MotionStreak_setStartingPositionInitialized : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MotionStreak_isStartingPositionInitialized(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MotionStreak* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MotionStreak_isStartingPositionInitialized : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isStartingPositionInitialized();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MotionStreak_isStartingPositionInitialized : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MotionStreak_isFastMode(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MotionStreak* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MotionStreak_isFastMode : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isFastMode();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MotionStreak_isFastMode : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MotionStreak_setFastMode(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::MotionStreak* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_MotionStreak_setFastMode : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_MotionStreak_setFastMode : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setFastMode(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("fastMode");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_MotionStreak_setFastMode : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_MotionStreak_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 5) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::Color3B arg3;
			ok &= rb_value_to_cccolor3b(argv[3], &arg3);
			if (!ok) { break; }
			cocos2d::Texture2D* arg4;
			ok &= rb_value_get_ptr(argv[4],&arg4);
			if (!ok) { break; }
			cocos2d::MotionStreak* ret = cocos2d::MotionStreak::create(arg0, arg1, arg2, arg3, arg4);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::MotionStreak>((cocos2d::MotionStreak*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 5) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) { break; }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) { break; }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::Color3B arg3;
			ok &= rb_value_to_cccolor3b(argv[3], &arg3);
			if (!ok) { break; }
			std::string arg4;
			ok &= rb_value_to_std_string(argv[4], &arg4);
			if (!ok) { break; }
			cocos2d::MotionStreak* ret = cocos2d::MotionStreak::create(arg0, arg1, arg2, arg3, arg4);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::MotionStreak>((cocos2d::MotionStreak*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_MotionStreak_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_MotionStreak() {
		
	RBVAL classValue=rb_define_class_bridge("MotionStreak",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"reset",RB_FUNC(rb_cocos2dx_MotionStreak_reset));

	

	rb_define_method_bridge(classValue,"setTexture",RB_FUNC(rb_cocos2dx_MotionStreak_setTexture));

    rb_define_method_bridge(classValue,"texture=",RB_FUNC(rb_cocos2dx_MotionStreak_setTexture));
	

	rb_define_method_bridge(classValue,"getTexture",RB_FUNC(rb_cocos2dx_MotionStreak_getTexture));

   rb_define_method_bridge(classValue,"texture",RB_FUNC(rb_cocos2dx_MotionStreak_getTexture));
	

	rb_define_method_bridge(classValue,"tintWithColor",RB_FUNC(rb_cocos2dx_MotionStreak_tintWithColor));

	

	rb_define_method_bridge(classValue,"setStartingPositionInitialized",RB_FUNC(rb_cocos2dx_MotionStreak_setStartingPositionInitialized));

    rb_define_method_bridge(classValue,"startingPositionInitialized=",RB_FUNC(rb_cocos2dx_MotionStreak_setStartingPositionInitialized));
	

	rb_define_method_bridge(classValue,"isStartingPositionInitialized",RB_FUNC(rb_cocos2dx_MotionStreak_isStartingPositionInitialized));

	

	rb_define_method_bridge(classValue,"isFastMode",RB_FUNC(rb_cocos2dx_MotionStreak_isFastMode));

	

	rb_define_method_bridge(classValue,"setFastMode",RB_FUNC(rb_cocos2dx_MotionStreak_setFastMode));

    rb_define_method_bridge(classValue,"fastMode=",RB_FUNC(rb_cocos2dx_MotionStreak_setFastMode));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_MotionStreak_create));

	


	TypeTest<cocos2d::MotionStreak> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::MotionStreak",classValue);
}
RBVAL rb_cocos2dx_ProgressTimer_isReverseDirection(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProgressTimer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_isReverseDirection : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isReverseDirection();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProgressTimer_isReverseDirection : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProgressTimer_setBarChangeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProgressTimer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setBarChangeRate : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setBarChangeRate : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setBarChangeRate(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("barChangeRate");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setBarChangeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProgressTimer_getPercentage(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProgressTimer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_getPercentage : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getPercentage();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProgressTimer_getPercentage : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProgressTimer_setSprite(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProgressTimer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setSprite : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Sprite* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setSprite : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setSprite(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("sprite");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setSprite : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProgressTimer_getType(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProgressTimer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_getType : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getType();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProgressTimer_getType : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProgressTimer_getSprite(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProgressTimer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_getSprite : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Sprite* ret = cobj->getSprite();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Sprite>((cocos2d::Sprite*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProgressTimer_getSprite : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProgressTimer_setMidpoint(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProgressTimer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setMidpoint : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setMidpoint : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setMidpoint(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("midpoint");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setMidpoint : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProgressTimer_getBarChangeRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProgressTimer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_getBarChangeRate : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getBarChangeRate();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProgressTimer_getBarChangeRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProgressTimer_setReverseDirection(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::ProgressTimer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setReverseDirection : self ptr is null");return RBNil();}
	do {
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setReverseDirection : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->setReverseDirection(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("reverseDirection");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setReverseDirection : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->setReverseProgress(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("reverseDirection");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setReverseDirection : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProgressTimer_getMidpoint(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProgressTimer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_getMidpoint : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec2 ret = cobj->getMidpoint();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProgressTimer_getMidpoint : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProgressTimer_setPercentage(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProgressTimer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setPercentage : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setPercentage : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setPercentage(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("percentage");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setPercentage : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProgressTimer_setType(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ProgressTimer* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setType : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ProgressTimer::Type arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setType : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setType(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("type");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ProgressTimer_setType : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ProgressTimer_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::Sprite* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ProgressTimer_create : Error processing arguments");return RBNil();}
		cocos2d::ProgressTimer* ret = cocos2d::ProgressTimer::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ProgressTimer>((cocos2d::ProgressTimer*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ProgressTimer_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ProgressTimer() {
		
	RBVAL classValue=rb_define_class_bridge("ProgressTimer",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"isReverseDirection",RB_FUNC(rb_cocos2dx_ProgressTimer_isReverseDirection));

	

	rb_define_method_bridge(classValue,"setBarChangeRate",RB_FUNC(rb_cocos2dx_ProgressTimer_setBarChangeRate));

    rb_define_method_bridge(classValue,"barChangeRate=",RB_FUNC(rb_cocos2dx_ProgressTimer_setBarChangeRate));
	

	rb_define_method_bridge(classValue,"getPercentage",RB_FUNC(rb_cocos2dx_ProgressTimer_getPercentage));

   rb_define_method_bridge(classValue,"percentage",RB_FUNC(rb_cocos2dx_ProgressTimer_getPercentage));
	

	rb_define_method_bridge(classValue,"setSprite",RB_FUNC(rb_cocos2dx_ProgressTimer_setSprite));

    rb_define_method_bridge(classValue,"sprite=",RB_FUNC(rb_cocos2dx_ProgressTimer_setSprite));
	

	rb_define_method_bridge(classValue,"getType",RB_FUNC(rb_cocos2dx_ProgressTimer_getType));

   rb_define_method_bridge(classValue,"type",RB_FUNC(rb_cocos2dx_ProgressTimer_getType));
	

	rb_define_method_bridge(classValue,"getSprite",RB_FUNC(rb_cocos2dx_ProgressTimer_getSprite));

   rb_define_method_bridge(classValue,"sprite",RB_FUNC(rb_cocos2dx_ProgressTimer_getSprite));
	

	rb_define_method_bridge(classValue,"setMidpoint",RB_FUNC(rb_cocos2dx_ProgressTimer_setMidpoint));

    rb_define_method_bridge(classValue,"midpoint=",RB_FUNC(rb_cocos2dx_ProgressTimer_setMidpoint));
	

	rb_define_method_bridge(classValue,"getBarChangeRate",RB_FUNC(rb_cocos2dx_ProgressTimer_getBarChangeRate));

   rb_define_method_bridge(classValue,"barChangeRate",RB_FUNC(rb_cocos2dx_ProgressTimer_getBarChangeRate));
	

	rb_define_method_bridge(classValue,"setReverseDirection",RB_FUNC(rb_cocos2dx_ProgressTimer_setReverseDirection));

    rb_define_method_bridge(classValue,"reverseDirection=",RB_FUNC(rb_cocos2dx_ProgressTimer_setReverseDirection));
	

	rb_define_method_bridge(classValue,"getMidpoint",RB_FUNC(rb_cocos2dx_ProgressTimer_getMidpoint));

   rb_define_method_bridge(classValue,"midpoint",RB_FUNC(rb_cocos2dx_ProgressTimer_getMidpoint));
	

	rb_define_method_bridge(classValue,"setPercentage",RB_FUNC(rb_cocos2dx_ProgressTimer_setPercentage));

    rb_define_method_bridge(classValue,"percentage=",RB_FUNC(rb_cocos2dx_ProgressTimer_setPercentage));
	

	rb_define_method_bridge(classValue,"setType",RB_FUNC(rb_cocos2dx_ProgressTimer_setType));

    rb_define_method_bridge(classValue,"type=",RB_FUNC(rb_cocos2dx_ProgressTimer_setType));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ProgressTimer_create));

	


	TypeTest<cocos2d::ProgressTimer> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ProgressTimer",classValue);
}
RBVAL rb_cocos2dx_Sprite_setSpriteFrame(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setSpriteFrame : self ptr is null");return RBNil();}
	do {
		if (argc == 1) {
			cocos2d::SpriteFrame* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setSpriteFrame : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->setSpriteFrame(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("spriteFrame");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setSpriteFrame : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->setSpriteFrame(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("spriteFrame");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Sprite_setSpriteFrame : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_setTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setTexture : self ptr is null");return RBNil();}
	do {
		if (argc == 1) {
			cocos2d::Texture2D* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setTexture : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->setTexture(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("texture");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setTexture : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->setTexture(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("texture");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Sprite_setTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_getTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_getTexture : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Texture2D* ret = cobj->getTexture();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Texture2D>((cocos2d::Texture2D*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_getTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_setFlippedY(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setFlippedY : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setFlippedY : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setFlippedY(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("flippedY");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_setFlippedY : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_setFlippedX(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setFlippedX : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setFlippedX : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setFlippedX(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("flippedX");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_setFlippedX : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_getBatchNode(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_getBatchNode : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::SpriteBatchNode* ret = cobj->getBatchNode();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::SpriteBatchNode>((cocos2d::SpriteBatchNode*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_getBatchNode : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_getOffsetPosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_getOffsetPosition : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec2& ret = cobj->getOffsetPosition();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_getOffsetPosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_removeAllChildrenWithCleanup(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_removeAllChildrenWithCleanup : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_removeAllChildrenWithCleanup : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeAllChildrenWithCleanup(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_removeAllChildrenWithCleanup : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_updateTransform(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_updateTransform : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->updateTransform();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_updateTransform : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_setTextureRect(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setTextureRect : self ptr is null");return RBNil();}
	do {
		if (argc == 3) {
			cocos2d::Rect arg0;
			ok &= rb_value_to_ccrect(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setTextureRect : Error processing argument 1 ( 3 )");return RBNil(); }
			bool arg1;
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setTextureRect : Error processing argument 2 ( 3 )");return RBNil(); }
			cocos2d::Size arg2;
			ok &= rb_value_to_ccsize(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setTextureRect : Error processing argument 3 ( 3 )");return RBNil(); }
			cobj->setTextureRect(arg0, arg1, arg2);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 1) {
			cocos2d::Rect arg0;
			ok &= rb_value_to_ccrect(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setTextureRect : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->setTextureRect(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("textureRect");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_Sprite_setTextureRect : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_isFrameDisplayed(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_isFrameDisplayed : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::SpriteFrame* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_isFrameDisplayed : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->isFrameDisplayed(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_isFrameDisplayed : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_getAtlasIndex(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_getAtlasIndex : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					ssize_t ret = cobj->getAtlasIndex();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_getAtlasIndex : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_setBatchNode(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setBatchNode : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::SpriteBatchNode* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setBatchNode : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setBatchNode(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("batchNode");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_setBatchNode : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_setDisplayFrameWithAnimationName(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setDisplayFrameWithAnimationName : self ptr is null");return RBNil();}
		if (argc == 2) {
			std::string arg0;
			ssize_t arg1;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			ok &= rb_value_to_ssize_t(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setDisplayFrameWithAnimationName : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDisplayFrameWithAnimationName(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_setDisplayFrameWithAnimationName : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_setTextureAtlas(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setTextureAtlas : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::TextureAtlas* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setTextureAtlas : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTextureAtlas(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("textureAtlas");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_setTextureAtlas : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_getSpriteFrame(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_getSpriteFrame : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::SpriteFrame* ret = cobj->getSpriteFrame();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_getSpriteFrame : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_isDirty(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_isDirty : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isDirty();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_isDirty : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_setAtlasIndex(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setAtlasIndex : self ptr is null");return RBNil();}
		if (argc == 1) {
			ssize_t arg0;
			ok &= rb_value_to_ssize_t(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setAtlasIndex : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAtlasIndex(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("atlasIndex");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_setAtlasIndex : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_setDirty(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setDirty : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setDirty : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDirty(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("dirty");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_setDirty : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_isTextureRectRotated(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_isTextureRectRotated : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isTextureRectRotated();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_isTextureRectRotated : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_getTextureRect(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_getTextureRect : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Rect& ret = cobj->getTextureRect();
				value = ccrect_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_getTextureRect : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_getTextureAtlas(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_getTextureAtlas : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::TextureAtlas* ret = cobj->getTextureAtlas();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::TextureAtlas>((cocos2d::TextureAtlas*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_getTextureAtlas : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_isFlippedX(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_isFlippedX : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isFlippedX();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_isFlippedX : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_isFlippedY(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_isFlippedY : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isFlippedY();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_isFlippedY : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_setVertexRect(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Sprite* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setVertexRect : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Rect arg0;
			ok &= rb_value_to_ccrect(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_setVertexRect : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setVertexRect(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("vertexRect");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Sprite_setVertexRect : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Sprite* ret = cocos2d::Sprite::create(arg0);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::Sprite>((cocos2d::Sprite*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 0) {
			cocos2d::Sprite* ret = cocos2d::Sprite::create();
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::Sprite>((cocos2d::Sprite*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 2) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Rect arg1;
			ok &= rb_value_to_ccrect(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::Sprite* ret = cocos2d::Sprite::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::Sprite>((cocos2d::Sprite*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_Sprite_create : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_createWithTexture(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 2) {
			cocos2d::Texture2D* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) { break; }
			cocos2d::Rect arg1;
			ok &= rb_value_to_ccrect(argv[1], &arg1);
			if (!ok) { break; }
			cocos2d::Sprite* ret = cocos2d::Sprite::createWithTexture(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::Sprite>((cocos2d::Sprite*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	do {
		if (argc == 3) {
			cocos2d::Texture2D* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) { break; }
			cocos2d::Rect arg1;
			ok &= rb_value_to_ccrect(argv[1], &arg1);
			if (!ok) { break; }
			bool arg2;
			ok &= rb_value_to_bool(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::Sprite* ret = cocos2d::Sprite::createWithTexture(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::Sprite>((cocos2d::Sprite*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 1) {
			cocos2d::Texture2D* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) { break; }
			cocos2d::Sprite* ret = cocos2d::Sprite::createWithTexture(arg0);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::Sprite>((cocos2d::Sprite*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_Sprite_createWithTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Sprite_createWithSpriteFrameName(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		std::string arg0;
		ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_createWithSpriteFrameName : Error processing arguments");return RBNil();}
		cocos2d::Sprite* ret = cocos2d::Sprite::createWithSpriteFrameName(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Sprite>((cocos2d::Sprite*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Sprite_createWithSpriteFrameName : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_Sprite_createWithSpriteFrame(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::SpriteFrame* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Sprite_createWithSpriteFrame : Error processing arguments");return RBNil();}
		cocos2d::Sprite* ret = cocos2d::Sprite::createWithSpriteFrame(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Sprite>((cocos2d::Sprite*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Sprite_createWithSpriteFrame : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Sprite() {
		
	RBVAL classValue=rb_define_class_bridge("Sprite",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"setSpriteFrame",RB_FUNC(rb_cocos2dx_Sprite_setSpriteFrame));

    rb_define_method_bridge(classValue,"spriteFrame=",RB_FUNC(rb_cocos2dx_Sprite_setSpriteFrame));
	

	rb_define_method_bridge(classValue,"setTexture",RB_FUNC(rb_cocos2dx_Sprite_setTexture));

    rb_define_method_bridge(classValue,"texture=",RB_FUNC(rb_cocos2dx_Sprite_setTexture));
	

	rb_define_method_bridge(classValue,"getTexture",RB_FUNC(rb_cocos2dx_Sprite_getTexture));

   rb_define_method_bridge(classValue,"texture",RB_FUNC(rb_cocos2dx_Sprite_getTexture));
	

	rb_define_method_bridge(classValue,"setFlippedY",RB_FUNC(rb_cocos2dx_Sprite_setFlippedY));

    rb_define_method_bridge(classValue,"flippedY=",RB_FUNC(rb_cocos2dx_Sprite_setFlippedY));
	

	rb_define_method_bridge(classValue,"setFlippedX",RB_FUNC(rb_cocos2dx_Sprite_setFlippedX));

    rb_define_method_bridge(classValue,"flippedX=",RB_FUNC(rb_cocos2dx_Sprite_setFlippedX));
	

	rb_define_method_bridge(classValue,"getBatchNode",RB_FUNC(rb_cocos2dx_Sprite_getBatchNode));

   rb_define_method_bridge(classValue,"batchNode",RB_FUNC(rb_cocos2dx_Sprite_getBatchNode));
	

	rb_define_method_bridge(classValue,"getOffsetPosition",RB_FUNC(rb_cocos2dx_Sprite_getOffsetPosition));

   rb_define_method_bridge(classValue,"offsetPosition",RB_FUNC(rb_cocos2dx_Sprite_getOffsetPosition));
	

	rb_define_method_bridge(classValue,"removeAllChildrenWithCleanup",RB_FUNC(rb_cocos2dx_Sprite_removeAllChildrenWithCleanup));

	

	rb_define_method_bridge(classValue,"updateTransform",RB_FUNC(rb_cocos2dx_Sprite_updateTransform));

	

	rb_define_method_bridge(classValue,"setTextureRect",RB_FUNC(rb_cocos2dx_Sprite_setTextureRect));

    rb_define_method_bridge(classValue,"textureRect=",RB_FUNC(rb_cocos2dx_Sprite_setTextureRect));
	

	rb_define_method_bridge(classValue,"isFrameDisplayed",RB_FUNC(rb_cocos2dx_Sprite_isFrameDisplayed));

	

	rb_define_method_bridge(classValue,"getAtlasIndex",RB_FUNC(rb_cocos2dx_Sprite_getAtlasIndex));

   rb_define_method_bridge(classValue,"atlasIndex",RB_FUNC(rb_cocos2dx_Sprite_getAtlasIndex));
	

	rb_define_method_bridge(classValue,"setBatchNode",RB_FUNC(rb_cocos2dx_Sprite_setBatchNode));

    rb_define_method_bridge(classValue,"batchNode=",RB_FUNC(rb_cocos2dx_Sprite_setBatchNode));
	

	rb_define_method_bridge(classValue,"setDisplayFrameWithAnimationName",RB_FUNC(rb_cocos2dx_Sprite_setDisplayFrameWithAnimationName));

    rb_define_method_bridge(classValue,"displayFrameWithAnimationName=",RB_FUNC(rb_cocos2dx_Sprite_setDisplayFrameWithAnimationName));
	

	rb_define_method_bridge(classValue,"setTextureAtlas",RB_FUNC(rb_cocos2dx_Sprite_setTextureAtlas));

    rb_define_method_bridge(classValue,"textureAtlas=",RB_FUNC(rb_cocos2dx_Sprite_setTextureAtlas));
	

	rb_define_method_bridge(classValue,"getSpriteFrame",RB_FUNC(rb_cocos2dx_Sprite_getSpriteFrame));

   rb_define_method_bridge(classValue,"spriteFrame",RB_FUNC(rb_cocos2dx_Sprite_getSpriteFrame));
	

	rb_define_method_bridge(classValue,"isDirty",RB_FUNC(rb_cocos2dx_Sprite_isDirty));

	

	rb_define_method_bridge(classValue,"setAtlasIndex",RB_FUNC(rb_cocos2dx_Sprite_setAtlasIndex));

    rb_define_method_bridge(classValue,"atlasIndex=",RB_FUNC(rb_cocos2dx_Sprite_setAtlasIndex));
	

	rb_define_method_bridge(classValue,"setDirty",RB_FUNC(rb_cocos2dx_Sprite_setDirty));

    rb_define_method_bridge(classValue,"dirty=",RB_FUNC(rb_cocos2dx_Sprite_setDirty));
	

	rb_define_method_bridge(classValue,"isTextureRectRotated",RB_FUNC(rb_cocos2dx_Sprite_isTextureRectRotated));

	

	rb_define_method_bridge(classValue,"getTextureRect",RB_FUNC(rb_cocos2dx_Sprite_getTextureRect));

   rb_define_method_bridge(classValue,"textureRect",RB_FUNC(rb_cocos2dx_Sprite_getTextureRect));
	

	rb_define_method_bridge(classValue,"getTextureAtlas",RB_FUNC(rb_cocos2dx_Sprite_getTextureAtlas));

   rb_define_method_bridge(classValue,"textureAtlas",RB_FUNC(rb_cocos2dx_Sprite_getTextureAtlas));
	

	rb_define_method_bridge(classValue,"isFlippedX",RB_FUNC(rb_cocos2dx_Sprite_isFlippedX));

	

	rb_define_method_bridge(classValue,"isFlippedY",RB_FUNC(rb_cocos2dx_Sprite_isFlippedY));

	

	rb_define_method_bridge(classValue,"setVertexRect",RB_FUNC(rb_cocos2dx_Sprite_setVertexRect));

    rb_define_method_bridge(classValue,"vertexRect=",RB_FUNC(rb_cocos2dx_Sprite_setVertexRect));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Sprite_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTexture",RB_FUNC(rb_cocos2dx_Sprite_createWithTexture));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithSpriteFrameName",RB_FUNC(rb_cocos2dx_Sprite_createWithSpriteFrameName));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithSpriteFrame",RB_FUNC(rb_cocos2dx_Sprite_createWithSpriteFrame));

	


	TypeTest<cocos2d::Sprite> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Sprite",classValue);
}
RBVAL rb_cocos2dx_Image_hasPremultipliedAlpha(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Image* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Image_hasPremultipliedAlpha : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->hasPremultipliedAlpha();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Image_hasPremultipliedAlpha : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Image_saveToFile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Image* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Image_saveToFile : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Image_saveToFile : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->saveToFile(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}
		if (argc == 2) {
			std::string arg0;
			bool arg1;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Image_saveToFile : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->saveToFile(arg0, arg1);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Image_saveToFile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Image_hasAlpha(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Image* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Image_hasAlpha : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->hasAlpha();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Image_hasAlpha : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Image_isCompressed(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Image* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Image_isCompressed : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isCompressed();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Image_isCompressed : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Image_getHeight(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Image* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Image_getHeight : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getHeight();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Image_getHeight : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Image_initWithImageFile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Image* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Image_initWithImageFile : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Image_initWithImageFile : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->initWithImageFile(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Image_initWithImageFile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Image_getWidth(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Image* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Image_getWidth : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getWidth();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Image_getWidth : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Image_getBitPerPixel(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Image* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Image_getBitPerPixel : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getBitPerPixel();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Image_getBitPerPixel : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Image_getFileType(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Image* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Image_getFileType : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getFileType();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Image_getFileType : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Image_getNumberOfMipmaps(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Image* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Image_getNumberOfMipmaps : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getNumberOfMipmaps();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Image_getNumberOfMipmaps : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Image_getRenderFormat(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Image* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Image_getRenderFormat : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getRenderFormat();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Image_getRenderFormat : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Image_setPVRImagesHavePremultipliedAlpha(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		bool arg0;
		ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Image_setPVRImagesHavePremultipliedAlpha : Error processing arguments");return RBNil();}
		cocos2d::Image::setPVRImagesHavePremultipliedAlpha(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("pVRImagesHavePremultipliedAlpha");
				}
				rb_cvar_set_bridge(clazz,propSYM,argv[0]);
		RBVAL value=RBNil();
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Image_setPVRImagesHavePremultipliedAlpha : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_Image_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::Image> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::Image* cobj = new cocos2d::Image();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Image_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Image() {
		
	RBVAL classValue=rb_define_class_bridge("Image",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"hasPremultipliedAlpha",RB_FUNC(rb_cocos2dx_Image_hasPremultipliedAlpha));

	

	rb_define_method_bridge(classValue,"saveToFile",RB_FUNC(rb_cocos2dx_Image_saveToFile));

	

	rb_define_method_bridge(classValue,"hasAlpha",RB_FUNC(rb_cocos2dx_Image_hasAlpha));

	

	rb_define_method_bridge(classValue,"isCompressed",RB_FUNC(rb_cocos2dx_Image_isCompressed));

	

	rb_define_method_bridge(classValue,"getHeight",RB_FUNC(rb_cocos2dx_Image_getHeight));

   rb_define_method_bridge(classValue,"height",RB_FUNC(rb_cocos2dx_Image_getHeight));
	

	rb_define_method_bridge(classValue,"initWithImageFile",RB_FUNC(rb_cocos2dx_Image_initWithImageFile));

	

	rb_define_method_bridge(classValue,"getWidth",RB_FUNC(rb_cocos2dx_Image_getWidth));

   rb_define_method_bridge(classValue,"width",RB_FUNC(rb_cocos2dx_Image_getWidth));
	

	rb_define_method_bridge(classValue,"getBitPerPixel",RB_FUNC(rb_cocos2dx_Image_getBitPerPixel));

   rb_define_method_bridge(classValue,"bitPerPixel",RB_FUNC(rb_cocos2dx_Image_getBitPerPixel));
	

	rb_define_method_bridge(classValue,"getFileType",RB_FUNC(rb_cocos2dx_Image_getFileType));

   rb_define_method_bridge(classValue,"fileType",RB_FUNC(rb_cocos2dx_Image_getFileType));
	

	rb_define_method_bridge(classValue,"getNumberOfMipmaps",RB_FUNC(rb_cocos2dx_Image_getNumberOfMipmaps));

   rb_define_method_bridge(classValue,"numberOfMipmaps",RB_FUNC(rb_cocos2dx_Image_getNumberOfMipmaps));
	

	rb_define_method_bridge(classValue,"getRenderFormat",RB_FUNC(rb_cocos2dx_Image_getRenderFormat));

   rb_define_method_bridge(classValue,"renderFormat",RB_FUNC(rb_cocos2dx_Image_getRenderFormat));
	

	

	rb_define_singleton_method_bridge(classValue,"setPVRImagesHavePremultipliedAlpha",RB_FUNC(rb_cocos2dx_Image_setPVRImagesHavePremultipliedAlpha));

    rb_define_singleton_method_bridge(classValue,"pVRImagesHavePremultipliedAlpha=",RB_FUNC(rb_cocos2dx_Image_setPVRImagesHavePremultipliedAlpha));
	

	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_Image_constructor));

	TypeTest<cocos2d::Image> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Image",classValue);
}
RBVAL rb_cocos2dx_RenderTexture_setVirtualViewport(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_setVirtualViewport : self ptr is null");return RBNil();}
		if (argc == 3) {
			cocos2d::Vec2 arg0;
			cocos2d::Rect arg1;
			cocos2d::Rect arg2;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			ok &= rb_value_to_ccrect(argv[1], &arg1);
			ok &= rb_value_to_ccrect(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_setVirtualViewport : Error processing argument 3 ( 3 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setVirtualViewport(arg0, arg1, arg2);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_setVirtualViewport : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_clearStencil(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_clearStencil : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_clearStencil : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->clearStencil(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_clearStencil : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_getClearDepth(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_getClearDepth : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getClearDepth();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_getClearDepth : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_getClearStencil(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_getClearStencil : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getClearStencil();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_getClearStencil : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_end(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_end : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->end();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_end : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_setClearStencil(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_setClearStencil : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_setClearStencil : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setClearStencil(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("clearStencil");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_setClearStencil : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_setSprite(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_setSprite : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Sprite* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_setSprite : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setSprite(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("sprite");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_setSprite : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_getSprite(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_getSprite : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Sprite* ret = cobj->getSprite();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Sprite>((cocos2d::Sprite*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_getSprite : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_isAutoDraw(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_isAutoDraw : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isAutoDraw();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_isAutoDraw : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_setKeepMatrix(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_setKeepMatrix : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_setKeepMatrix : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setKeepMatrix(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("keepMatrix");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_setKeepMatrix : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_setClearFlags(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_setClearFlags : self ptr is null");return RBNil();}
		if (argc == 1) {
			unsigned int arg0;
			ok &= rb_value_to_uint(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_setClearFlags : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setClearFlags(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("clearFlags");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_setClearFlags : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_begin(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_begin : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->begin();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_begin : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_setAutoDraw(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_setAutoDraw : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_setAutoDraw : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAutoDraw(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("autoDraw");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_setAutoDraw : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_setClearColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_setClearColor : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Color4F arg0;
			ok &= rb_value_to_cccolor4f(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_setClearColor : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setClearColor(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("clearColor");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_setClearColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_endToLua(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_endToLua : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->endToLua();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_endToLua : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_beginWithClear(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : self ptr is null");return RBNil();}
	do {
		if (argc == 5) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : Error processing argument 1 ( 5 )");return RBNil(); }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : Error processing argument 2 ( 5 )");return RBNil(); }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : Error processing argument 3 ( 5 )");return RBNil(); }
			float arg3;
			ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : Error processing argument 4 ( 5 )");return RBNil(); }
			float arg4;
			ok &= rb_value_to_float(argv[4], &arg4);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : Error processing argument 5 ( 5 )");return RBNil(); }
			cobj->beginWithClear(arg0, arg1, arg2, arg3, arg4);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 4) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : Error processing argument 1 ( 4 )");return RBNil(); }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : Error processing argument 2 ( 4 )");return RBNil(); }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : Error processing argument 3 ( 4 )");return RBNil(); }
			float arg3;
			ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : Error processing argument 4 ( 4 )");return RBNil(); }
			cobj->beginWithClear(arg0, arg1, arg2, arg3);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 6) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : Error processing argument 1 ( 6 )");return RBNil(); }
			float arg1;
			ok &= rb_value_to_float(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : Error processing argument 2 ( 6 )");return RBNil(); }
			float arg2;
			ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : Error processing argument 3 ( 6 )");return RBNil(); }
			float arg3;
			ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : Error processing argument 4 ( 6 )");return RBNil(); }
			float arg4;
			ok &= rb_value_to_float(argv[4], &arg4);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : Error processing argument 5 ( 6 )");return RBNil(); }
			int arg5;
			ok &= rb_value_to_int(argv[5], (int *)&arg5);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : Error processing argument 6 ( 6 )");return RBNil(); }
			cobj->beginWithClear(arg0, arg1, arg2, arg3, arg4, arg5);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_beginWithClear : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_clearDepth(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_clearDepth : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_clearDepth : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->clearDepth(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_clearDepth : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_getClearColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_getClearColor : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Color4F& ret = cobj->getClearColor();
				value = cccolor4f_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_getClearColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_clear(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_clear : self ptr is null");return RBNil();}
		if (argc == 4) {
			float arg0;
			float arg1;
			float arg2;
			float arg3;
			ok &= rb_value_to_float(argv[0], &arg0);
			ok &= rb_value_to_float(argv[1], &arg1);
			ok &= rb_value_to_float(argv[2], &arg2);
			ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_clear : Error processing argument 4 ( 4 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->clear(arg0, arg1, arg2, arg3);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_clear : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_getClearFlags(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_getClearFlags : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					unsigned int ret = cobj->getClearFlags();
				value = uint_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_getClearFlags : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_newImage(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_newImage : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Image* ret = cobj->newImage();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Image>((cocos2d::Image*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_newImage : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Image* ret = cobj->newImage(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Image>((cocos2d::Image*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_newImage : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_setClearDepth(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_setClearDepth : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_setClearDepth : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setClearDepth(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("clearDepth");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_setClearDepth : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_initWithWidthAndHeight(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::RenderTexture* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_initWithWidthAndHeight : self ptr is null");return RBNil();}
	do {
		if (argc == 4) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_initWithWidthAndHeight : Error processing argument 1 ( 4 )");return RBNil(); }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_initWithWidthAndHeight : Error processing argument 2 ( 4 )");return RBNil(); }
			cocos2d::Texture2D::PixelFormat arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_initWithWidthAndHeight : Error processing argument 3 ( 4 )");return RBNil(); }
			unsigned int arg3;
			ok &= rb_value_to_uint(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_initWithWidthAndHeight : Error processing argument 4 ( 4 )");return RBNil(); }
			bool ret = cobj->initWithWidthAndHeight(arg0, arg1, arg2, arg3);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 3) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_initWithWidthAndHeight : Error processing argument 1 ( 3 )");return RBNil(); }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_initWithWidthAndHeight : Error processing argument 2 ( 3 )");return RBNil(); }
			cocos2d::Texture2D::PixelFormat arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_RenderTexture_initWithWidthAndHeight : Error processing argument 3 ( 3 )");return RBNil(); }
			bool ret = cobj->initWithWidthAndHeight(arg0, arg1, arg2);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_initWithWidthAndHeight : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 3) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) { break; }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) { break; }
			cocos2d::Texture2D::PixelFormat arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) { break; }
			cocos2d::RenderTexture* ret = cocos2d::RenderTexture::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::RenderTexture>((cocos2d::RenderTexture*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 4) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) { break; }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) { break; }
			cocos2d::Texture2D::PixelFormat arg2;
			ok &= rb_value_to_int(argv[2], (int *)&arg2);
			if (!ok) { break; }
			unsigned int arg3;
			ok &= rb_value_to_uint(argv[3], &arg3);
			if (!ok) { break; }
			cocos2d::RenderTexture* ret = cocos2d::RenderTexture::create(arg0, arg1, arg2, arg3);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::RenderTexture>((cocos2d::RenderTexture*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 2) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) { break; }
			int arg1;
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) { break; }
			cocos2d::RenderTexture* ret = cocos2d::RenderTexture::create(arg0, arg1);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::RenderTexture>((cocos2d::RenderTexture*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_RenderTexture_create : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_RenderTexture_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::RenderTexture> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::RenderTexture* cobj = new cocos2d::RenderTexture();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_RenderTexture_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_RenderTexture() {
		
	RBVAL classValue=rb_define_class_bridge("RenderTexture",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"setVirtualViewport",RB_FUNC(rb_cocos2dx_RenderTexture_setVirtualViewport));

    rb_define_method_bridge(classValue,"virtualViewport=",RB_FUNC(rb_cocos2dx_RenderTexture_setVirtualViewport));
	

	rb_define_method_bridge(classValue,"clearStencil",RB_FUNC(rb_cocos2dx_RenderTexture_clearStencil));

	

	rb_define_method_bridge(classValue,"getClearDepth",RB_FUNC(rb_cocos2dx_RenderTexture_getClearDepth));

   rb_define_method_bridge(classValue,"clearDepth",RB_FUNC(rb_cocos2dx_RenderTexture_getClearDepth));
	

	rb_define_method_bridge(classValue,"getClearStencil",RB_FUNC(rb_cocos2dx_RenderTexture_getClearStencil));

   rb_define_method_bridge(classValue,"clearStencil",RB_FUNC(rb_cocos2dx_RenderTexture_getClearStencil));
	

	rb_define_method_bridge(classValue,"end",RB_FUNC(rb_cocos2dx_RenderTexture_end));

	

	rb_define_method_bridge(classValue,"setClearStencil",RB_FUNC(rb_cocos2dx_RenderTexture_setClearStencil));

    rb_define_method_bridge(classValue,"clearStencil=",RB_FUNC(rb_cocos2dx_RenderTexture_setClearStencil));
	

	rb_define_method_bridge(classValue,"setSprite",RB_FUNC(rb_cocos2dx_RenderTexture_setSprite));

    rb_define_method_bridge(classValue,"sprite=",RB_FUNC(rb_cocos2dx_RenderTexture_setSprite));
	

	rb_define_method_bridge(classValue,"getSprite",RB_FUNC(rb_cocos2dx_RenderTexture_getSprite));

   rb_define_method_bridge(classValue,"sprite",RB_FUNC(rb_cocos2dx_RenderTexture_getSprite));
	

	rb_define_method_bridge(classValue,"isAutoDraw",RB_FUNC(rb_cocos2dx_RenderTexture_isAutoDraw));

	

	rb_define_method_bridge(classValue,"setKeepMatrix",RB_FUNC(rb_cocos2dx_RenderTexture_setKeepMatrix));

    rb_define_method_bridge(classValue,"keepMatrix=",RB_FUNC(rb_cocos2dx_RenderTexture_setKeepMatrix));
	

	rb_define_method_bridge(classValue,"setClearFlags",RB_FUNC(rb_cocos2dx_RenderTexture_setClearFlags));

    rb_define_method_bridge(classValue,"clearFlags=",RB_FUNC(rb_cocos2dx_RenderTexture_setClearFlags));
	

	rb_define_method_bridge(classValue,"begin",RB_FUNC(rb_cocos2dx_RenderTexture_begin));

	

	rb_define_method_bridge(classValue,"setAutoDraw",RB_FUNC(rb_cocos2dx_RenderTexture_setAutoDraw));

    rb_define_method_bridge(classValue,"autoDraw=",RB_FUNC(rb_cocos2dx_RenderTexture_setAutoDraw));
	

	rb_define_method_bridge(classValue,"setClearColor",RB_FUNC(rb_cocos2dx_RenderTexture_setClearColor));

    rb_define_method_bridge(classValue,"clearColor=",RB_FUNC(rb_cocos2dx_RenderTexture_setClearColor));
	

	rb_define_method_bridge(classValue,"endToLua",RB_FUNC(rb_cocos2dx_RenderTexture_endToLua));

	

	rb_define_method_bridge(classValue,"beginWithClear",RB_FUNC(rb_cocos2dx_RenderTexture_beginWithClear));

	

	rb_define_method_bridge(classValue,"clearDepth",RB_FUNC(rb_cocos2dx_RenderTexture_clearDepth));

	

	rb_define_method_bridge(classValue,"getClearColor",RB_FUNC(rb_cocos2dx_RenderTexture_getClearColor));

   rb_define_method_bridge(classValue,"clearColor",RB_FUNC(rb_cocos2dx_RenderTexture_getClearColor));
	

	rb_define_method_bridge(classValue,"clear",RB_FUNC(rb_cocos2dx_RenderTexture_clear));

	

	rb_define_method_bridge(classValue,"getClearFlags",RB_FUNC(rb_cocos2dx_RenderTexture_getClearFlags));

   rb_define_method_bridge(classValue,"clearFlags",RB_FUNC(rb_cocos2dx_RenderTexture_getClearFlags));
	

	rb_define_method_bridge(classValue,"newImage",RB_FUNC(rb_cocos2dx_RenderTexture_newImage));

	

	rb_define_method_bridge(classValue,"setClearDepth",RB_FUNC(rb_cocos2dx_RenderTexture_setClearDepth));

    rb_define_method_bridge(classValue,"clearDepth=",RB_FUNC(rb_cocos2dx_RenderTexture_setClearDepth));
	

	rb_define_method_bridge(classValue,"initWithWidthAndHeight",RB_FUNC(rb_cocos2dx_RenderTexture_initWithWidthAndHeight));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_RenderTexture_create));

	

	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_RenderTexture_constructor));

	TypeTest<cocos2d::RenderTexture> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::RenderTexture",classValue);
}
RBVAL rb_cocos2dx_NodeGrid_setTarget(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::NodeGrid* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_NodeGrid_setTarget : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_NodeGrid_setTarget : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTarget(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("target");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_NodeGrid_setTarget : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_NodeGrid_getGrid(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::NodeGrid* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_NodeGrid_getGrid : self ptr is null");return RBNil();}
	do {
		if (argc == 0) {
			const cocos2d::GridBase* ret = cobj->getGrid();
			RBVAL value = RBNil();
						if (ret) {
				value = rbb_get_or_create_value<cocos2d::GridBase>((cocos2d::GridBase*)ret);
			} else {
				value = RBNil();
			};
			return value;
		}
	} while(0);

	do {
		if (argc == 0) {
			cocos2d::GridBase* ret = cobj->getGrid();
			RBVAL value = RBNil();
						if (ret) {
				value = rbb_get_or_create_value<cocos2d::GridBase>((cocos2d::GridBase*)ret);
			} else {
				value = RBNil();
			};
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_NodeGrid_getGrid : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_NodeGrid_setGrid(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::NodeGrid* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_NodeGrid_setGrid : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::GridBase* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_NodeGrid_setGrid : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setGrid(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("grid");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_NodeGrid_setGrid : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_NodeGrid_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::NodeGrid* ret = cocos2d::NodeGrid::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::NodeGrid>((cocos2d::NodeGrid*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_NodeGrid_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_NodeGrid() {
		
	RBVAL classValue=rb_define_class_bridge("NodeGrid",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"setTarget",RB_FUNC(rb_cocos2dx_NodeGrid_setTarget));

    rb_define_method_bridge(classValue,"target=",RB_FUNC(rb_cocos2dx_NodeGrid_setTarget));
	

	rb_define_method_bridge(classValue,"getGrid",RB_FUNC(rb_cocos2dx_NodeGrid_getGrid));

   rb_define_method_bridge(classValue,"grid",RB_FUNC(rb_cocos2dx_NodeGrid_getGrid));
	

	rb_define_method_bridge(classValue,"setGrid",RB_FUNC(rb_cocos2dx_NodeGrid_setGrid));

    rb_define_method_bridge(classValue,"grid=",RB_FUNC(rb_cocos2dx_NodeGrid_setGrid));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_NodeGrid_create));

	


	TypeTest<cocos2d::NodeGrid> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::NodeGrid",classValue);
}
RBVAL rb_cocos2dx_ParticleBatchNode_setTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_setTexture : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Texture2D* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_setTexture : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTexture(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("texture");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_setTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleBatchNode_disableParticle(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_disableParticle : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_disableParticle : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->disableParticle(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_disableParticle : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleBatchNode_getTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_getTexture : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Texture2D* ret = cobj->getTexture();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Texture2D>((cocos2d::Texture2D*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_getTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleBatchNode_setTextureAtlas(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_setTextureAtlas : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::TextureAtlas* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_setTextureAtlas : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTextureAtlas(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("textureAtlas");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_setTextureAtlas : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeAllChildrenWithCleanup(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleBatchNode_getTextureAtlas(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_getTextureAtlas : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::TextureAtlas* ret = cobj->getTextureAtlas();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::TextureAtlas>((cocos2d::TextureAtlas*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_getTextureAtlas : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleBatchNode_insertChild(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_insertChild : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::ParticleSystem* arg0;
			int arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_insertChild : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->insertChild(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_insertChild : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleBatchNode_removeChildAtIndex(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleBatchNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_removeChildAtIndex : self ptr is null");return RBNil();}
		if (argc == 2) {
			int arg0;
			bool arg1;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			ok &= rb_value_to_bool(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_removeChildAtIndex : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeChildAtIndex(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_removeChildAtIndex : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleBatchNode_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		std::string arg0;
		ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_create : Error processing arguments");return RBNil();}
		cocos2d::ParticleBatchNode* ret = cocos2d::ParticleBatchNode::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleBatchNode>((cocos2d::ParticleBatchNode*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	if (argc == 2) {
		std::string arg0;
		int arg1;
		ok &= rb_value_to_std_string(argv[0], &arg0);
		ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_create : Error processing arguments");return RBNil();}
		cocos2d::ParticleBatchNode* ret = cocos2d::ParticleBatchNode::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleBatchNode>((cocos2d::ParticleBatchNode*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_ParticleBatchNode_createWithTexture(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::Texture2D* arg0;
		ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_createWithTexture : Error processing arguments");return RBNil();}
		cocos2d::ParticleBatchNode* ret = cocos2d::ParticleBatchNode::createWithTexture(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleBatchNode>((cocos2d::ParticleBatchNode*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	if (argc == 2) {
		cocos2d::Texture2D* arg0;
		int arg1;
		ok &= rb_value_get_ptr(argv[0],&arg0);
		ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_createWithTexture : Error processing arguments");return RBNil();}
		cocos2d::ParticleBatchNode* ret = cocos2d::ParticleBatchNode::createWithTexture(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleBatchNode>((cocos2d::ParticleBatchNode*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleBatchNode_createWithTexture : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ParticleBatchNode() {
		
	RBVAL classValue=rb_define_class_bridge("ParticleBatchNode",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"setTexture",RB_FUNC(rb_cocos2dx_ParticleBatchNode_setTexture));

    rb_define_method_bridge(classValue,"texture=",RB_FUNC(rb_cocos2dx_ParticleBatchNode_setTexture));
	

	rb_define_method_bridge(classValue,"disableParticle",RB_FUNC(rb_cocos2dx_ParticleBatchNode_disableParticle));

	

	rb_define_method_bridge(classValue,"getTexture",RB_FUNC(rb_cocos2dx_ParticleBatchNode_getTexture));

   rb_define_method_bridge(classValue,"texture",RB_FUNC(rb_cocos2dx_ParticleBatchNode_getTexture));
	

	rb_define_method_bridge(classValue,"setTextureAtlas",RB_FUNC(rb_cocos2dx_ParticleBatchNode_setTextureAtlas));

    rb_define_method_bridge(classValue,"textureAtlas=",RB_FUNC(rb_cocos2dx_ParticleBatchNode_setTextureAtlas));
	

	rb_define_method_bridge(classValue,"removeAllChildrenWithCleanup",RB_FUNC(rb_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup));

	

	rb_define_method_bridge(classValue,"getTextureAtlas",RB_FUNC(rb_cocos2dx_ParticleBatchNode_getTextureAtlas));

   rb_define_method_bridge(classValue,"textureAtlas",RB_FUNC(rb_cocos2dx_ParticleBatchNode_getTextureAtlas));
	

	rb_define_method_bridge(classValue,"insertChild",RB_FUNC(rb_cocos2dx_ParticleBatchNode_insertChild));

	

	rb_define_method_bridge(classValue,"removeChildAtIndex",RB_FUNC(rb_cocos2dx_ParticleBatchNode_removeChildAtIndex));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ParticleBatchNode_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTexture",RB_FUNC(rb_cocos2dx_ParticleBatchNode_createWithTexture));

	


	TypeTest<cocos2d::ParticleBatchNode> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ParticleBatchNode",classValue);
}
RBVAL rb_cocos2dx_ParticleSystem_getStartSizeVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getStartSizeVar : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getStartSizeVar();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getStartSizeVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getTexture : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Texture2D* ret = cobj->getTexture();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Texture2D>((cocos2d::Texture2D*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_isFull(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_isFull : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isFull();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_isFull : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getBatchNode(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getBatchNode : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::ParticleBatchNode* ret = cobj->getBatchNode();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::ParticleBatchNode>((cocos2d::ParticleBatchNode*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getBatchNode : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getStartColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getStartColor : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Color4F& ret = cobj->getStartColor();
				value = cccolor4f_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getStartColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getPositionType(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getPositionType : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getPositionType();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getPositionType : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setPosVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setPosVar : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setPosVar : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setPosVar(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("posVar");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setPosVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getEndSpin(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEndSpin : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getEndSpin();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEndSpin : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setRotatePerSecondVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRotatePerSecondVar : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRotatePerSecondVar : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRotatePerSecondVar(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("rotatePerSecondVar");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRotatePerSecondVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getStartSpinVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getStartSpinVar : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getStartSpinVar();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getStartSpinVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getRadialAccelVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getRadialAccelVar : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getRadialAccelVar();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getRadialAccelVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getEndSizeVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEndSizeVar : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getEndSizeVar();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEndSizeVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setRotation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRotation : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRotation : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRotation(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("rotation");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRotation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setTangentialAccel(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setTangentialAccel : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setTangentialAccel : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTangentialAccel(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("tangentialAccel");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setTangentialAccel : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setScaleY(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setScaleY : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setScaleY : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setScaleY(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("scaleY");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setScaleY : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setScaleX(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setScaleX : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setScaleX : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setScaleX(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("scaleX");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setScaleX : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getRadialAccel(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getRadialAccel : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getRadialAccel();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getRadialAccel : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setStartRadius(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartRadius : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartRadius : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setStartRadius(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("startRadius");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartRadius : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setRotatePerSecond(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRotatePerSecond : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRotatePerSecond : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRotatePerSecond(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("rotatePerSecond");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRotatePerSecond : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setEndSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndSize : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndSize : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEndSize(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("endSize");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getGravity(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getGravity : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec2& ret = cobj->getGravity();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getGravity : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getTangentialAccel(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getTangentialAccel : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getTangentialAccel();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getTangentialAccel : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setEndRadius(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndRadius : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndRadius : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEndRadius(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("endRadius");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndRadius : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getSpeed(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getSpeed : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getSpeed();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getSpeed : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getAngle(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getAngle : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAngle();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getAngle : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setEndColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndColor : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Color4F arg0;
			ok &= rb_value_to_cccolor4f(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndColor : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEndColor(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("endColor");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setStartSpin(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartSpin : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartSpin : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setStartSpin(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("startSpin");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartSpin : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setDuration(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setDuration : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setDuration : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDuration(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("duration");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setDuration : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setTexture : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Texture2D* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setTexture : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTexture(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("texture");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getPosVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getPosVar : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec2& ret = cobj->getPosVar();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getPosVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_updateWithNoTime(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_updateWithNoTime : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->updateWithNoTime();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_updateWithNoTime : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_isBlendAdditive(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_isBlendAdditive : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isBlendAdditive();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_isBlendAdditive : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getSpeedVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getSpeedVar : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getSpeedVar();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getSpeedVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setPositionType(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setPositionType : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ParticleSystem::PositionType arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setPositionType : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setPositionType(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("positionType");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setPositionType : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_stopSystem(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_stopSystem : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->stopSystem();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_stopSystem : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getSourcePosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getSourcePosition : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec2& ret = cobj->getSourcePosition();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getSourcePosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setLifeVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setLifeVar : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setLifeVar : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setLifeVar(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("lifeVar");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setLifeVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setTotalParticles(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setTotalParticles : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setTotalParticles : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTotalParticles(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("totalParticles");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setTotalParticles : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setEndColorVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndColorVar : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Color4F arg0;
			ok &= rb_value_to_cccolor4f(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndColorVar : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEndColorVar(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("endColorVar");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndColorVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getAtlasIndex(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getAtlasIndex : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getAtlasIndex();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getAtlasIndex : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getStartSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getStartSize : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getStartSize();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getStartSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setStartSpinVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartSpinVar : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartSpinVar : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setStartSpinVar(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("startSpinVar");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartSpinVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_resetSystem(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_resetSystem : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->resetSystem();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_resetSystem : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setAtlasIndex(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setAtlasIndex : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setAtlasIndex : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAtlasIndex(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("atlasIndex");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setAtlasIndex : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setTangentialAccelVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setTangentialAccelVar : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setTangentialAccelVar : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTangentialAccelVar(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("tangentialAccelVar");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setTangentialAccelVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setEndRadiusVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndRadiusVar : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndRadiusVar : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEndRadiusVar(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("endRadiusVar");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndRadiusVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getEndRadius(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEndRadius : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getEndRadius();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEndRadius : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_isOpacityModifyRGB(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_isOpacityModifyRGB : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isOpacityModifyRGB();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_isOpacityModifyRGB : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_isActive(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_isActive : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isActive();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_isActive : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setRadialAccelVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRadialAccelVar : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRadialAccelVar : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRadialAccelVar(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("radialAccelVar");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRadialAccelVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setStartSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartSize : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartSize : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setStartSize(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("startSize");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setSpeed(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setSpeed : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setSpeed : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setSpeed(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("speed");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setSpeed : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getStartSpin(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getStartSpin : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getStartSpin();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getStartSpin : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getRotatePerSecond(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getRotatePerSecond : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getRotatePerSecond();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getRotatePerSecond : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setEmitterMode(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEmitterMode : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ParticleSystem::Mode arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEmitterMode : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEmitterMode(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("emitterMode");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEmitterMode : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getDuration(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getDuration : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getDuration();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getDuration : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setSourcePosition(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setSourcePosition : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setSourcePosition : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setSourcePosition(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("sourcePosition");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setSourcePosition : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getEndSpinVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEndSpinVar : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getEndSpinVar();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEndSpinVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setBlendAdditive(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setBlendAdditive : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setBlendAdditive : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setBlendAdditive(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("blendAdditive");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setBlendAdditive : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setLife(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setLife : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setLife : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setLife(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("life");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setLife : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setAngleVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setAngleVar : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setAngleVar : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAngleVar(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("angleVar");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setAngleVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setRotationIsDir(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRotationIsDir : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRotationIsDir : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRotationIsDir(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("rotationIsDir");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRotationIsDir : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setEndSizeVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndSizeVar : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndSizeVar : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEndSizeVar(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("endSizeVar");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndSizeVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setAngle(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setAngle : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setAngle : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAngle(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("angle");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setAngle : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setBatchNode(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setBatchNode : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::ParticleBatchNode* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setBatchNode : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setBatchNode(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("batchNode");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setBatchNode : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getTangentialAccelVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getTangentialAccelVar : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getTangentialAccelVar();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getTangentialAccelVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getEmitterMode(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEmitterMode : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getEmitterMode();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEmitterMode : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setEndSpinVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndSpinVar : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndSpinVar : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEndSpinVar(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("endSpinVar");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndSpinVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getAngleVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getAngleVar : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getAngleVar();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getAngleVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setStartColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartColor : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Color4F arg0;
			ok &= rb_value_to_cccolor4f(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartColor : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setStartColor(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("startColor");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getRotatePerSecondVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getRotatePerSecondVar : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getRotatePerSecondVar();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getRotatePerSecondVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getEndSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEndSize : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getEndSize();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEndSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getLife(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getLife : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getLife();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getLife : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setSpeedVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setSpeedVar : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setSpeedVar : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setSpeedVar(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("speedVar");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setSpeedVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setAutoRemoveOnFinish(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setAutoRemoveOnFinish : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setAutoRemoveOnFinish : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAutoRemoveOnFinish(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("autoRemoveOnFinish");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setAutoRemoveOnFinish : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setGravity(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setGravity : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setGravity : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setGravity(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("gravity");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setGravity : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_postStep(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_postStep : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->postStep();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_postStep : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setEmissionRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEmissionRate : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEmissionRate : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEmissionRate(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("emissionRate");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEmissionRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getEndColorVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEndColorVar : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Color4F& ret = cobj->getEndColorVar();
				value = cccolor4f_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEndColorVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getRotationIsDir(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getRotationIsDir : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->getRotationIsDir();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getRotationIsDir : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setScale(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setScale : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setScale : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setScale(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("scale");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setScale : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getEmissionRate(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEmissionRate : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getEmissionRate();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEmissionRate : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getEndColor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEndColor : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Color4F& ret = cobj->getEndColor();
				value = cccolor4f_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEndColor : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getLifeVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getLifeVar : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getLifeVar();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getLifeVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setStartSizeVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartSizeVar : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartSizeVar : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setStartSizeVar(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("startSizeVar");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartSizeVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setOpacityModifyRGB(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setOpacityModifyRGB : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setOpacityModifyRGB : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setOpacityModifyRGB(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("opacityModifyRGB");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setOpacityModifyRGB : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_addParticle(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_addParticle : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->addParticle();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_addParticle : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getStartRadius(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getStartRadius : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getStartRadius();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getStartRadius : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getParticleCount(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getParticleCount : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					unsigned int ret = cobj->getParticleCount();
				value = uint_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getParticleCount : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getStartRadiusVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getStartRadiusVar : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getStartRadiusVar();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getStartRadiusVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setStartColorVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartColorVar : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Color4F arg0;
			ok &= rb_value_to_cccolor4f(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartColorVar : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setStartColorVar(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("startColorVar");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartColorVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setEndSpin(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndSpin : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndSpin : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEndSpin(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("endSpin");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setEndSpin : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setRadialAccel(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRadialAccel : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRadialAccel : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRadialAccel(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("radialAccel");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setRadialAccel : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_isAutoRemoveOnFinish(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_isAutoRemoveOnFinish : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isAutoRemoveOnFinish();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_isAutoRemoveOnFinish : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getTotalParticles(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getTotalParticles : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getTotalParticles();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getTotalParticles : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_setStartRadiusVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartRadiusVar : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartRadiusVar : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setStartRadiusVar(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("startRadiusVar");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_setStartRadiusVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getEndRadiusVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEndRadiusVar : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getEndRadiusVar();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getEndRadiusVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_getStartColorVar(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystem* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getStartColorVar : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Color4F& ret = cobj->getStartColorVar();
				value = cccolor4f_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_getStartColorVar : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystem_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		std::string arg0;
		ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_create : Error processing arguments");return RBNil();}
		cocos2d::ParticleSystem* ret = cocos2d::ParticleSystem::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleSystem>((cocos2d::ParticleSystem*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_ParticleSystem_createWithTotalParticles(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		int arg0;
		ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystem_createWithTotalParticles : Error processing arguments");return RBNil();}
		cocos2d::ParticleSystem* ret = cocos2d::ParticleSystem::createWithTotalParticles(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleSystem>((cocos2d::ParticleSystem*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleSystem_createWithTotalParticles : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ParticleSystem() {
		
	RBVAL classValue=rb_define_class_bridge("ParticleSystem",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"getStartSizeVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getStartSizeVar));

   rb_define_method_bridge(classValue,"startSizeVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getStartSizeVar));
	

	rb_define_method_bridge(classValue,"getTexture",RB_FUNC(rb_cocos2dx_ParticleSystem_getTexture));

   rb_define_method_bridge(classValue,"texture",RB_FUNC(rb_cocos2dx_ParticleSystem_getTexture));
	

	rb_define_method_bridge(classValue,"isFull",RB_FUNC(rb_cocos2dx_ParticleSystem_isFull));

	

	rb_define_method_bridge(classValue,"getBatchNode",RB_FUNC(rb_cocos2dx_ParticleSystem_getBatchNode));

   rb_define_method_bridge(classValue,"batchNode",RB_FUNC(rb_cocos2dx_ParticleSystem_getBatchNode));
	

	rb_define_method_bridge(classValue,"getStartColor",RB_FUNC(rb_cocos2dx_ParticleSystem_getStartColor));

   rb_define_method_bridge(classValue,"startColor",RB_FUNC(rb_cocos2dx_ParticleSystem_getStartColor));
	

	rb_define_method_bridge(classValue,"getPositionType",RB_FUNC(rb_cocos2dx_ParticleSystem_getPositionType));

   rb_define_method_bridge(classValue,"positionType",RB_FUNC(rb_cocos2dx_ParticleSystem_getPositionType));
	

	rb_define_method_bridge(classValue,"setPosVar",RB_FUNC(rb_cocos2dx_ParticleSystem_setPosVar));

    rb_define_method_bridge(classValue,"posVar=",RB_FUNC(rb_cocos2dx_ParticleSystem_setPosVar));
	

	rb_define_method_bridge(classValue,"getEndSpin",RB_FUNC(rb_cocos2dx_ParticleSystem_getEndSpin));

   rb_define_method_bridge(classValue,"endSpin",RB_FUNC(rb_cocos2dx_ParticleSystem_getEndSpin));
	

	rb_define_method_bridge(classValue,"setRotatePerSecondVar",RB_FUNC(rb_cocos2dx_ParticleSystem_setRotatePerSecondVar));

    rb_define_method_bridge(classValue,"rotatePerSecondVar=",RB_FUNC(rb_cocos2dx_ParticleSystem_setRotatePerSecondVar));
	

	rb_define_method_bridge(classValue,"getStartSpinVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getStartSpinVar));

   rb_define_method_bridge(classValue,"startSpinVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getStartSpinVar));
	

	rb_define_method_bridge(classValue,"getRadialAccelVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getRadialAccelVar));

   rb_define_method_bridge(classValue,"radialAccelVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getRadialAccelVar));
	

	rb_define_method_bridge(classValue,"getEndSizeVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getEndSizeVar));

   rb_define_method_bridge(classValue,"endSizeVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getEndSizeVar));
	

	rb_define_method_bridge(classValue,"setRotation",RB_FUNC(rb_cocos2dx_ParticleSystem_setRotation));

    rb_define_method_bridge(classValue,"rotation=",RB_FUNC(rb_cocos2dx_ParticleSystem_setRotation));
	

	rb_define_method_bridge(classValue,"setTangentialAccel",RB_FUNC(rb_cocos2dx_ParticleSystem_setTangentialAccel));

    rb_define_method_bridge(classValue,"tangentialAccel=",RB_FUNC(rb_cocos2dx_ParticleSystem_setTangentialAccel));
	

	rb_define_method_bridge(classValue,"setScaleY",RB_FUNC(rb_cocos2dx_ParticleSystem_setScaleY));

    rb_define_method_bridge(classValue,"scaleY=",RB_FUNC(rb_cocos2dx_ParticleSystem_setScaleY));
	

	rb_define_method_bridge(classValue,"setScaleX",RB_FUNC(rb_cocos2dx_ParticleSystem_setScaleX));

    rb_define_method_bridge(classValue,"scaleX=",RB_FUNC(rb_cocos2dx_ParticleSystem_setScaleX));
	

	rb_define_method_bridge(classValue,"getRadialAccel",RB_FUNC(rb_cocos2dx_ParticleSystem_getRadialAccel));

   rb_define_method_bridge(classValue,"radialAccel",RB_FUNC(rb_cocos2dx_ParticleSystem_getRadialAccel));
	

	rb_define_method_bridge(classValue,"setStartRadius",RB_FUNC(rb_cocos2dx_ParticleSystem_setStartRadius));

    rb_define_method_bridge(classValue,"startRadius=",RB_FUNC(rb_cocos2dx_ParticleSystem_setStartRadius));
	

	rb_define_method_bridge(classValue,"setRotatePerSecond",RB_FUNC(rb_cocos2dx_ParticleSystem_setRotatePerSecond));

    rb_define_method_bridge(classValue,"rotatePerSecond=",RB_FUNC(rb_cocos2dx_ParticleSystem_setRotatePerSecond));
	

	rb_define_method_bridge(classValue,"setEndSize",RB_FUNC(rb_cocos2dx_ParticleSystem_setEndSize));

    rb_define_method_bridge(classValue,"endSize=",RB_FUNC(rb_cocos2dx_ParticleSystem_setEndSize));
	

	rb_define_method_bridge(classValue,"getGravity",RB_FUNC(rb_cocos2dx_ParticleSystem_getGravity));

   rb_define_method_bridge(classValue,"gravity",RB_FUNC(rb_cocos2dx_ParticleSystem_getGravity));
	

	rb_define_method_bridge(classValue,"getTangentialAccel",RB_FUNC(rb_cocos2dx_ParticleSystem_getTangentialAccel));

   rb_define_method_bridge(classValue,"tangentialAccel",RB_FUNC(rb_cocos2dx_ParticleSystem_getTangentialAccel));
	

	rb_define_method_bridge(classValue,"setEndRadius",RB_FUNC(rb_cocos2dx_ParticleSystem_setEndRadius));

    rb_define_method_bridge(classValue,"endRadius=",RB_FUNC(rb_cocos2dx_ParticleSystem_setEndRadius));
	

	rb_define_method_bridge(classValue,"getSpeed",RB_FUNC(rb_cocos2dx_ParticleSystem_getSpeed));

   rb_define_method_bridge(classValue,"speed",RB_FUNC(rb_cocos2dx_ParticleSystem_getSpeed));
	

	rb_define_method_bridge(classValue,"getAngle",RB_FUNC(rb_cocos2dx_ParticleSystem_getAngle));

   rb_define_method_bridge(classValue,"angle",RB_FUNC(rb_cocos2dx_ParticleSystem_getAngle));
	

	rb_define_method_bridge(classValue,"setEndColor",RB_FUNC(rb_cocos2dx_ParticleSystem_setEndColor));

    rb_define_method_bridge(classValue,"endColor=",RB_FUNC(rb_cocos2dx_ParticleSystem_setEndColor));
	

	rb_define_method_bridge(classValue,"setStartSpin",RB_FUNC(rb_cocos2dx_ParticleSystem_setStartSpin));

    rb_define_method_bridge(classValue,"startSpin=",RB_FUNC(rb_cocos2dx_ParticleSystem_setStartSpin));
	

	rb_define_method_bridge(classValue,"setDuration",RB_FUNC(rb_cocos2dx_ParticleSystem_setDuration));

    rb_define_method_bridge(classValue,"duration=",RB_FUNC(rb_cocos2dx_ParticleSystem_setDuration));
	

	rb_define_method_bridge(classValue,"setTexture",RB_FUNC(rb_cocos2dx_ParticleSystem_setTexture));

    rb_define_method_bridge(classValue,"texture=",RB_FUNC(rb_cocos2dx_ParticleSystem_setTexture));
	

	rb_define_method_bridge(classValue,"getPosVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getPosVar));

   rb_define_method_bridge(classValue,"posVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getPosVar));
	

	rb_define_method_bridge(classValue,"updateWithNoTime",RB_FUNC(rb_cocos2dx_ParticleSystem_updateWithNoTime));

	

	rb_define_method_bridge(classValue,"isBlendAdditive",RB_FUNC(rb_cocos2dx_ParticleSystem_isBlendAdditive));

	

	rb_define_method_bridge(classValue,"getSpeedVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getSpeedVar));

   rb_define_method_bridge(classValue,"speedVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getSpeedVar));
	

	rb_define_method_bridge(classValue,"setPositionType",RB_FUNC(rb_cocos2dx_ParticleSystem_setPositionType));

    rb_define_method_bridge(classValue,"positionType=",RB_FUNC(rb_cocos2dx_ParticleSystem_setPositionType));
	

	rb_define_method_bridge(classValue,"stopSystem",RB_FUNC(rb_cocos2dx_ParticleSystem_stopSystem));

	

	rb_define_method_bridge(classValue,"getSourcePosition",RB_FUNC(rb_cocos2dx_ParticleSystem_getSourcePosition));

   rb_define_method_bridge(classValue,"sourcePosition",RB_FUNC(rb_cocos2dx_ParticleSystem_getSourcePosition));
	

	rb_define_method_bridge(classValue,"setLifeVar",RB_FUNC(rb_cocos2dx_ParticleSystem_setLifeVar));

    rb_define_method_bridge(classValue,"lifeVar=",RB_FUNC(rb_cocos2dx_ParticleSystem_setLifeVar));
	

	rb_define_method_bridge(classValue,"setTotalParticles",RB_FUNC(rb_cocos2dx_ParticleSystem_setTotalParticles));

    rb_define_method_bridge(classValue,"totalParticles=",RB_FUNC(rb_cocos2dx_ParticleSystem_setTotalParticles));
	

	rb_define_method_bridge(classValue,"setEndColorVar",RB_FUNC(rb_cocos2dx_ParticleSystem_setEndColorVar));

    rb_define_method_bridge(classValue,"endColorVar=",RB_FUNC(rb_cocos2dx_ParticleSystem_setEndColorVar));
	

	rb_define_method_bridge(classValue,"getAtlasIndex",RB_FUNC(rb_cocos2dx_ParticleSystem_getAtlasIndex));

   rb_define_method_bridge(classValue,"atlasIndex",RB_FUNC(rb_cocos2dx_ParticleSystem_getAtlasIndex));
	

	rb_define_method_bridge(classValue,"getStartSize",RB_FUNC(rb_cocos2dx_ParticleSystem_getStartSize));

   rb_define_method_bridge(classValue,"startSize",RB_FUNC(rb_cocos2dx_ParticleSystem_getStartSize));
	

	rb_define_method_bridge(classValue,"setStartSpinVar",RB_FUNC(rb_cocos2dx_ParticleSystem_setStartSpinVar));

    rb_define_method_bridge(classValue,"startSpinVar=",RB_FUNC(rb_cocos2dx_ParticleSystem_setStartSpinVar));
	

	rb_define_method_bridge(classValue,"resetSystem",RB_FUNC(rb_cocos2dx_ParticleSystem_resetSystem));

	

	rb_define_method_bridge(classValue,"setAtlasIndex",RB_FUNC(rb_cocos2dx_ParticleSystem_setAtlasIndex));

    rb_define_method_bridge(classValue,"atlasIndex=",RB_FUNC(rb_cocos2dx_ParticleSystem_setAtlasIndex));
	

	rb_define_method_bridge(classValue,"setTangentialAccelVar",RB_FUNC(rb_cocos2dx_ParticleSystem_setTangentialAccelVar));

    rb_define_method_bridge(classValue,"tangentialAccelVar=",RB_FUNC(rb_cocos2dx_ParticleSystem_setTangentialAccelVar));
	

	rb_define_method_bridge(classValue,"setEndRadiusVar",RB_FUNC(rb_cocos2dx_ParticleSystem_setEndRadiusVar));

    rb_define_method_bridge(classValue,"endRadiusVar=",RB_FUNC(rb_cocos2dx_ParticleSystem_setEndRadiusVar));
	

	rb_define_method_bridge(classValue,"getEndRadius",RB_FUNC(rb_cocos2dx_ParticleSystem_getEndRadius));

   rb_define_method_bridge(classValue,"endRadius",RB_FUNC(rb_cocos2dx_ParticleSystem_getEndRadius));
	

	rb_define_method_bridge(classValue,"isOpacityModifyRGB",RB_FUNC(rb_cocos2dx_ParticleSystem_isOpacityModifyRGB));

	

	rb_define_method_bridge(classValue,"isActive",RB_FUNC(rb_cocos2dx_ParticleSystem_isActive));

	

	rb_define_method_bridge(classValue,"setRadialAccelVar",RB_FUNC(rb_cocos2dx_ParticleSystem_setRadialAccelVar));

    rb_define_method_bridge(classValue,"radialAccelVar=",RB_FUNC(rb_cocos2dx_ParticleSystem_setRadialAccelVar));
	

	rb_define_method_bridge(classValue,"setStartSize",RB_FUNC(rb_cocos2dx_ParticleSystem_setStartSize));

    rb_define_method_bridge(classValue,"startSize=",RB_FUNC(rb_cocos2dx_ParticleSystem_setStartSize));
	

	rb_define_method_bridge(classValue,"setSpeed",RB_FUNC(rb_cocos2dx_ParticleSystem_setSpeed));

    rb_define_method_bridge(classValue,"speed=",RB_FUNC(rb_cocos2dx_ParticleSystem_setSpeed));
	

	rb_define_method_bridge(classValue,"getStartSpin",RB_FUNC(rb_cocos2dx_ParticleSystem_getStartSpin));

   rb_define_method_bridge(classValue,"startSpin",RB_FUNC(rb_cocos2dx_ParticleSystem_getStartSpin));
	

	rb_define_method_bridge(classValue,"getRotatePerSecond",RB_FUNC(rb_cocos2dx_ParticleSystem_getRotatePerSecond));

   rb_define_method_bridge(classValue,"rotatePerSecond",RB_FUNC(rb_cocos2dx_ParticleSystem_getRotatePerSecond));
	

	rb_define_method_bridge(classValue,"setEmitterMode",RB_FUNC(rb_cocos2dx_ParticleSystem_setEmitterMode));

    rb_define_method_bridge(classValue,"emitterMode=",RB_FUNC(rb_cocos2dx_ParticleSystem_setEmitterMode));
	

	rb_define_method_bridge(classValue,"getDuration",RB_FUNC(rb_cocos2dx_ParticleSystem_getDuration));

   rb_define_method_bridge(classValue,"duration",RB_FUNC(rb_cocos2dx_ParticleSystem_getDuration));
	

	rb_define_method_bridge(classValue,"setSourcePosition",RB_FUNC(rb_cocos2dx_ParticleSystem_setSourcePosition));

    rb_define_method_bridge(classValue,"sourcePosition=",RB_FUNC(rb_cocos2dx_ParticleSystem_setSourcePosition));
	

	rb_define_method_bridge(classValue,"getEndSpinVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getEndSpinVar));

   rb_define_method_bridge(classValue,"endSpinVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getEndSpinVar));
	

	rb_define_method_bridge(classValue,"setBlendAdditive",RB_FUNC(rb_cocos2dx_ParticleSystem_setBlendAdditive));

    rb_define_method_bridge(classValue,"blendAdditive=",RB_FUNC(rb_cocos2dx_ParticleSystem_setBlendAdditive));
	

	rb_define_method_bridge(classValue,"setLife",RB_FUNC(rb_cocos2dx_ParticleSystem_setLife));

    rb_define_method_bridge(classValue,"life=",RB_FUNC(rb_cocos2dx_ParticleSystem_setLife));
	

	rb_define_method_bridge(classValue,"setAngleVar",RB_FUNC(rb_cocos2dx_ParticleSystem_setAngleVar));

    rb_define_method_bridge(classValue,"angleVar=",RB_FUNC(rb_cocos2dx_ParticleSystem_setAngleVar));
	

	rb_define_method_bridge(classValue,"setRotationIsDir",RB_FUNC(rb_cocos2dx_ParticleSystem_setRotationIsDir));

    rb_define_method_bridge(classValue,"rotationIsDir=",RB_FUNC(rb_cocos2dx_ParticleSystem_setRotationIsDir));
	

	rb_define_method_bridge(classValue,"setEndSizeVar",RB_FUNC(rb_cocos2dx_ParticleSystem_setEndSizeVar));

    rb_define_method_bridge(classValue,"endSizeVar=",RB_FUNC(rb_cocos2dx_ParticleSystem_setEndSizeVar));
	

	rb_define_method_bridge(classValue,"setAngle",RB_FUNC(rb_cocos2dx_ParticleSystem_setAngle));

    rb_define_method_bridge(classValue,"angle=",RB_FUNC(rb_cocos2dx_ParticleSystem_setAngle));
	

	rb_define_method_bridge(classValue,"setBatchNode",RB_FUNC(rb_cocos2dx_ParticleSystem_setBatchNode));

    rb_define_method_bridge(classValue,"batchNode=",RB_FUNC(rb_cocos2dx_ParticleSystem_setBatchNode));
	

	rb_define_method_bridge(classValue,"getTangentialAccelVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getTangentialAccelVar));

   rb_define_method_bridge(classValue,"tangentialAccelVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getTangentialAccelVar));
	

	rb_define_method_bridge(classValue,"getEmitterMode",RB_FUNC(rb_cocos2dx_ParticleSystem_getEmitterMode));

   rb_define_method_bridge(classValue,"emitterMode",RB_FUNC(rb_cocos2dx_ParticleSystem_getEmitterMode));
	

	rb_define_method_bridge(classValue,"setEndSpinVar",RB_FUNC(rb_cocos2dx_ParticleSystem_setEndSpinVar));

    rb_define_method_bridge(classValue,"endSpinVar=",RB_FUNC(rb_cocos2dx_ParticleSystem_setEndSpinVar));
	

	rb_define_method_bridge(classValue,"getAngleVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getAngleVar));

   rb_define_method_bridge(classValue,"angleVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getAngleVar));
	

	rb_define_method_bridge(classValue,"setStartColor",RB_FUNC(rb_cocos2dx_ParticleSystem_setStartColor));

    rb_define_method_bridge(classValue,"startColor=",RB_FUNC(rb_cocos2dx_ParticleSystem_setStartColor));
	

	rb_define_method_bridge(classValue,"getRotatePerSecondVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getRotatePerSecondVar));

   rb_define_method_bridge(classValue,"rotatePerSecondVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getRotatePerSecondVar));
	

	rb_define_method_bridge(classValue,"getEndSize",RB_FUNC(rb_cocos2dx_ParticleSystem_getEndSize));

   rb_define_method_bridge(classValue,"endSize",RB_FUNC(rb_cocos2dx_ParticleSystem_getEndSize));
	

	rb_define_method_bridge(classValue,"getLife",RB_FUNC(rb_cocos2dx_ParticleSystem_getLife));

   rb_define_method_bridge(classValue,"life",RB_FUNC(rb_cocos2dx_ParticleSystem_getLife));
	

	rb_define_method_bridge(classValue,"setSpeedVar",RB_FUNC(rb_cocos2dx_ParticleSystem_setSpeedVar));

    rb_define_method_bridge(classValue,"speedVar=",RB_FUNC(rb_cocos2dx_ParticleSystem_setSpeedVar));
	

	rb_define_method_bridge(classValue,"setAutoRemoveOnFinish",RB_FUNC(rb_cocos2dx_ParticleSystem_setAutoRemoveOnFinish));

    rb_define_method_bridge(classValue,"autoRemoveOnFinish=",RB_FUNC(rb_cocos2dx_ParticleSystem_setAutoRemoveOnFinish));
	

	rb_define_method_bridge(classValue,"setGravity",RB_FUNC(rb_cocos2dx_ParticleSystem_setGravity));

    rb_define_method_bridge(classValue,"gravity=",RB_FUNC(rb_cocos2dx_ParticleSystem_setGravity));
	

	rb_define_method_bridge(classValue,"postStep",RB_FUNC(rb_cocos2dx_ParticleSystem_postStep));

	

	rb_define_method_bridge(classValue,"setEmissionRate",RB_FUNC(rb_cocos2dx_ParticleSystem_setEmissionRate));

    rb_define_method_bridge(classValue,"emissionRate=",RB_FUNC(rb_cocos2dx_ParticleSystem_setEmissionRate));
	

	rb_define_method_bridge(classValue,"getEndColorVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getEndColorVar));

   rb_define_method_bridge(classValue,"endColorVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getEndColorVar));
	

	rb_define_method_bridge(classValue,"getRotationIsDir",RB_FUNC(rb_cocos2dx_ParticleSystem_getRotationIsDir));

   rb_define_method_bridge(classValue,"rotationIsDir",RB_FUNC(rb_cocos2dx_ParticleSystem_getRotationIsDir));
	

	rb_define_method_bridge(classValue,"setScale",RB_FUNC(rb_cocos2dx_ParticleSystem_setScale));

    rb_define_method_bridge(classValue,"scale=",RB_FUNC(rb_cocos2dx_ParticleSystem_setScale));
	

	rb_define_method_bridge(classValue,"getEmissionRate",RB_FUNC(rb_cocos2dx_ParticleSystem_getEmissionRate));

   rb_define_method_bridge(classValue,"emissionRate",RB_FUNC(rb_cocos2dx_ParticleSystem_getEmissionRate));
	

	rb_define_method_bridge(classValue,"getEndColor",RB_FUNC(rb_cocos2dx_ParticleSystem_getEndColor));

   rb_define_method_bridge(classValue,"endColor",RB_FUNC(rb_cocos2dx_ParticleSystem_getEndColor));
	

	rb_define_method_bridge(classValue,"getLifeVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getLifeVar));

   rb_define_method_bridge(classValue,"lifeVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getLifeVar));
	

	rb_define_method_bridge(classValue,"setStartSizeVar",RB_FUNC(rb_cocos2dx_ParticleSystem_setStartSizeVar));

    rb_define_method_bridge(classValue,"startSizeVar=",RB_FUNC(rb_cocos2dx_ParticleSystem_setStartSizeVar));
	

	rb_define_method_bridge(classValue,"setOpacityModifyRGB",RB_FUNC(rb_cocos2dx_ParticleSystem_setOpacityModifyRGB));

    rb_define_method_bridge(classValue,"opacityModifyRGB=",RB_FUNC(rb_cocos2dx_ParticleSystem_setOpacityModifyRGB));
	

	rb_define_method_bridge(classValue,"addParticle",RB_FUNC(rb_cocos2dx_ParticleSystem_addParticle));

	

	rb_define_method_bridge(classValue,"getStartRadius",RB_FUNC(rb_cocos2dx_ParticleSystem_getStartRadius));

   rb_define_method_bridge(classValue,"startRadius",RB_FUNC(rb_cocos2dx_ParticleSystem_getStartRadius));
	

	rb_define_method_bridge(classValue,"getParticleCount",RB_FUNC(rb_cocos2dx_ParticleSystem_getParticleCount));

   rb_define_method_bridge(classValue,"particleCount",RB_FUNC(rb_cocos2dx_ParticleSystem_getParticleCount));
	

	rb_define_method_bridge(classValue,"getStartRadiusVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getStartRadiusVar));

   rb_define_method_bridge(classValue,"startRadiusVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getStartRadiusVar));
	

	rb_define_method_bridge(classValue,"setStartColorVar",RB_FUNC(rb_cocos2dx_ParticleSystem_setStartColorVar));

    rb_define_method_bridge(classValue,"startColorVar=",RB_FUNC(rb_cocos2dx_ParticleSystem_setStartColorVar));
	

	rb_define_method_bridge(classValue,"setEndSpin",RB_FUNC(rb_cocos2dx_ParticleSystem_setEndSpin));

    rb_define_method_bridge(classValue,"endSpin=",RB_FUNC(rb_cocos2dx_ParticleSystem_setEndSpin));
	

	rb_define_method_bridge(classValue,"setRadialAccel",RB_FUNC(rb_cocos2dx_ParticleSystem_setRadialAccel));

    rb_define_method_bridge(classValue,"radialAccel=",RB_FUNC(rb_cocos2dx_ParticleSystem_setRadialAccel));
	

	rb_define_method_bridge(classValue,"isAutoRemoveOnFinish",RB_FUNC(rb_cocos2dx_ParticleSystem_isAutoRemoveOnFinish));

	

	rb_define_method_bridge(classValue,"getTotalParticles",RB_FUNC(rb_cocos2dx_ParticleSystem_getTotalParticles));

   rb_define_method_bridge(classValue,"totalParticles",RB_FUNC(rb_cocos2dx_ParticleSystem_getTotalParticles));
	

	rb_define_method_bridge(classValue,"setStartRadiusVar",RB_FUNC(rb_cocos2dx_ParticleSystem_setStartRadiusVar));

    rb_define_method_bridge(classValue,"startRadiusVar=",RB_FUNC(rb_cocos2dx_ParticleSystem_setStartRadiusVar));
	

	rb_define_method_bridge(classValue,"getEndRadiusVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getEndRadiusVar));

   rb_define_method_bridge(classValue,"endRadiusVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getEndRadiusVar));
	

	rb_define_method_bridge(classValue,"getStartColorVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getStartColorVar));

   rb_define_method_bridge(classValue,"startColorVar",RB_FUNC(rb_cocos2dx_ParticleSystem_getStartColorVar));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ParticleSystem_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTotalParticles",RB_FUNC(rb_cocos2dx_ParticleSystem_createWithTotalParticles));

	


	TypeTest<cocos2d::ParticleSystem> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ParticleSystem",classValue);
}
RBVAL rb_cocos2dx_ParticleSystemQuad_setDisplayFrame(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystemQuad* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystemQuad_setDisplayFrame : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::SpriteFrame* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystemQuad_setDisplayFrame : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDisplayFrame(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("displayFrame");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystemQuad_setDisplayFrame : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystemQuad_setTextureWithRect(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystemQuad* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystemQuad_setTextureWithRect : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::Texture2D* arg0;
			cocos2d::Rect arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_ccrect(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystemQuad_setTextureWithRect : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTextureWithRect(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystemQuad_setTextureWithRect : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystemQuad_listenRendererRecreated(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParticleSystemQuad* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystemQuad_listenRendererRecreated : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::EventCustom* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystemQuad_listenRendererRecreated : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->listenRendererRecreated(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParticleSystemQuad_listenRendererRecreated : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystemQuad_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::ParticleSystemQuad* ret = cocos2d::ParticleSystemQuad::create(arg0);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::ParticleSystemQuad>((cocos2d::ParticleSystemQuad*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 0) {
			cocos2d::ParticleSystemQuad* ret = cocos2d::ParticleSystemQuad::create();
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::ParticleSystemQuad>((cocos2d::ParticleSystemQuad*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 1) {
			cocos2d::ValueMap arg0;
			ok &= rb_value_to_ccvaluemap(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::ParticleSystemQuad* ret = cocos2d::ParticleSystemQuad::create(arg0);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::ParticleSystemQuad>((cocos2d::ParticleSystemQuad*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_ParticleSystemQuad_create : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParticleSystemQuad_createWithTotalParticles(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		int arg0;
		ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSystemQuad_createWithTotalParticles : Error processing arguments");return RBNil();}
		cocos2d::ParticleSystemQuad* ret = cocos2d::ParticleSystemQuad::createWithTotalParticles(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleSystemQuad>((cocos2d::ParticleSystemQuad*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleSystemQuad_createWithTotalParticles : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ParticleSystemQuad() {
		
	RBVAL classValue=rb_define_class_bridge("ParticleSystemQuad",rb_get_class_value("cocos2d::ParticleSystem"),true);

	rb_define_method_bridge(classValue,"setDisplayFrame",RB_FUNC(rb_cocos2dx_ParticleSystemQuad_setDisplayFrame));

    rb_define_method_bridge(classValue,"displayFrame=",RB_FUNC(rb_cocos2dx_ParticleSystemQuad_setDisplayFrame));
	

	rb_define_method_bridge(classValue,"setTextureWithRect",RB_FUNC(rb_cocos2dx_ParticleSystemQuad_setTextureWithRect));

    rb_define_method_bridge(classValue,"textureWithRect=",RB_FUNC(rb_cocos2dx_ParticleSystemQuad_setTextureWithRect));
	

	rb_define_method_bridge(classValue,"listenRendererRecreated",RB_FUNC(rb_cocos2dx_ParticleSystemQuad_listenRendererRecreated));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ParticleSystemQuad_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTotalParticles",RB_FUNC(rb_cocos2dx_ParticleSystemQuad_createWithTotalParticles));

	


	TypeTest<cocos2d::ParticleSystemQuad> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ParticleSystemQuad",classValue);
}
RBVAL rb_cocos2dx_ParticleFire_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::ParticleFire* ret = cocos2d::ParticleFire::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleFire>((cocos2d::ParticleFire*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleFire_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_ParticleFire_createWithTotalParticles(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		int arg0;
		ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleFire_createWithTotalParticles : Error processing arguments");return RBNil();}
		cocos2d::ParticleFire* ret = cocos2d::ParticleFire::createWithTotalParticles(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleFire>((cocos2d::ParticleFire*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleFire_createWithTotalParticles : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ParticleFire() {
		
	RBVAL classValue=rb_define_class_bridge("ParticleFire",rb_get_class_value("cocos2d::ParticleSystemQuad"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ParticleFire_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTotalParticles",RB_FUNC(rb_cocos2dx_ParticleFire_createWithTotalParticles));

	


	TypeTest<cocos2d::ParticleFire> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ParticleFire",classValue);
}
RBVAL rb_cocos2dx_ParticleFireworks_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::ParticleFireworks* ret = cocos2d::ParticleFireworks::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleFireworks>((cocos2d::ParticleFireworks*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleFireworks_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_ParticleFireworks_createWithTotalParticles(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		int arg0;
		ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleFireworks_createWithTotalParticles : Error processing arguments");return RBNil();}
		cocos2d::ParticleFireworks* ret = cocos2d::ParticleFireworks::createWithTotalParticles(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleFireworks>((cocos2d::ParticleFireworks*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleFireworks_createWithTotalParticles : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ParticleFireworks() {
		
	RBVAL classValue=rb_define_class_bridge("ParticleFireworks",rb_get_class_value("cocos2d::ParticleSystemQuad"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ParticleFireworks_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTotalParticles",RB_FUNC(rb_cocos2dx_ParticleFireworks_createWithTotalParticles));

	


	TypeTest<cocos2d::ParticleFireworks> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ParticleFireworks",classValue);
}
RBVAL rb_cocos2dx_ParticleSun_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::ParticleSun* ret = cocos2d::ParticleSun::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleSun>((cocos2d::ParticleSun*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleSun_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_ParticleSun_createWithTotalParticles(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		int arg0;
		ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSun_createWithTotalParticles : Error processing arguments");return RBNil();}
		cocos2d::ParticleSun* ret = cocos2d::ParticleSun::createWithTotalParticles(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleSun>((cocos2d::ParticleSun*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleSun_createWithTotalParticles : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ParticleSun() {
		
	RBVAL classValue=rb_define_class_bridge("ParticleSun",rb_get_class_value("cocos2d::ParticleSystemQuad"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ParticleSun_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTotalParticles",RB_FUNC(rb_cocos2dx_ParticleSun_createWithTotalParticles));

	


	TypeTest<cocos2d::ParticleSun> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ParticleSun",classValue);
}
RBVAL rb_cocos2dx_ParticleGalaxy_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::ParticleGalaxy* ret = cocos2d::ParticleGalaxy::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleGalaxy>((cocos2d::ParticleGalaxy*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleGalaxy_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_ParticleGalaxy_createWithTotalParticles(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		int arg0;
		ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleGalaxy_createWithTotalParticles : Error processing arguments");return RBNil();}
		cocos2d::ParticleGalaxy* ret = cocos2d::ParticleGalaxy::createWithTotalParticles(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleGalaxy>((cocos2d::ParticleGalaxy*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleGalaxy_createWithTotalParticles : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ParticleGalaxy() {
		
	RBVAL classValue=rb_define_class_bridge("ParticleGalaxy",rb_get_class_value("cocos2d::ParticleSystemQuad"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ParticleGalaxy_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTotalParticles",RB_FUNC(rb_cocos2dx_ParticleGalaxy_createWithTotalParticles));

	


	TypeTest<cocos2d::ParticleGalaxy> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ParticleGalaxy",classValue);
}
RBVAL rb_cocos2dx_ParticleFlower_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::ParticleFlower* ret = cocos2d::ParticleFlower::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleFlower>((cocos2d::ParticleFlower*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleFlower_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_ParticleFlower_createWithTotalParticles(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		int arg0;
		ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleFlower_createWithTotalParticles : Error processing arguments");return RBNil();}
		cocos2d::ParticleFlower* ret = cocos2d::ParticleFlower::createWithTotalParticles(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleFlower>((cocos2d::ParticleFlower*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleFlower_createWithTotalParticles : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ParticleFlower() {
		
	RBVAL classValue=rb_define_class_bridge("ParticleFlower",rb_get_class_value("cocos2d::ParticleSystemQuad"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ParticleFlower_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTotalParticles",RB_FUNC(rb_cocos2dx_ParticleFlower_createWithTotalParticles));

	


	TypeTest<cocos2d::ParticleFlower> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ParticleFlower",classValue);
}
RBVAL rb_cocos2dx_ParticleMeteor_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::ParticleMeteor* ret = cocos2d::ParticleMeteor::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleMeteor>((cocos2d::ParticleMeteor*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleMeteor_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_ParticleMeteor_createWithTotalParticles(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		int arg0;
		ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleMeteor_createWithTotalParticles : Error processing arguments");return RBNil();}
		cocos2d::ParticleMeteor* ret = cocos2d::ParticleMeteor::createWithTotalParticles(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleMeteor>((cocos2d::ParticleMeteor*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleMeteor_createWithTotalParticles : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ParticleMeteor() {
		
	RBVAL classValue=rb_define_class_bridge("ParticleMeteor",rb_get_class_value("cocos2d::ParticleSystemQuad"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ParticleMeteor_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTotalParticles",RB_FUNC(rb_cocos2dx_ParticleMeteor_createWithTotalParticles));

	


	TypeTest<cocos2d::ParticleMeteor> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ParticleMeteor",classValue);
}
RBVAL rb_cocos2dx_ParticleSpiral_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::ParticleSpiral* ret = cocos2d::ParticleSpiral::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleSpiral>((cocos2d::ParticleSpiral*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleSpiral_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_ParticleSpiral_createWithTotalParticles(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		int arg0;
		ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSpiral_createWithTotalParticles : Error processing arguments");return RBNil();}
		cocos2d::ParticleSpiral* ret = cocos2d::ParticleSpiral::createWithTotalParticles(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleSpiral>((cocos2d::ParticleSpiral*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleSpiral_createWithTotalParticles : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ParticleSpiral() {
		
	RBVAL classValue=rb_define_class_bridge("ParticleSpiral",rb_get_class_value("cocos2d::ParticleSystemQuad"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ParticleSpiral_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTotalParticles",RB_FUNC(rb_cocos2dx_ParticleSpiral_createWithTotalParticles));

	


	TypeTest<cocos2d::ParticleSpiral> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ParticleSpiral",classValue);
}
RBVAL rb_cocos2dx_ParticleExplosion_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::ParticleExplosion* ret = cocos2d::ParticleExplosion::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleExplosion>((cocos2d::ParticleExplosion*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleExplosion_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_ParticleExplosion_createWithTotalParticles(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		int arg0;
		ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleExplosion_createWithTotalParticles : Error processing arguments");return RBNil();}
		cocos2d::ParticleExplosion* ret = cocos2d::ParticleExplosion::createWithTotalParticles(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleExplosion>((cocos2d::ParticleExplosion*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleExplosion_createWithTotalParticles : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ParticleExplosion() {
		
	RBVAL classValue=rb_define_class_bridge("ParticleExplosion",rb_get_class_value("cocos2d::ParticleSystemQuad"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ParticleExplosion_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTotalParticles",RB_FUNC(rb_cocos2dx_ParticleExplosion_createWithTotalParticles));

	


	TypeTest<cocos2d::ParticleExplosion> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ParticleExplosion",classValue);
}
RBVAL rb_cocos2dx_ParticleSmoke_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::ParticleSmoke* ret = cocos2d::ParticleSmoke::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleSmoke>((cocos2d::ParticleSmoke*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleSmoke_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_ParticleSmoke_createWithTotalParticles(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		int arg0;
		ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSmoke_createWithTotalParticles : Error processing arguments");return RBNil();}
		cocos2d::ParticleSmoke* ret = cocos2d::ParticleSmoke::createWithTotalParticles(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleSmoke>((cocos2d::ParticleSmoke*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleSmoke_createWithTotalParticles : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ParticleSmoke() {
		
	RBVAL classValue=rb_define_class_bridge("ParticleSmoke",rb_get_class_value("cocos2d::ParticleSystemQuad"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ParticleSmoke_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTotalParticles",RB_FUNC(rb_cocos2dx_ParticleSmoke_createWithTotalParticles));

	


	TypeTest<cocos2d::ParticleSmoke> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ParticleSmoke",classValue);
}
RBVAL rb_cocos2dx_ParticleSnow_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::ParticleSnow* ret = cocos2d::ParticleSnow::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleSnow>((cocos2d::ParticleSnow*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleSnow_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_ParticleSnow_createWithTotalParticles(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		int arg0;
		ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleSnow_createWithTotalParticles : Error processing arguments");return RBNil();}
		cocos2d::ParticleSnow* ret = cocos2d::ParticleSnow::createWithTotalParticles(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleSnow>((cocos2d::ParticleSnow*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleSnow_createWithTotalParticles : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ParticleSnow() {
		
	RBVAL classValue=rb_define_class_bridge("ParticleSnow",rb_get_class_value("cocos2d::ParticleSystemQuad"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ParticleSnow_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTotalParticles",RB_FUNC(rb_cocos2dx_ParticleSnow_createWithTotalParticles));

	


	TypeTest<cocos2d::ParticleSnow> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ParticleSnow",classValue);
}
RBVAL rb_cocos2dx_ParticleRain_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::ParticleRain* ret = cocos2d::ParticleRain::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleRain>((cocos2d::ParticleRain*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleRain_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_ParticleRain_createWithTotalParticles(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		int arg0;
		ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParticleRain_createWithTotalParticles : Error processing arguments");return RBNil();}
		cocos2d::ParticleRain* ret = cocos2d::ParticleRain::createWithTotalParticles(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParticleRain>((cocos2d::ParticleRain*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParticleRain_createWithTotalParticles : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ParticleRain() {
		
	RBVAL classValue=rb_define_class_bridge("ParticleRain",rb_get_class_value("cocos2d::ParticleSystemQuad"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ParticleRain_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithTotalParticles",RB_FUNC(rb_cocos2dx_ParticleRain_createWithTotalParticles));

	


	TypeTest<cocos2d::ParticleRain> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ParticleRain",classValue);
}
RBVAL rb_cocos2dx_GridBase_setGridSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_setGridSize : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Size arg0;
			ok &= rb_value_to_ccsize(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_setGridSize : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setGridSize(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("gridSize");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_setGridSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_afterBlit(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_afterBlit : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->afterBlit();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_afterBlit : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_afterDraw(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_afterDraw : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_afterDraw : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->afterDraw(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_afterDraw : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_beforeDraw(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_beforeDraw : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->beforeDraw();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_beforeDraw : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_calculateVertexPoints(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_calculateVertexPoints : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->calculateVertexPoints();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_calculateVertexPoints : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_isTextureFlipped(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_isTextureFlipped : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isTextureFlipped();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_isTextureFlipped : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_getGridSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_getGridSize : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Size& ret = cobj->getGridSize();
				value = ccsize_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_getGridSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_getStep(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_getStep : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Vec2& ret = cobj->getStep();
				value = vec2_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_getStep : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_set2DProjection(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_set2DProjection : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->set2DProjection();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_set2DProjection : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_setStep(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_setStep : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec2 arg0;
			ok &= rb_value_to_vec2(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_setStep : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setStep(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("step");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_setStep : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_setTextureFlipped(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_setTextureFlipped : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_setTextureFlipped : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setTextureFlipped(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("textureFlipped");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_setTextureFlipped : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_blit(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_blit : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->blit();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_blit : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_setActive(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_setActive : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_setActive : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setActive(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("active");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_setActive : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_getReuseGrid(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_getReuseGrid : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = cobj->getReuseGrid();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_getReuseGrid : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_initWithSize(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_initWithSize : self ptr is null");return RBNil();}
	do {
		if (argc == 1) {
			cocos2d::Size arg0;
			ok &= rb_value_to_ccsize(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_initWithSize : Error processing argument 1 ( 1 )");return RBNil(); }
			bool ret = cobj->initWithSize(arg0);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	do {
		if (argc == 3) {
			cocos2d::Size arg0;
			ok &= rb_value_to_ccsize(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_initWithSize : Error processing argument 1 ( 3 )");return RBNil(); }
			cocos2d::Texture2D* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_initWithSize : Error processing argument 2 ( 3 )");return RBNil(); }
			bool arg2;
			ok &= rb_value_to_bool(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_initWithSize : Error processing argument 3 ( 3 )");return RBNil(); }
			bool ret = cobj->initWithSize(arg0, arg1, arg2);
			RBVAL value = RBNil();
			value = bool_to_rb_value(ret);
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_GridBase_initWithSize : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_beforeBlit(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_beforeBlit : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->beforeBlit();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_beforeBlit : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_setReuseGrid(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_setReuseGrid : self ptr is null");return RBNil();}
		if (argc == 1) {
			int arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_setReuseGrid : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setReuseGrid(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("reuseGrid");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_setReuseGrid : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_isActive(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_isActive : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isActive();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_isActive : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_reuse(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GridBase* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GridBase_reuse : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->reuse();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GridBase_reuse : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GridBase_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 1) {
			cocos2d::Size arg0;
			ok &= rb_value_to_ccsize(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::GridBase* ret = cocos2d::GridBase::create(arg0);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::GridBase>((cocos2d::GridBase*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 3) {
			cocos2d::Size arg0;
			ok &= rb_value_to_ccsize(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Texture2D* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			bool arg2;
			ok &= rb_value_to_bool(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::GridBase* ret = cocos2d::GridBase::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::GridBase>((cocos2d::GridBase*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_GridBase_create : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_GridBase() {
		
	RBVAL classValue=rb_define_class_bridge("GridBase",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"setGridSize",RB_FUNC(rb_cocos2dx_GridBase_setGridSize));

    rb_define_method_bridge(classValue,"gridSize=",RB_FUNC(rb_cocos2dx_GridBase_setGridSize));
	

	rb_define_method_bridge(classValue,"afterBlit",RB_FUNC(rb_cocos2dx_GridBase_afterBlit));

	

	rb_define_method_bridge(classValue,"afterDraw",RB_FUNC(rb_cocos2dx_GridBase_afterDraw));

	

	rb_define_method_bridge(classValue,"beforeDraw",RB_FUNC(rb_cocos2dx_GridBase_beforeDraw));

	

	rb_define_method_bridge(classValue,"calculateVertexPoints",RB_FUNC(rb_cocos2dx_GridBase_calculateVertexPoints));

	

	rb_define_method_bridge(classValue,"isTextureFlipped",RB_FUNC(rb_cocos2dx_GridBase_isTextureFlipped));

	

	rb_define_method_bridge(classValue,"getGridSize",RB_FUNC(rb_cocos2dx_GridBase_getGridSize));

   rb_define_method_bridge(classValue,"gridSize",RB_FUNC(rb_cocos2dx_GridBase_getGridSize));
	

	rb_define_method_bridge(classValue,"getStep",RB_FUNC(rb_cocos2dx_GridBase_getStep));

   rb_define_method_bridge(classValue,"step",RB_FUNC(rb_cocos2dx_GridBase_getStep));
	

	rb_define_method_bridge(classValue,"set2DProjection",RB_FUNC(rb_cocos2dx_GridBase_set2DProjection));

    rb_define_method_bridge(classValue,"2DProjection=",RB_FUNC(rb_cocos2dx_GridBase_set2DProjection));
	

	rb_define_method_bridge(classValue,"setStep",RB_FUNC(rb_cocos2dx_GridBase_setStep));

    rb_define_method_bridge(classValue,"step=",RB_FUNC(rb_cocos2dx_GridBase_setStep));
	

	rb_define_method_bridge(classValue,"setTextureFlipped",RB_FUNC(rb_cocos2dx_GridBase_setTextureFlipped));

    rb_define_method_bridge(classValue,"textureFlipped=",RB_FUNC(rb_cocos2dx_GridBase_setTextureFlipped));
	

	rb_define_method_bridge(classValue,"blit",RB_FUNC(rb_cocos2dx_GridBase_blit));

	

	rb_define_method_bridge(classValue,"setActive",RB_FUNC(rb_cocos2dx_GridBase_setActive));

    rb_define_method_bridge(classValue,"active=",RB_FUNC(rb_cocos2dx_GridBase_setActive));
	

	rb_define_method_bridge(classValue,"getReuseGrid",RB_FUNC(rb_cocos2dx_GridBase_getReuseGrid));

   rb_define_method_bridge(classValue,"reuseGrid",RB_FUNC(rb_cocos2dx_GridBase_getReuseGrid));
	

	rb_define_method_bridge(classValue,"initWithSize",RB_FUNC(rb_cocos2dx_GridBase_initWithSize));

	

	rb_define_method_bridge(classValue,"beforeBlit",RB_FUNC(rb_cocos2dx_GridBase_beforeBlit));

	

	rb_define_method_bridge(classValue,"setReuseGrid",RB_FUNC(rb_cocos2dx_GridBase_setReuseGrid));

    rb_define_method_bridge(classValue,"reuseGrid=",RB_FUNC(rb_cocos2dx_GridBase_setReuseGrid));
	

	rb_define_method_bridge(classValue,"isActive",RB_FUNC(rb_cocos2dx_GridBase_isActive));

	

	rb_define_method_bridge(classValue,"reuse",RB_FUNC(rb_cocos2dx_GridBase_reuse));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_GridBase_create));

	


	TypeTest<cocos2d::GridBase> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::GridBase",classValue);
}
RBVAL rb_cocos2dx_Grid3D_getNeedDepthTestForBlit(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Grid3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Grid3D_getNeedDepthTestForBlit : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->getNeedDepthTestForBlit();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Grid3D_getNeedDepthTestForBlit : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Grid3D_setNeedDepthTestForBlit(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Grid3D* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Grid3D_setNeedDepthTestForBlit : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Grid3D_setNeedDepthTestForBlit : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setNeedDepthTestForBlit(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("needDepthTestForBlit");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Grid3D_setNeedDepthTestForBlit : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Grid3D_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 1) {
			cocos2d::Size arg0;
			ok &= rb_value_to_ccsize(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Grid3D* ret = cocos2d::Grid3D::create(arg0);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::Grid3D>((cocos2d::Grid3D*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 3) {
			cocos2d::Size arg0;
			ok &= rb_value_to_ccsize(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Texture2D* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			bool arg2;
			ok &= rb_value_to_bool(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::Grid3D* ret = cocos2d::Grid3D::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::Grid3D>((cocos2d::Grid3D*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_Grid3D_create : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Grid3D_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::Grid3D> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::Grid3D* cobj = new cocos2d::Grid3D();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Grid3D_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Grid3D() {
		
	RBVAL classValue=rb_define_class_bridge("Grid3D",rb_get_class_value("cocos2d::GridBase"),true);

	rb_define_method_bridge(classValue,"getNeedDepthTestForBlit",RB_FUNC(rb_cocos2dx_Grid3D_getNeedDepthTestForBlit));

   rb_define_method_bridge(classValue,"needDepthTestForBlit",RB_FUNC(rb_cocos2dx_Grid3D_getNeedDepthTestForBlit));
	

	rb_define_method_bridge(classValue,"setNeedDepthTestForBlit",RB_FUNC(rb_cocos2dx_Grid3D_setNeedDepthTestForBlit));

    rb_define_method_bridge(classValue,"needDepthTestForBlit=",RB_FUNC(rb_cocos2dx_Grid3D_setNeedDepthTestForBlit));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Grid3D_create));

	

	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_Grid3D_constructor));

	TypeTest<cocos2d::Grid3D> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Grid3D",classValue);
}
RBVAL rb_cocos2dx_TiledGrid3D_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	
	do {
		if (argc == 1) {
			cocos2d::Size arg0;
			ok &= rb_value_to_ccsize(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::TiledGrid3D* ret = cocos2d::TiledGrid3D::create(arg0);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TiledGrid3D>((cocos2d::TiledGrid3D*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	
	do {
		if (argc == 3) {
			cocos2d::Size arg0;
			ok &= rb_value_to_ccsize(argv[0], &arg0);
			if (!ok) { break; }
			cocos2d::Texture2D* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) { break; }
			bool arg2;
			ok &= rb_value_to_bool(argv[2], &arg2);
			if (!ok) { break; }
			cocos2d::TiledGrid3D* ret = cocos2d::TiledGrid3D::create(arg0, arg1, arg2);
			RBVAL value=RBNil();
							if (ret) {
					value = rbb_get_or_create_value<cocos2d::TiledGrid3D>((cocos2d::TiledGrid3D*)ret);
				} else {
					value = RBNil();
				};
			return value;
		}
	} while (0);
	rb_raise_arg_error("rb_cocos2dx_TiledGrid3D_create : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TiledGrid3D_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::TiledGrid3D> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::TiledGrid3D* cobj = new cocos2d::TiledGrid3D();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TiledGrid3D_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TiledGrid3D() {
		
	RBVAL classValue=rb_define_class_bridge("TiledGrid3D",rb_get_class_value("cocos2d::GridBase"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_TiledGrid3D_create));

	

	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_TiledGrid3D_constructor));

	TypeTest<cocos2d::TiledGrid3D> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TiledGrid3D",classValue);
}
RBVAL rb_cocos2dx_Camera_getProjectionMatrix(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Camera* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Camera_getProjectionMatrix : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Mat4& ret = cobj->getProjectionMatrix();
				value = mat4_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Camera_getProjectionMatrix : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Camera_getViewProjectionMatrix(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Camera* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Camera_getViewProjectionMatrix : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Mat4& ret = cobj->getViewProjectionMatrix();
				value = mat4_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Camera_getViewProjectionMatrix : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Camera_getViewMatrix(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Camera* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Camera_getViewMatrix : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const cocos2d::Mat4& ret = cobj->getViewMatrix();
				value = mat4_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Camera_getViewMatrix : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Camera_getCameraFlag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Camera* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Camera_getCameraFlag : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getCameraFlag();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Camera_getCameraFlag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Camera_getType(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Camera* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Camera_getType : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getType();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Camera_getType : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Camera_lookAt(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Camera* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Camera_lookAt : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::Vec3 arg0;
			cocos2d::Vec3 arg1;
			ok &= rb_value_to_vec3(argv[0], &arg0);
			ok &= rb_value_to_vec3(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Camera_lookAt : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->lookAt(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Camera_lookAt : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Camera_setCameraFlag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Camera* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Camera_setCameraFlag : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::CameraFlag arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Camera_setCameraFlag : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setCameraFlag(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("cameraFlag");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Camera_setCameraFlag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Camera_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::Camera* ret = cocos2d::Camera::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Camera>((cocos2d::Camera*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Camera_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_Camera_createPerspective(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 4) {
		float arg0;
		float arg1;
		float arg2;
		float arg3;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_float(argv[1], &arg1);
		ok &= rb_value_to_float(argv[2], &arg2);
		ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Camera_createPerspective : Error processing arguments");return RBNil();}
		cocos2d::Camera* ret = cocos2d::Camera::createPerspective(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Camera>((cocos2d::Camera*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Camera_createPerspective : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_Camera_createOrthographic(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 4) {
		float arg0;
		float arg1;
		float arg2;
		float arg3;
		ok &= rb_value_to_float(argv[0], &arg0);
		ok &= rb_value_to_float(argv[1], &arg1);
		ok &= rb_value_to_float(argv[2], &arg2);
		ok &= rb_value_to_float(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Camera_createOrthographic : Error processing arguments");return RBNil();}
		cocos2d::Camera* ret = cocos2d::Camera::createOrthographic(arg0, arg1, arg2, arg3);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Camera>((cocos2d::Camera*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Camera_createOrthographic : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_Camera_getVisitingCamera(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		const cocos2d::Camera* ret = cocos2d::Camera::getVisitingCamera();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Camera>((cocos2d::Camera*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Camera_getVisitingCamera : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Camera() {
		
	RBVAL classValue=rb_define_class_bridge("Camera",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"getProjectionMatrix",RB_FUNC(rb_cocos2dx_Camera_getProjectionMatrix));

   rb_define_method_bridge(classValue,"projectionMatrix",RB_FUNC(rb_cocos2dx_Camera_getProjectionMatrix));
	

	rb_define_method_bridge(classValue,"getViewProjectionMatrix",RB_FUNC(rb_cocos2dx_Camera_getViewProjectionMatrix));

   rb_define_method_bridge(classValue,"viewProjectionMatrix",RB_FUNC(rb_cocos2dx_Camera_getViewProjectionMatrix));
	

	rb_define_method_bridge(classValue,"getViewMatrix",RB_FUNC(rb_cocos2dx_Camera_getViewMatrix));

   rb_define_method_bridge(classValue,"viewMatrix",RB_FUNC(rb_cocos2dx_Camera_getViewMatrix));
	

	rb_define_method_bridge(classValue,"getCameraFlag",RB_FUNC(rb_cocos2dx_Camera_getCameraFlag));

   rb_define_method_bridge(classValue,"cameraFlag",RB_FUNC(rb_cocos2dx_Camera_getCameraFlag));
	

	rb_define_method_bridge(classValue,"getType",RB_FUNC(rb_cocos2dx_Camera_getType));

   rb_define_method_bridge(classValue,"type",RB_FUNC(rb_cocos2dx_Camera_getType));
	

	rb_define_method_bridge(classValue,"lookAt",RB_FUNC(rb_cocos2dx_Camera_lookAt));

	

	rb_define_method_bridge(classValue,"setCameraFlag",RB_FUNC(rb_cocos2dx_Camera_setCameraFlag));

    rb_define_method_bridge(classValue,"cameraFlag=",RB_FUNC(rb_cocos2dx_Camera_setCameraFlag));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Camera_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createPerspective",RB_FUNC(rb_cocos2dx_Camera_createPerspective));

	
	

	rb_define_singleton_method_bridge(classValue,"createOrthographic",RB_FUNC(rb_cocos2dx_Camera_createOrthographic));

	
	

	rb_define_singleton_method_bridge(classValue,"getVisitingCamera",RB_FUNC(rb_cocos2dx_Camera_getVisitingCamera));

   rb_define_singleton_method_bridge(classValue,"visitingCamera",RB_FUNC(rb_cocos2dx_Camera_getVisitingCamera));
	


	TypeTest<cocos2d::Camera> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Camera",classValue);
}
RBVAL rb_cocos2dx_BaseLight_setEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::BaseLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_BaseLight_setEnabled : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_BaseLight_setEnabled : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEnabled(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("enabled");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_BaseLight_setEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_BaseLight_getIntensity(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::BaseLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_BaseLight_getIntensity : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getIntensity();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_BaseLight_getIntensity : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_BaseLight_isEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::BaseLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_BaseLight_isEnabled : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isEnabled();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_BaseLight_isEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_BaseLight_getLightType(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::BaseLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_BaseLight_getLightType : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getLightType();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_BaseLight_getLightType : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_BaseLight_setLightFlag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::BaseLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_BaseLight_setLightFlag : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::LightFlag arg0;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_BaseLight_setLightFlag : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setLightFlag(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("lightFlag");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_BaseLight_setLightFlag : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_BaseLight_setIntensity(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::BaseLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_BaseLight_setIntensity : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_BaseLight_setIntensity : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setIntensity(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("intensity");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_BaseLight_setIntensity : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_BaseLight_getLightFlag(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::BaseLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_BaseLight_getLightFlag : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getLightFlag();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_BaseLight_getLightFlag : wrong number of arguments");
	return RBNil();
}


void rb_register_cocos2dx_BaseLight() {
		
	RBVAL classValue=rb_define_class_bridge("BaseLight",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"setEnabled",RB_FUNC(rb_cocos2dx_BaseLight_setEnabled));

    rb_define_method_bridge(classValue,"enabled=",RB_FUNC(rb_cocos2dx_BaseLight_setEnabled));
	

	rb_define_method_bridge(classValue,"getIntensity",RB_FUNC(rb_cocos2dx_BaseLight_getIntensity));

   rb_define_method_bridge(classValue,"intensity",RB_FUNC(rb_cocos2dx_BaseLight_getIntensity));
	

	rb_define_method_bridge(classValue,"isEnabled",RB_FUNC(rb_cocos2dx_BaseLight_isEnabled));

	

	rb_define_method_bridge(classValue,"getLightType",RB_FUNC(rb_cocos2dx_BaseLight_getLightType));

   rb_define_method_bridge(classValue,"lightType",RB_FUNC(rb_cocos2dx_BaseLight_getLightType));
	

	rb_define_method_bridge(classValue,"setLightFlag",RB_FUNC(rb_cocos2dx_BaseLight_setLightFlag));

    rb_define_method_bridge(classValue,"lightFlag=",RB_FUNC(rb_cocos2dx_BaseLight_setLightFlag));
	

	rb_define_method_bridge(classValue,"setIntensity",RB_FUNC(rb_cocos2dx_BaseLight_setIntensity));

    rb_define_method_bridge(classValue,"intensity=",RB_FUNC(rb_cocos2dx_BaseLight_setIntensity));
	

	rb_define_method_bridge(classValue,"getLightFlag",RB_FUNC(rb_cocos2dx_BaseLight_getLightFlag));

   rb_define_method_bridge(classValue,"lightFlag",RB_FUNC(rb_cocos2dx_BaseLight_getLightFlag));
	



	TypeTest<cocos2d::BaseLight> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::BaseLight",classValue);
}
RBVAL rb_cocos2dx_DirectionLight_getDirection(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::DirectionLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DirectionLight_getDirection : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec3 ret = cobj->getDirection();
				value = vec3_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_DirectionLight_getDirection : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DirectionLight_getDirectionInWorld(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::DirectionLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DirectionLight_getDirectionInWorld : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec3 ret = cobj->getDirectionInWorld();
				value = vec3_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_DirectionLight_getDirectionInWorld : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DirectionLight_setDirection(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::DirectionLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_DirectionLight_setDirection : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec3 arg0;
			ok &= rb_value_to_vec3(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DirectionLight_setDirection : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDirection(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("direction");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_DirectionLight_setDirection : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_DirectionLight_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		cocos2d::Vec3 arg0;
		cocos2d::Color3B arg1;
		ok &= rb_value_to_vec3(argv[0], &arg0);
		ok &= rb_value_to_cccolor3b(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_DirectionLight_create : Error processing arguments");return RBNil();}
		cocos2d::DirectionLight* ret = cocos2d::DirectionLight::create(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::DirectionLight>((cocos2d::DirectionLight*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_DirectionLight_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_DirectionLight() {
		
	RBVAL classValue=rb_define_class_bridge("DirectionLight",rb_get_class_value("cocos2d::BaseLight"),true);

	rb_define_method_bridge(classValue,"getDirection",RB_FUNC(rb_cocos2dx_DirectionLight_getDirection));

   rb_define_method_bridge(classValue,"direction",RB_FUNC(rb_cocos2dx_DirectionLight_getDirection));
	

	rb_define_method_bridge(classValue,"getDirectionInWorld",RB_FUNC(rb_cocos2dx_DirectionLight_getDirectionInWorld));

   rb_define_method_bridge(classValue,"directionInWorld",RB_FUNC(rb_cocos2dx_DirectionLight_getDirectionInWorld));
	

	rb_define_method_bridge(classValue,"setDirection",RB_FUNC(rb_cocos2dx_DirectionLight_setDirection));

    rb_define_method_bridge(classValue,"direction=",RB_FUNC(rb_cocos2dx_DirectionLight_setDirection));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_DirectionLight_create));

	


	TypeTest<cocos2d::DirectionLight> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::DirectionLight",classValue);
}
RBVAL rb_cocos2dx_PointLight_getRange(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::PointLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_PointLight_getRange : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getRange();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_PointLight_getRange : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_PointLight_setRange(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::PointLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_PointLight_setRange : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_PointLight_setRange : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRange(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("range");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_PointLight_setRange : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_PointLight_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 3) {
		cocos2d::Vec3 arg0;
		cocos2d::Color3B arg1;
		float arg2;
		ok &= rb_value_to_vec3(argv[0], &arg0);
		ok &= rb_value_to_cccolor3b(argv[1], &arg1);
		ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_PointLight_create : Error processing arguments");return RBNil();}
		cocos2d::PointLight* ret = cocos2d::PointLight::create(arg0, arg1, arg2);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::PointLight>((cocos2d::PointLight*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_PointLight_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_PointLight() {
		
	RBVAL classValue=rb_define_class_bridge("PointLight",rb_get_class_value("cocos2d::BaseLight"),true);

	rb_define_method_bridge(classValue,"getRange",RB_FUNC(rb_cocos2dx_PointLight_getRange));

   rb_define_method_bridge(classValue,"range",RB_FUNC(rb_cocos2dx_PointLight_getRange));
	

	rb_define_method_bridge(classValue,"setRange",RB_FUNC(rb_cocos2dx_PointLight_setRange));

    rb_define_method_bridge(classValue,"range=",RB_FUNC(rb_cocos2dx_PointLight_setRange));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_PointLight_create));

	


	TypeTest<cocos2d::PointLight> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::PointLight",classValue);
}
RBVAL rb_cocos2dx_SpotLight_getRange(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpotLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpotLight_getRange : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getRange();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpotLight_getRange : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpotLight_setDirection(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpotLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpotLight_setDirection : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Vec3 arg0;
			ok &= rb_value_to_vec3(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpotLight_setDirection : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setDirection(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("direction");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpotLight_setDirection : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpotLight_getCosInnerAngle(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpotLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpotLight_getCosInnerAngle : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getCosInnerAngle();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpotLight_getCosInnerAngle : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpotLight_getOuterAngle(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpotLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpotLight_getOuterAngle : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getOuterAngle();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpotLight_getOuterAngle : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpotLight_getInnerAngle(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpotLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpotLight_getInnerAngle : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getInnerAngle();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpotLight_getInnerAngle : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpotLight_getDirection(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpotLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpotLight_getDirection : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec3 ret = cobj->getDirection();
				value = vec3_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpotLight_getDirection : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpotLight_getCosOuterAngle(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpotLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpotLight_getCosOuterAngle : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					float ret = cobj->getCosOuterAngle();
				value = float_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpotLight_getCosOuterAngle : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpotLight_setOuterAngle(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpotLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpotLight_setOuterAngle : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpotLight_setOuterAngle : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setOuterAngle(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("outerAngle");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpotLight_setOuterAngle : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpotLight_setInnerAngle(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpotLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpotLight_setInnerAngle : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpotLight_setInnerAngle : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setInnerAngle(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("innerAngle");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpotLight_setInnerAngle : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpotLight_getDirectionInWorld(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpotLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpotLight_getDirectionInWorld : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Vec3 ret = cobj->getDirectionInWorld();
				value = vec3_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpotLight_getDirectionInWorld : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpotLight_setRange(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpotLight* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpotLight_setRange : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpotLight_setRange : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setRange(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("range");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpotLight_setRange : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpotLight_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 6) {
		cocos2d::Vec3 arg0;
		cocos2d::Vec3 arg1;
		cocos2d::Color3B arg2;
		float arg3;
		float arg4;
		float arg5;
		ok &= rb_value_to_vec3(argv[0], &arg0);
		ok &= rb_value_to_vec3(argv[1], &arg1);
		ok &= rb_value_to_cccolor3b(argv[2], &arg2);
		ok &= rb_value_to_float(argv[3], &arg3);
		ok &= rb_value_to_float(argv[4], &arg4);
		ok &= rb_value_to_float(argv[5], &arg5);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpotLight_create : Error processing arguments");return RBNil();}
		cocos2d::SpotLight* ret = cocos2d::SpotLight::create(arg0, arg1, arg2, arg3, arg4, arg5);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::SpotLight>((cocos2d::SpotLight*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_SpotLight_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_SpotLight() {
		
	RBVAL classValue=rb_define_class_bridge("SpotLight",rb_get_class_value("cocos2d::BaseLight"),true);

	rb_define_method_bridge(classValue,"getRange",RB_FUNC(rb_cocos2dx_SpotLight_getRange));

   rb_define_method_bridge(classValue,"range",RB_FUNC(rb_cocos2dx_SpotLight_getRange));
	

	rb_define_method_bridge(classValue,"setDirection",RB_FUNC(rb_cocos2dx_SpotLight_setDirection));

    rb_define_method_bridge(classValue,"direction=",RB_FUNC(rb_cocos2dx_SpotLight_setDirection));
	

	rb_define_method_bridge(classValue,"getCosInnerAngle",RB_FUNC(rb_cocos2dx_SpotLight_getCosInnerAngle));

   rb_define_method_bridge(classValue,"cosInnerAngle",RB_FUNC(rb_cocos2dx_SpotLight_getCosInnerAngle));
	

	rb_define_method_bridge(classValue,"getOuterAngle",RB_FUNC(rb_cocos2dx_SpotLight_getOuterAngle));

   rb_define_method_bridge(classValue,"outerAngle",RB_FUNC(rb_cocos2dx_SpotLight_getOuterAngle));
	

	rb_define_method_bridge(classValue,"getInnerAngle",RB_FUNC(rb_cocos2dx_SpotLight_getInnerAngle));

   rb_define_method_bridge(classValue,"innerAngle",RB_FUNC(rb_cocos2dx_SpotLight_getInnerAngle));
	

	rb_define_method_bridge(classValue,"getDirection",RB_FUNC(rb_cocos2dx_SpotLight_getDirection));

   rb_define_method_bridge(classValue,"direction",RB_FUNC(rb_cocos2dx_SpotLight_getDirection));
	

	rb_define_method_bridge(classValue,"getCosOuterAngle",RB_FUNC(rb_cocos2dx_SpotLight_getCosOuterAngle));

   rb_define_method_bridge(classValue,"cosOuterAngle",RB_FUNC(rb_cocos2dx_SpotLight_getCosOuterAngle));
	

	rb_define_method_bridge(classValue,"setOuterAngle",RB_FUNC(rb_cocos2dx_SpotLight_setOuterAngle));

    rb_define_method_bridge(classValue,"outerAngle=",RB_FUNC(rb_cocos2dx_SpotLight_setOuterAngle));
	

	rb_define_method_bridge(classValue,"setInnerAngle",RB_FUNC(rb_cocos2dx_SpotLight_setInnerAngle));

    rb_define_method_bridge(classValue,"innerAngle=",RB_FUNC(rb_cocos2dx_SpotLight_setInnerAngle));
	

	rb_define_method_bridge(classValue,"getDirectionInWorld",RB_FUNC(rb_cocos2dx_SpotLight_getDirectionInWorld));

   rb_define_method_bridge(classValue,"directionInWorld",RB_FUNC(rb_cocos2dx_SpotLight_getDirectionInWorld));
	

	rb_define_method_bridge(classValue,"setRange",RB_FUNC(rb_cocos2dx_SpotLight_setRange));

    rb_define_method_bridge(classValue,"range=",RB_FUNC(rb_cocos2dx_SpotLight_setRange));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_SpotLight_create));

	


	TypeTest<cocos2d::SpotLight> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::SpotLight",classValue);
}
RBVAL rb_cocos2dx_AmbientLight_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		cocos2d::Color3B arg0;
		ok &= rb_value_to_cccolor3b(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_AmbientLight_create : Error processing arguments");return RBNil();}
		cocos2d::AmbientLight* ret = cocos2d::AmbientLight::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::AmbientLight>((cocos2d::AmbientLight*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_AmbientLight_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_AmbientLight() {
		
	RBVAL classValue=rb_define_class_bridge("AmbientLight",rb_get_class_value("cocos2d::BaseLight"),true);

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_AmbientLight_create));

	


	TypeTest<cocos2d::AmbientLight> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::AmbientLight",classValue);
}
RBVAL rb_cocos2dx_GLProgram_getFragmentShaderLog(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgram* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_getFragmentShaderLog : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					std::string ret = cobj->getFragmentShaderLog();
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgram_getFragmentShaderLog : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgram_initWithByteArrays(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgram* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_initWithByteArrays : self ptr is null");return RBNil();}
		if (argc == 2) {
			const char* arg0;
			const char* arg1;
			std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
			std::string arg1_tmp; ok &= rb_value_to_std_string(argv[1], &arg1_tmp); arg1 = arg1_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_initWithByteArrays : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->initWithByteArrays(arg0, arg1);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgram_initWithByteArrays : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgram_initWithFilenames(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgram* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_initWithFilenames : self ptr is null");return RBNil();}
		if (argc == 2) {
			std::string arg0;
			std::string arg1;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_initWithFilenames : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->initWithFilenames(arg0, arg1);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgram_initWithFilenames : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgram_use(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgram* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_use : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->use();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgram_use : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgram_getVertexShaderLog(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgram* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_getVertexShaderLog : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					std::string ret = cobj->getVertexShaderLog();
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgram_getVertexShaderLog : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgram_setUniformsForBuiltins(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::GLProgram* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_setUniformsForBuiltins : self ptr is null");return RBNil();}
	do {
		if (argc == 1) {
			cocos2d::Mat4 arg0;
			ok &= rb_value_to_mat4(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_setUniformsForBuiltins : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->setUniformsForBuiltins(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("uniformsForBuiltins");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 0) {
			cobj->setUniformsForBuiltins();
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_GLProgram_setUniformsForBuiltins : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgram_updateUniforms(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgram* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_updateUniforms : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->updateUniforms();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgram_updateUniforms : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgram_setUniformLocationWith1i(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgram* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_setUniformLocationWith1i : self ptr is null");return RBNil();}
		if (argc == 2) {
			int arg0;
			int arg1;
			ok &= rb_value_to_int(argv[0], (int *)&arg0);
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_setUniformLocationWith1i : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setUniformLocationWith1i(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgram_setUniformLocationWith1i : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgram_reset(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgram* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_reset : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->reset();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgram_reset : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgram_bindAttribLocation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgram* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_bindAttribLocation : self ptr is null");return RBNil();}
		if (argc == 2) {
			std::string arg0;
			unsigned int arg1;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			ok &= rb_value_to_uint(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_bindAttribLocation : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->bindAttribLocation(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgram_bindAttribLocation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgram_getAttribLocation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgram* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_getAttribLocation : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_getAttribLocation : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					int ret = cobj->getAttribLocation(arg0);
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgram_getAttribLocation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgram_link(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgram* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_link : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->link();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgram_link : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgram_createWithByteArrays(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		const char* arg0;
		const char* arg1;
		std::string arg0_tmp; ok &= rb_value_to_std_string(argv[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
		std::string arg1_tmp; ok &= rb_value_to_std_string(argv[1], &arg1_tmp); arg1 = arg1_tmp.c_str();
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_createWithByteArrays : Error processing arguments");return RBNil();}
		cocos2d::GLProgram* ret = cocos2d::GLProgram::createWithByteArrays(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::GLProgram>((cocos2d::GLProgram*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_GLProgram_createWithByteArrays : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_GLProgram_createWithFilenames(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		std::string arg0;
		std::string arg1;
		ok &= rb_value_to_std_string(argv[0], &arg0);
		ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgram_createWithFilenames : Error processing arguments");return RBNil();}
		cocos2d::GLProgram* ret = cocos2d::GLProgram::createWithFilenames(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::GLProgram>((cocos2d::GLProgram*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_GLProgram_createWithFilenames : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_GLProgram_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::GLProgram> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::GLProgram* cobj = new cocos2d::GLProgram();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgram_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_GLProgram() {
		
	RBVAL classValue=rb_define_class_bridge("GLProgram",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"getFragmentShaderLog",RB_FUNC(rb_cocos2dx_GLProgram_getFragmentShaderLog));

   rb_define_method_bridge(classValue,"fragmentShaderLog",RB_FUNC(rb_cocos2dx_GLProgram_getFragmentShaderLog));
	

	rb_define_method_bridge(classValue,"initWithByteArrays",RB_FUNC(rb_cocos2dx_GLProgram_initWithByteArrays));

	

	rb_define_method_bridge(classValue,"initWithFilenames",RB_FUNC(rb_cocos2dx_GLProgram_initWithFilenames));

	

	rb_define_method_bridge(classValue,"use",RB_FUNC(rb_cocos2dx_GLProgram_use));

	

	rb_define_method_bridge(classValue,"getVertexShaderLog",RB_FUNC(rb_cocos2dx_GLProgram_getVertexShaderLog));

   rb_define_method_bridge(classValue,"vertexShaderLog",RB_FUNC(rb_cocos2dx_GLProgram_getVertexShaderLog));
	

	rb_define_method_bridge(classValue,"setUniformsForBuiltins",RB_FUNC(rb_cocos2dx_GLProgram_setUniformsForBuiltins));

    rb_define_method_bridge(classValue,"uniformsForBuiltins=",RB_FUNC(rb_cocos2dx_GLProgram_setUniformsForBuiltins));
	

	rb_define_method_bridge(classValue,"updateUniforms",RB_FUNC(rb_cocos2dx_GLProgram_updateUniforms));

	

	rb_define_method_bridge(classValue,"setUniformLocationI32",RB_FUNC(rb_cocos2dx_GLProgram_setUniformLocationWith1i));

    rb_define_method_bridge(classValue,"uniformLocationI32=",RB_FUNC(rb_cocos2dx_GLProgram_setUniformLocationWith1i));
	

	rb_define_method_bridge(classValue,"reset",RB_FUNC(rb_cocos2dx_GLProgram_reset));

	

	rb_define_method_bridge(classValue,"bindAttribLocation",RB_FUNC(rb_cocos2dx_GLProgram_bindAttribLocation));

	

	rb_define_method_bridge(classValue,"getAttribLocation",RB_FUNC(rb_cocos2dx_GLProgram_getAttribLocation));

   rb_define_method_bridge(classValue,"attribLocation",RB_FUNC(rb_cocos2dx_GLProgram_getAttribLocation));
	

	rb_define_method_bridge(classValue,"link",RB_FUNC(rb_cocos2dx_GLProgram_link));

	

	

	rb_define_singleton_method_bridge(classValue,"createWithByteArrays",RB_FUNC(rb_cocos2dx_GLProgram_createWithByteArrays));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithFilenames",RB_FUNC(rb_cocos2dx_GLProgram_createWithFilenames));

	

	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_GLProgram_constructor));

	TypeTest<cocos2d::GLProgram> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::GLProgram",classValue);
}
RBVAL rb_cocos2dx_GLProgramCache_addGLProgram(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgramCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramCache_addGLProgram : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::GLProgram* arg0;
			std::string arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramCache_addGLProgram : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addGLProgram(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgramCache_addGLProgram : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramCache_getGLProgram(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgramCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramCache_getGLProgram : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramCache_getGLProgram : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::GLProgram* ret = cobj->getGLProgram(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::GLProgram>((cocos2d::GLProgram*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgramCache_getGLProgram : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramCache_reloadDefaultGLPrograms(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgramCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramCache_reloadDefaultGLPrograms : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->reloadDefaultGLPrograms();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgramCache_reloadDefaultGLPrograms : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramCache_loadDefaultGLPrograms(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::GLProgramCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLProgramCache_loadDefaultGLPrograms : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->loadDefaultGLPrograms();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgramCache_loadDefaultGLPrograms : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_GLProgramCache_destroyInstance(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::GLProgramCache::destroyInstance();
		RBVAL value=RBNil();
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_GLProgramCache_destroyInstance : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_GLProgramCache_getInstance(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::GLProgramCache* ret = cocos2d::GLProgramCache::getInstance();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::GLProgramCache>((cocos2d::GLProgramCache*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_GLProgramCache_getInstance : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_GLProgramCache_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::GLProgramCache> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::GLProgramCache* cobj = new cocos2d::GLProgramCache();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_GLProgramCache_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_GLProgramCache() {
		
	RBVAL classValue=rb_define_class_bridge("GLProgramCache",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"addGLProgram",RB_FUNC(rb_cocos2dx_GLProgramCache_addGLProgram));

	

	rb_define_method_bridge(classValue,"getGLProgram",RB_FUNC(rb_cocos2dx_GLProgramCache_getGLProgram));

   rb_define_method_bridge(classValue,"gLProgram",RB_FUNC(rb_cocos2dx_GLProgramCache_getGLProgram));
	

	rb_define_method_bridge(classValue,"reloadDefaultGLPrograms",RB_FUNC(rb_cocos2dx_GLProgramCache_reloadDefaultGLPrograms));

	

	rb_define_method_bridge(classValue,"loadDefaultGLPrograms",RB_FUNC(rb_cocos2dx_GLProgramCache_loadDefaultGLPrograms));

	

	

	rb_define_singleton_method_bridge(classValue,"destroyInstance",RB_FUNC(rb_cocos2dx_GLProgramCache_destroyInstance));

	
	

	rb_define_singleton_method_bridge(classValue,"getInstance",RB_FUNC(rb_cocos2dx_GLProgramCache_getInstance));

   rb_define_singleton_method_bridge(classValue,"instance",RB_FUNC(rb_cocos2dx_GLProgramCache_getInstance));
	

	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_GLProgramCache_constructor));

	TypeTest<cocos2d::GLProgramCache> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::GLProgramCache",classValue);
}
RBVAL rb_cocos2dx_TextureCache_reloadTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TextureCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_reloadTexture : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_reloadTexture : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->reloadTexture(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TextureCache_reloadTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TextureCache_unbindAllImageAsync(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TextureCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_unbindAllImageAsync : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->unbindAllImageAsync();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TextureCache_unbindAllImageAsync : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TextureCache_removeTextureForKey(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TextureCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_removeTextureForKey : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_removeTextureForKey : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeTextureForKey(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TextureCache_removeTextureForKey : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TextureCache_removeAllTextures(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TextureCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_removeAllTextures : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->removeAllTextures();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TextureCache_removeAllTextures : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TextureCache_getDescription(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TextureCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_getDescription : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					std::string ret = cobj->getDescription();
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TextureCache_getDescription : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TextureCache_getCachedTextureInfo(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TextureCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_getCachedTextureInfo : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					std::string ret = cobj->getCachedTextureInfo();
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TextureCache_getCachedTextureInfo : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TextureCache_addImage(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::TextureCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_addImage : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			cocos2d::Image* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_addImage : Error processing argument 1 ( 2 )");return RBNil(); }
			std::string arg1;
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_addImage : Error processing argument 2 ( 2 )");return RBNil(); }
			cocos2d::Texture2D* ret = cobj->addImage(arg0, arg1);
			RBVAL value = RBNil();
						if (ret) {
				value = rbb_get_or_create_value<cocos2d::Texture2D>((cocos2d::Texture2D*)ret);
			} else {
				value = RBNil();
			};
			return value;
		}
	} while(0);

	do {
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_addImage : Error processing argument 1 ( 1 )");return RBNil(); }
			cocos2d::Texture2D* ret = cobj->addImage(arg0);
			RBVAL value = RBNil();
						if (ret) {
				value = rbb_get_or_create_value<cocos2d::Texture2D>((cocos2d::Texture2D*)ret);
			} else {
				value = RBNil();
			};
			return value;
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_TextureCache_addImage : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TextureCache_unbindImageAsync(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TextureCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_unbindImageAsync : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_unbindImageAsync : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->unbindImageAsync(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TextureCache_unbindImageAsync : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TextureCache_getTextureForKey(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TextureCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_getTextureForKey : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_getTextureForKey : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Texture2D* ret = cobj->getTextureForKey(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Texture2D>((cocos2d::Texture2D*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TextureCache_getTextureForKey : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TextureCache_removeUnusedTextures(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TextureCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_removeUnusedTextures : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->removeUnusedTextures();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TextureCache_removeUnusedTextures : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TextureCache_removeTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TextureCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_removeTexture : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Texture2D* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_removeTexture : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeTexture(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TextureCache_removeTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TextureCache_waitForQuit(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::TextureCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_TextureCache_waitForQuit : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->waitForQuit();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TextureCache_waitForQuit : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_TextureCache_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::TextureCache> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::TextureCache* cobj = new cocos2d::TextureCache();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_TextureCache_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_TextureCache() {
		
	RBVAL classValue=rb_define_class_bridge("TextureCache",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"reloadTexture",RB_FUNC(rb_cocos2dx_TextureCache_reloadTexture));

	

	rb_define_method_bridge(classValue,"unbindAllImageAsync",RB_FUNC(rb_cocos2dx_TextureCache_unbindAllImageAsync));

	

	rb_define_method_bridge(classValue,"removeTextureForKey",RB_FUNC(rb_cocos2dx_TextureCache_removeTextureForKey));

	

	rb_define_method_bridge(classValue,"removeAllTextures",RB_FUNC(rb_cocos2dx_TextureCache_removeAllTextures));

	

	rb_define_method_bridge(classValue,"getDescription",RB_FUNC(rb_cocos2dx_TextureCache_getDescription));

   rb_define_method_bridge(classValue,"description",RB_FUNC(rb_cocos2dx_TextureCache_getDescription));
	

	rb_define_method_bridge(classValue,"getCachedTextureInfo",RB_FUNC(rb_cocos2dx_TextureCache_getCachedTextureInfo));

   rb_define_method_bridge(classValue,"cachedTextureInfo",RB_FUNC(rb_cocos2dx_TextureCache_getCachedTextureInfo));
	

	rb_define_method_bridge(classValue,"addImage",RB_FUNC(rb_cocos2dx_TextureCache_addImage));

	

	rb_define_method_bridge(classValue,"unbindImageAsync",RB_FUNC(rb_cocos2dx_TextureCache_unbindImageAsync));

	

	rb_define_method_bridge(classValue,"getTextureForKey",RB_FUNC(rb_cocos2dx_TextureCache_getTextureForKey));

   rb_define_method_bridge(classValue,"textureForKey",RB_FUNC(rb_cocos2dx_TextureCache_getTextureForKey));
	

	rb_define_method_bridge(classValue,"removeUnusedTextures",RB_FUNC(rb_cocos2dx_TextureCache_removeUnusedTextures));

	

	rb_define_method_bridge(classValue,"removeTexture",RB_FUNC(rb_cocos2dx_TextureCache_removeTexture));

	

	rb_define_method_bridge(classValue,"waitForQuit",RB_FUNC(rb_cocos2dx_TextureCache_waitForQuit));

	


	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_TextureCache_constructor));

	TypeTest<cocos2d::TextureCache> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::TextureCache",classValue);
}
RBVAL rb_cocos2dx_Device_setAccelerometerEnabled(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		bool arg0;
		ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Device_setAccelerometerEnabled : Error processing arguments");return RBNil();}
		cocos2d::Device::setAccelerometerEnabled(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("accelerometerEnabled");
				}
				rb_cvar_set_bridge(clazz,propSYM,argv[0]);
		RBVAL value=RBNil();
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Device_setAccelerometerEnabled : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_Device_setKeepScreenOn(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		bool arg0;
		ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Device_setKeepScreenOn : Error processing arguments");return RBNil();}
		cocos2d::Device::setKeepScreenOn(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("keepScreenOn");
				}
				rb_cvar_set_bridge(clazz,propSYM,argv[0]);
		RBVAL value=RBNil();
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Device_setKeepScreenOn : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_Device_setAccelerometerInterval(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		float arg0;
		ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Device_setAccelerometerInterval : Error processing arguments");return RBNil();}
		cocos2d::Device::setAccelerometerInterval(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("accelerometerInterval");
				}
				rb_cvar_set_bridge(clazz,propSYM,argv[0]);
		RBVAL value=RBNil();
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Device_setAccelerometerInterval : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_Device_getDPI(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		int ret = cocos2d::Device::getDPI();
		RBVAL value=RBNil();
		value = int_to_rb_value(ret);
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Device_getDPI : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Device() {
		
	RBVAL classValue=rb_define_class_bridge("Device",rb_get_root_class(),true);

	

	rb_define_singleton_method_bridge(classValue,"setAccelerometerEnabled",RB_FUNC(rb_cocos2dx_Device_setAccelerometerEnabled));

    rb_define_singleton_method_bridge(classValue,"accelerometerEnabled=",RB_FUNC(rb_cocos2dx_Device_setAccelerometerEnabled));
	
	

	rb_define_singleton_method_bridge(classValue,"setKeepScreenOn",RB_FUNC(rb_cocos2dx_Device_setKeepScreenOn));

    rb_define_singleton_method_bridge(classValue,"keepScreenOn=",RB_FUNC(rb_cocos2dx_Device_setKeepScreenOn));
	
	

	rb_define_singleton_method_bridge(classValue,"setAccelerometerInterval",RB_FUNC(rb_cocos2dx_Device_setAccelerometerInterval));

    rb_define_singleton_method_bridge(classValue,"accelerometerInterval=",RB_FUNC(rb_cocos2dx_Device_setAccelerometerInterval));
	
	

	rb_define_singleton_method_bridge(classValue,"getDPI",RB_FUNC(rb_cocos2dx_Device_getDPI));

   rb_define_singleton_method_bridge(classValue,"dPI",RB_FUNC(rb_cocos2dx_Device_getDPI));
	


	TypeTest<cocos2d::Device> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Device",classValue);
}
RBVAL rb_cocos2dx_Application_openURL(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Application* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Application_openURL : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Application_openURL : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					bool ret = cobj->openURL(arg0);
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Application_openURL : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Application_getTargetPlatform(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Application* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Application_getTargetPlatform : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getTargetPlatform();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Application_getTargetPlatform : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Application_getCurrentLanguage(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Application* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Application_getCurrentLanguage : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					int ret = (int)cobj->getCurrentLanguage();
				value = int_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Application_getCurrentLanguage : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Application_getCurrentLanguageCode(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Application* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Application_getCurrentLanguageCode : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const char* ret = cobj->getCurrentLanguageCode();
				value = char_ptr_to_rb_string(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Application_getCurrentLanguageCode : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Application_setAnimationInterval(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Application* cobj = nullptr;
		ok=rb_value_get_ptr_raw(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Application_setAnimationInterval : self ptr is null");return RBNil();}
		if (argc == 1) {
			double arg0;
			ok &= rb_value_to_double(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Application_setAnimationInterval : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setAnimationInterval(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("animationInterval");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Application_setAnimationInterval : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Application_getInstance(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::Application* ret = cocos2d::Application::getInstance();
		RBVAL value=RBNil();
		value = Application_to_rb_value(ret);
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Application_getInstance : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Application() {
		
	RBVAL classValue=rb_define_class_bridge("Application",rb_get_root_class(),true);

	rb_define_method_bridge(classValue,"openURL",RB_FUNC(rb_cocos2dx_Application_openURL));

	

	rb_define_method_bridge(classValue,"getTargetPlatform",RB_FUNC(rb_cocos2dx_Application_getTargetPlatform));

   rb_define_method_bridge(classValue,"targetPlatform",RB_FUNC(rb_cocos2dx_Application_getTargetPlatform));
	

	rb_define_method_bridge(classValue,"getCurrentLanguage",RB_FUNC(rb_cocos2dx_Application_getCurrentLanguage));

   rb_define_method_bridge(classValue,"currentLanguage",RB_FUNC(rb_cocos2dx_Application_getCurrentLanguage));
	

	rb_define_method_bridge(classValue,"getCurrentLanguageCode",RB_FUNC(rb_cocos2dx_Application_getCurrentLanguageCode));

   rb_define_method_bridge(classValue,"currentLanguageCode",RB_FUNC(rb_cocos2dx_Application_getCurrentLanguageCode));
	

	rb_define_method_bridge(classValue,"setAnimationInterval",RB_FUNC(rb_cocos2dx_Application_setAnimationInterval));

    rb_define_method_bridge(classValue,"animationInterval=",RB_FUNC(rb_cocos2dx_Application_setAnimationInterval));
	

	

	rb_define_singleton_method_bridge(classValue,"getInstance",RB_FUNC(rb_cocos2dx_Application_getInstance));

   rb_define_singleton_method_bridge(classValue,"instance",RB_FUNC(rb_cocos2dx_Application_getInstance));
	


	TypeTest<cocos2d::Application> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Application",classValue);
}
RBVAL rb_cocos2dx_GLViewImpl_createWithRect(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 2) {
		std::string arg0;
		cocos2d::Rect arg1;
		ok &= rb_value_to_std_string(argv[0], &arg0);
		ok &= rb_value_to_ccrect(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLViewImpl_createWithRect : Error processing arguments");return RBNil();}
		cocos2d::GLViewImpl* ret = cocos2d::GLViewImpl::createWithRect(arg0, arg1);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::GLViewImpl>((cocos2d::GLViewImpl*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	if (argc == 3) {
		std::string arg0;
		cocos2d::Rect arg1;
		float arg2;
		ok &= rb_value_to_std_string(argv[0], &arg0);
		ok &= rb_value_to_ccrect(argv[1], &arg1);
		ok &= rb_value_to_float(argv[2], &arg2);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLViewImpl_createWithRect : Error processing arguments");return RBNil();}
		cocos2d::GLViewImpl* ret = cocos2d::GLViewImpl::createWithRect(arg0, arg1, arg2);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::GLViewImpl>((cocos2d::GLViewImpl*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_GLViewImpl_createWithRect : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_GLViewImpl_create(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		std::string arg0;
		ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLViewImpl_create : Error processing arguments");return RBNil();}
		cocos2d::GLViewImpl* ret = cocos2d::GLViewImpl::create(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::GLViewImpl>((cocos2d::GLViewImpl*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_GLViewImpl_create : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_GLViewImpl_createWithFullScreen(int argc, RBVAL *argv, RBVAL clazz)
{
	bool ok = true;
	if (argc == 1) {
		std::string arg0;
		ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_GLViewImpl_createWithFullScreen : Error processing arguments");return RBNil();}
		cocos2d::GLViewImpl* ret = cocos2d::GLViewImpl::createWithFullScreen(arg0);
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::GLViewImpl>((cocos2d::GLViewImpl*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_GLViewImpl_createWithFullScreen : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_GLViewImpl() {
		
	RBVAL classValue=rb_define_class_bridge("GLViewImpl",rb_get_class_value("cocos2d::GLView"),true);

	

	rb_define_singleton_method_bridge(classValue,"createWithRect",RB_FUNC(rb_cocos2dx_GLViewImpl_createWithRect));

	
	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_GLViewImpl_create));

	
	

	rb_define_singleton_method_bridge(classValue,"createWithFullScreen",RB_FUNC(rb_cocos2dx_GLViewImpl_createWithFullScreen));

	


	TypeTest<cocos2d::GLViewImpl> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::GLViewImpl",classValue);
}
RBVAL rb_cocos2dx_AnimationCache_getAnimation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AnimationCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationCache_getAnimation : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationCache_getAnimation : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::Animation* ret = cobj->getAnimation(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Animation>((cocos2d::Animation*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AnimationCache_getAnimation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AnimationCache_addAnimation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AnimationCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationCache_addAnimation : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::Animation* arg0;
			std::string arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationCache_addAnimation : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addAnimation(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AnimationCache_addAnimation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AnimationCache_init(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AnimationCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationCache_init : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->init();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AnimationCache_init : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AnimationCache_addAnimationsWithDictionary(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AnimationCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationCache_addAnimationsWithDictionary : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::ValueMap arg0;
			std::string arg1;
			ok &= rb_value_to_ccvaluemap(argv[0], &arg0);
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationCache_addAnimationsWithDictionary : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addAnimationsWithDictionary(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AnimationCache_addAnimationsWithDictionary : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AnimationCache_removeAnimation(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AnimationCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationCache_removeAnimation : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationCache_removeAnimation : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeAnimation(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AnimationCache_removeAnimation : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AnimationCache_addAnimationsWithFile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::AnimationCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationCache_addAnimationsWithFile : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_AnimationCache_addAnimationsWithFile : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addAnimationsWithFile(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AnimationCache_addAnimationsWithFile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_AnimationCache_destroyInstance(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::AnimationCache::destroyInstance();
		RBVAL value=RBNil();
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_AnimationCache_destroyInstance : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_AnimationCache_getInstance(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::AnimationCache* ret = cocos2d::AnimationCache::getInstance();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::AnimationCache>((cocos2d::AnimationCache*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_AnimationCache_getInstance : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_AnimationCache_constructor(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
		static RBVAL RBCLZ=0;
		if (RBCLZ==0){
			TypeTest<cocos2d::AnimationCache> t;
			RBCLZ=rb_get_class_value(t.s_name());
		}
		if (argc == 0) {
			cocos2d::AnimationCache* cobj = new cocos2d::AnimationCache();
				cocos2d::Ref *_ccobj = dynamic_cast<cocos2d::Ref *>(cobj);
				if (_ccobj) {
					_ccobj->autorelease();
				}
			RBVAL value = rbb_create_value(cobj,RBCLZ);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_AnimationCache_constructor : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_AnimationCache() {
		
	RBVAL classValue=rb_define_class_bridge("AnimationCache",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"getAnimation",RB_FUNC(rb_cocos2dx_AnimationCache_getAnimation));

   rb_define_method_bridge(classValue,"animation",RB_FUNC(rb_cocos2dx_AnimationCache_getAnimation));
	

	rb_define_method_bridge(classValue,"addAnimation",RB_FUNC(rb_cocos2dx_AnimationCache_addAnimation));

	

	rb_define_method_bridge(classValue,"init",RB_FUNC(rb_cocos2dx_AnimationCache_init));

	

	rb_define_method_bridge(classValue,"addAnimationsWithDictionary",RB_FUNC(rb_cocos2dx_AnimationCache_addAnimationsWithDictionary));

	

	rb_define_method_bridge(classValue,"removeAnimation",RB_FUNC(rb_cocos2dx_AnimationCache_removeAnimation));

	

	rb_define_method_bridge(classValue,"addAnimations",RB_FUNC(rb_cocos2dx_AnimationCache_addAnimationsWithFile));

	

	

	rb_define_singleton_method_bridge(classValue,"destroyInstance",RB_FUNC(rb_cocos2dx_AnimationCache_destroyInstance));

	
	

	rb_define_singleton_method_bridge(classValue,"getInstance",RB_FUNC(rb_cocos2dx_AnimationCache_getInstance));

   rb_define_singleton_method_bridge(classValue,"instance",RB_FUNC(rb_cocos2dx_AnimationCache_getInstance));
	

	rb_define_singleton_method_bridge(classValue,"new",RB_FUNC(rb_cocos2dx_AnimationCache_constructor));

	TypeTest<cocos2d::AnimationCache> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::AnimationCache",classValue);
}
RBVAL rb_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrameCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent : self ptr is null");return RBNil();}
		if (argc == 2) {
			std::string arg0;
			cocos2d::Texture2D* arg1;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addSpriteFramesWithFileContent(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	RBVAL value=RBNil();
	cocos2d::SpriteFrameCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile : self ptr is null");return RBNil();}
	do {
		if (argc == 2) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile : Error processing argument 1 ( 2 )");return RBNil(); }
			std::string arg1;
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->addSpriteFramesWithFile(arg0, arg1);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile : Error processing argument 1 ( 1 )");return RBNil(); }
			cobj->addSpriteFramesWithFile(arg0);
			return RBNil();
		}
	} while(0);

	do {
		if (argc == 2) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile : Error processing argument 1 ( 2 )");return RBNil(); }
			cocos2d::Texture2D* arg1;
			ok &= rb_value_get_ptr(argv[1],&arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile : Error processing argument 2 ( 2 )");return RBNil(); }
			cobj->addSpriteFramesWithFile(arg0, arg1);
			return RBNil();
		}
	} while(0);

	rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrameCache_addSpriteFrame(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrameCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_addSpriteFrame : self ptr is null");return RBNil();}
		if (argc == 2) {
			cocos2d::SpriteFrame* arg0;
			std::string arg1;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_std_string(argv[1], &arg1);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_addSpriteFrame : Error processing argument 2 ( 2 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addSpriteFrame(arg0, arg1);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_addSpriteFrame : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrameCache_removeUnusedSpriteFrames(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrameCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_removeUnusedSpriteFrames : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->removeUnusedSpriteFrames();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_removeUnusedSpriteFrames : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrameCache_getSpriteFrameByName(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrameCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_getSpriteFrameByName : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_getSpriteFrameByName : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
					cocos2d::SpriteFrame* ret = cobj->getSpriteFrameByName(arg0);
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_getSpriteFrameByName : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrameCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeSpriteFramesFromFile(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrameCache_init(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrameCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_init : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->init();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_init : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrameCache_removeSpriteFrames(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrameCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_removeSpriteFrames : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
				cobj->removeSpriteFrames();
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_removeSpriteFrames : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrameCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Texture2D* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeSpriteFramesFromTexture(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrameCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeSpriteFramesFromFileContent(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrameCache_removeSpriteFrameByName(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::SpriteFrameCache* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_removeSpriteFrameByName : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_removeSpriteFrameByName : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeSpriteFrameByName(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_removeSpriteFrameByName : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_SpriteFrameCache_destroyInstance(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::SpriteFrameCache::destroyInstance();
		RBVAL value=RBNil();
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_destroyInstance : wrong number of arguments");
	return RBNil();
}

RBVAL rb_cocos2dx_SpriteFrameCache_getInstance(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::SpriteFrameCache* ret = cocos2d::SpriteFrameCache::getInstance();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::SpriteFrameCache>((cocos2d::SpriteFrameCache*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_SpriteFrameCache_getInstance : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_SpriteFrameCache() {
		
	RBVAL classValue=rb_define_class_bridge("SpriteFrameCache",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"addSpriteFramesWithFileContent",RB_FUNC(rb_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent));

	

	rb_define_method_bridge(classValue,"addSpriteFrames",RB_FUNC(rb_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile));

	

	rb_define_method_bridge(classValue,"addSpriteFrame",RB_FUNC(rb_cocos2dx_SpriteFrameCache_addSpriteFrame));

	

	rb_define_method_bridge(classValue,"removeUnusedSpriteFrames",RB_FUNC(rb_cocos2dx_SpriteFrameCache_removeUnusedSpriteFrames));

	

	rb_define_method_bridge(classValue,"getSpriteFrame",RB_FUNC(rb_cocos2dx_SpriteFrameCache_getSpriteFrameByName));

   rb_define_method_bridge(classValue,"spriteFrame",RB_FUNC(rb_cocos2dx_SpriteFrameCache_getSpriteFrameByName));
	

	rb_define_method_bridge(classValue,"removeSpriteFramesFromFile",RB_FUNC(rb_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile));

	

	rb_define_method_bridge(classValue,"init",RB_FUNC(rb_cocos2dx_SpriteFrameCache_init));

	

	rb_define_method_bridge(classValue,"removeSpriteFrames",RB_FUNC(rb_cocos2dx_SpriteFrameCache_removeSpriteFrames));

	

	rb_define_method_bridge(classValue,"removeSpriteFramesFromTexture",RB_FUNC(rb_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture));

	

	rb_define_method_bridge(classValue,"removeSpriteFramesFromFileContent",RB_FUNC(rb_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent));

	

	rb_define_method_bridge(classValue,"removeSpriteFrameByName",RB_FUNC(rb_cocos2dx_SpriteFrameCache_removeSpriteFrameByName));

	

	

	rb_define_singleton_method_bridge(classValue,"destroyInstance",RB_FUNC(rb_cocos2dx_SpriteFrameCache_destroyInstance));

	
	

	rb_define_singleton_method_bridge(classValue,"getInstance",RB_FUNC(rb_cocos2dx_SpriteFrameCache_getInstance));

   rb_define_singleton_method_bridge(classValue,"instance",RB_FUNC(rb_cocos2dx_SpriteFrameCache_getInstance));
	


	TypeTest<cocos2d::SpriteFrameCache> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::SpriteFrameCache",classValue);
}
RBVAL rb_cocos2dx_ParallaxNode_addChild(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParallaxNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParallaxNode_addChild : self ptr is null");return RBNil();}
		if (argc == 4) {
			cocos2d::Node* arg0;
			int arg1;
			cocos2d::Vec2 arg2;
			cocos2d::Vec2 arg3;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			ok &= rb_value_to_int(argv[1], (int *)&arg1);
			ok &= rb_value_to_vec2(argv[2], &arg2);
			ok &= rb_value_to_vec2(argv[3], &arg3);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParallaxNode_addChild : Error processing argument 4 ( 4 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->addChild(arg0, arg1, arg2, arg3);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParallaxNode_addChild : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::ParallaxNode* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->removeAllChildrenWithCleanup(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_ParallaxNode_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::ParallaxNode* ret = cocos2d::ParallaxNode::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::ParallaxNode>((cocos2d::ParallaxNode*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_ParallaxNode_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_ParallaxNode() {
		
	RBVAL classValue=rb_define_class_bridge("ParallaxNode",rb_get_class_value("cocos2d::Node"),true);

	rb_define_method_bridge(classValue,"addChild",RB_FUNC(rb_cocos2dx_ParallaxNode_addChild));

	

	rb_define_method_bridge(classValue,"removeAllChildrenWithCleanup",RB_FUNC(rb_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup));

	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_ParallaxNode_create));

	


	TypeTest<cocos2d::ParallaxNode> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::ParallaxNode",classValue);
}
RBVAL rb_cocos2dx_Component_setEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Component* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Component_setEnabled : self ptr is null");return RBNil();}
		if (argc == 1) {
			bool arg0;
			ok &= rb_value_to_bool(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Component_setEnabled : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setEnabled(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("enabled");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Component_setEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Component_setName(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Component* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Component_setName : self ptr is null");return RBNil();}
		if (argc == 1) {
			std::string arg0;
			ok &= rb_value_to_std_string(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Component_setName : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setName(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("name");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Component_setName : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Component_isEnabled(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Component* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Component_isEnabled : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->isEnabled();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Component_isEnabled : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Component_update(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Component* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Component_update : self ptr is null");return RBNil();}
		if (argc == 1) {
			float arg0;
			ok &= rb_value_to_float(argv[0], &arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Component_update : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->update(arg0);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Component_update : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Component_getOwner(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Component* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Component_getOwner : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					cocos2d::Node* ret = cobj->getOwner();
							if (ret) {
				value = rbb_get_or_create_value<cocos2d::Node>((cocos2d::Node*)ret);
			} else {
				value = RBNil();
			};
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Component_getOwner : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Component_init(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Component* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Component_init : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					bool ret = cobj->init();
				value = bool_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Component_init : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Component_setOwner(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Component* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Component_setOwner : self ptr is null");return RBNil();}
		if (argc == 1) {
			cocos2d::Node* arg0;
			ok &= rb_value_get_ptr(argv[0],&arg0);
			if (!ok) {rb_raise_arg_error("rb_cocos2dx_Component_setOwner : Error processing argument 1 ( 1 )");return RBNil();}
			RBVAL value = RBNil();
				cobj->setOwner(arg0);
				static RBVAL propSYM=0l;
				if (propSYM==0l){
					propSYM=rb_sym_from_name("owner");
				}
				rb_ivar_set_bridge(self,propSYM,argv[0]);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Component_setOwner : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Component_getName(int argc, RBVAL *argv, RBVAL self)
{
	bool ok = true;
	cocos2d::Component* cobj = nullptr;
		ok=rb_value_get_ptr(self,&cobj);
	if (!ok) {rb_raise_arg_error("rb_cocos2dx_Component_getName : self ptr is null");return RBNil();}
		if (argc == 0) {
			RBVAL value = RBNil();
					const std::string& ret = cobj->getName();
				value = std_string_to_rb_value(ret);
		return value;
		}

	rb_raise_arg_error("rb_cocos2dx_Component_getName : wrong number of arguments");
	return RBNil();
}
RBVAL rb_cocos2dx_Component_create(int argc, RBVAL *argv, RBVAL clazz)
{
	if (argc == 0) {
		cocos2d::Component* ret = cocos2d::Component::create();
		RBVAL value=RBNil();
				if (ret) {
			value = rbb_get_or_create_value<cocos2d::Component>((cocos2d::Component*)ret);
		} else {
			value = RBNil();
		};
		return value;
	}
	rb_raise_arg_error("rb_cocos2dx_Component_create : wrong number of arguments");
	return RBNil();
}



void rb_register_cocos2dx_Component() {
		
	RBVAL classValue=rb_define_class_bridge("Component",rb_get_class_value("cocos2d::Ref"),true);

	rb_define_method_bridge(classValue,"setEnabled",RB_FUNC(rb_cocos2dx_Component_setEnabled));

    rb_define_method_bridge(classValue,"enabled=",RB_FUNC(rb_cocos2dx_Component_setEnabled));
	

	rb_define_method_bridge(classValue,"setName",RB_FUNC(rb_cocos2dx_Component_setName));

    rb_define_method_bridge(classValue,"name=",RB_FUNC(rb_cocos2dx_Component_setName));
	

	rb_define_method_bridge(classValue,"isEnabled",RB_FUNC(rb_cocos2dx_Component_isEnabled));

	

	rb_define_method_bridge(classValue,"update",RB_FUNC(rb_cocos2dx_Component_update));

	

	rb_define_method_bridge(classValue,"getOwner",RB_FUNC(rb_cocos2dx_Component_getOwner));

   rb_define_method_bridge(classValue,"owner",RB_FUNC(rb_cocos2dx_Component_getOwner));
	

	rb_define_method_bridge(classValue,"init",RB_FUNC(rb_cocos2dx_Component_init));

	

	rb_define_method_bridge(classValue,"setOwner",RB_FUNC(rb_cocos2dx_Component_setOwner));

    rb_define_method_bridge(classValue,"owner=",RB_FUNC(rb_cocos2dx_Component_setOwner));
	

	rb_define_method_bridge(classValue,"getName",RB_FUNC(rb_cocos2dx_Component_getName));

   rb_define_method_bridge(classValue,"name",RB_FUNC(rb_cocos2dx_Component_getName));
	

	

	rb_define_singleton_method_bridge(classValue,"create",RB_FUNC(rb_cocos2dx_Component_create));

	


	TypeTest<cocos2d::Component> t;
	std::string typeName = t.s_name();
	rbb_register_class_value(typeName,classValue);
	rbb_register_class_value("cocos2d::Component",classValue);
}

void register_all_cocos2dx() {
	rb_register_cocos2dx_Ref();
	rb_register_cocos2dx_Console();
	rb_register_cocos2dx_Node();
	rb_register_cocos2dx_Scene();
	rb_register_cocos2dx_TransitionScene();
	rb_register_cocos2dx_TransitionEaseScene();
	rb_register_cocos2dx_TransitionMoveInL();
	rb_register_cocos2dx_TransitionMoveInB();
	rb_register_cocos2dx_TransitionMoveInT();
	rb_register_cocos2dx_TransitionMoveInR();
	rb_register_cocos2dx_Action();
	rb_register_cocos2dx_FiniteTimeAction();
	rb_register_cocos2dx_ActionInstant();
	rb_register_cocos2dx_Hide();
	rb_register_cocos2dx_BlendProtocol();
	rb_register_cocos2dx_TextureProtocol();
	rb_register_cocos2dx_ParticleSystem();
	rb_register_cocos2dx_ParticleSystemQuad();
	rb_register_cocos2dx_ParticleSpiral();
	rb_register_cocos2dx_GridBase();
	rb_register_cocos2dx_AnimationCache();
	rb_register_cocos2dx_ActionInterval();
	rb_register_cocos2dx_ActionCamera();
	rb_register_cocos2dx_ProgressFromTo();
	rb_register_cocos2dx_MoveBy();
	rb_register_cocos2dx_MoveTo();
	rb_register_cocos2dx_JumpBy();
	rb_register_cocos2dx_EventListener();
	rb_register_cocos2dx_EventListenerKeyboard();
	rb_register_cocos2dx_EventListenerMouse();
	rb_register_cocos2dx_TransitionRotoZoom();
	rb_register_cocos2dx_Director();
	rb_register_cocos2dx_Scheduler();
	rb_register_cocos2dx_ActionEase();
	rb_register_cocos2dx_EaseElastic();
	rb_register_cocos2dx_EaseElasticOut();
	rb_register_cocos2dx_EaseQuadraticActionInOut();
	rb_register_cocos2dx_EaseBackOut();
	rb_register_cocos2dx_Texture2D();
	rb_register_cocos2dx_TransitionSceneOriented();
	rb_register_cocos2dx_TransitionFlipX();
	rb_register_cocos2dx_GridAction();
	rb_register_cocos2dx_TiledGrid3DAction();
	rb_register_cocos2dx_FadeOutTRTiles();
	rb_register_cocos2dx_FadeOutUpTiles();
	rb_register_cocos2dx_FadeOutDownTiles();
	rb_register_cocos2dx_StopGrid();
	rb_register_cocos2dx_ParticleBatchNode();
	rb_register_cocos2dx_SkewTo();
	rb_register_cocos2dx_SkewBy();
	rb_register_cocos2dx_EaseQuadraticActionOut();
	rb_register_cocos2dx_TransitionProgress();
	rb_register_cocos2dx_TransitionProgressVertical();
	rb_register_cocos2dx_Layer();
	rb_register_cocos2dx_Grid3DAction();
	rb_register_cocos2dx_BaseLight();
	rb_register_cocos2dx_SpotLight();
	rb_register_cocos2dx_FadeTo();
	rb_register_cocos2dx_FadeIn();
	rb_register_cocos2dx_DirectionLight();
	rb_register_cocos2dx_GLProgramState();
	rb_register_cocos2dx_EventListenerCustom();
	rb_register_cocos2dx_FlipX3D();
	rb_register_cocos2dx_FlipY3D();
	rb_register_cocos2dx_EaseSineInOut();
	rb_register_cocos2dx_TransitionFlipAngular();
	rb_register_cocos2dx_EaseElasticInOut();
	rb_register_cocos2dx_EaseBounce();
	rb_register_cocos2dx_Show();
	rb_register_cocos2dx_FadeOut();
	rb_register_cocos2dx_CallFunc();
	rb_register_cocos2dx_Event();
	rb_register_cocos2dx_EventMouse();
	rb_register_cocos2dx_GLView();
	rb_register_cocos2dx_EaseBezierAction();
	rb_register_cocos2dx_ParticleFireworks();
	rb_register_cocos2dx_MenuItem();
	rb_register_cocos2dx_MenuItemSprite();
	rb_register_cocos2dx_MenuItemImage();
	rb_register_cocos2dx_ParticleFire();
	rb_register_cocos2dx_TransitionZoomFlipAngular();
	rb_register_cocos2dx_EaseRateAction();
	rb_register_cocos2dx_EaseIn();
	rb_register_cocos2dx_EaseExponentialInOut();
	rb_register_cocos2dx_EaseBackInOut();
	rb_register_cocos2dx_Waves3D();
	rb_register_cocos2dx_EaseExponentialOut();
	rb_register_cocos2dx_SpriteBatchNode();
	rb_register_cocos2dx_LabelProtocol();
	rb_register_cocos2dx_Label();
	rb_register_cocos2dx_Application();
	rb_register_cocos2dx_DelayTime();
	rb_register_cocos2dx_AtlasNode();
	rb_register_cocos2dx_LabelAtlas();
	rb_register_cocos2dx_ParticleSnow();
	rb_register_cocos2dx_EaseElasticIn();
	rb_register_cocos2dx_EaseCircleActionInOut();
	rb_register_cocos2dx_EaseQuarticActionOut();
	rb_register_cocos2dx_EventAcceleration();
	rb_register_cocos2dx_EaseCubicActionIn();
	rb_register_cocos2dx_TextureCache();
	rb_register_cocos2dx_ActionTween();
	rb_register_cocos2dx_TransitionFadeTR();
	rb_register_cocos2dx_TransitionFadeDown();
	rb_register_cocos2dx_ParticleSun();
	rb_register_cocos2dx_TransitionProgressHorizontal();
	rb_register_cocos2dx_FlipX();
	rb_register_cocos2dx_FlipY();
	rb_register_cocos2dx_EventKeyboard();
	rb_register_cocos2dx_TransitionSplitCols();
	rb_register_cocos2dx_Timer();
	rb_register_cocos2dx_RepeatForever();
	rb_register_cocos2dx_Place();
	rb_register_cocos2dx_EventListenerAcceleration();
	rb_register_cocos2dx_TiledGrid3D();
	rb_register_cocos2dx_EaseBounceOut();
	rb_register_cocos2dx_RenderTexture();
	rb_register_cocos2dx_TintBy();
	rb_register_cocos2dx_TransitionShrinkGrow();
	rb_register_cocos2dx_ClippingNode();
	rb_register_cocos2dx_ParticleFlower();
	rb_register_cocos2dx_EaseCircleActionIn();
	rb_register_cocos2dx_ParticleSmoke();
	rb_register_cocos2dx_Image();
	rb_register_cocos2dx_LayerMultiplex();
	rb_register_cocos2dx_Blink();
	rb_register_cocos2dx_JumpTo();
	rb_register_cocos2dx_ParticleExplosion();
	rb_register_cocos2dx_TransitionJumpZoom();
	rb_register_cocos2dx_Touch();
	rb_register_cocos2dx_AnimationFrame();
	rb_register_cocos2dx_NodeGrid();
	rb_register_cocos2dx_EaseSineIn();
	rb_register_cocos2dx_EaseBounceIn();
	rb_register_cocos2dx_Camera();
	rb_register_cocos2dx_GLProgram();
	rb_register_cocos2dx_ParticleGalaxy();
	rb_register_cocos2dx_Twirl();
	rb_register_cocos2dx_MenuItemLabel();
	rb_register_cocos2dx_EaseQuinticActionIn();
	rb_register_cocos2dx_LayerColor();
	rb_register_cocos2dx_FadeOutBLTiles();
	rb_register_cocos2dx_LayerGradient();
	rb_register_cocos2dx_EventListenerTouchAllAtOnce();
	rb_register_cocos2dx_GLViewImpl();
	rb_register_cocos2dx_ToggleVisibility();
	rb_register_cocos2dx_Repeat();
	rb_register_cocos2dx_CardinalSplineTo();
	rb_register_cocos2dx_CardinalSplineBy();
	rb_register_cocos2dx_TransitionFlipY();
	rb_register_cocos2dx_TurnOffTiles();
	rb_register_cocos2dx_TintTo();
	rb_register_cocos2dx_CatmullRomTo();
	rb_register_cocos2dx_TransitionFadeBL();
	rb_register_cocos2dx_TargetedAction();
	rb_register_cocos2dx_DrawNode();
	rb_register_cocos2dx_TransitionTurnOffTiles();
	rb_register_cocos2dx_RotateTo();
	rb_register_cocos2dx_TransitionSplitRows();
	rb_register_cocos2dx_Device();
	rb_register_cocos2dx_TransitionProgressRadialCCW();
	rb_register_cocos2dx_EventListenerFocus();
	rb_register_cocos2dx_TransitionPageTurn();
	rb_register_cocos2dx_BezierBy();
	rb_register_cocos2dx_BezierTo();
	rb_register_cocos2dx_Menu();
	rb_register_cocos2dx_SpriteFrame();
	rb_register_cocos2dx_ActionManager();
	rb_register_cocos2dx_UserDefault();
	rb_register_cocos2dx_TransitionZoomFlipX();
	rb_register_cocos2dx_EventFocus();
	rb_register_cocos2dx_EaseQuinticActionInOut();
	rb_register_cocos2dx_SpriteFrameCache();
	rb_register_cocos2dx_PointLight();
	rb_register_cocos2dx_TransitionCrossFade();
	rb_register_cocos2dx_Ripple3D();
	rb_register_cocos2dx_Lens3D();
	rb_register_cocos2dx_ScaleTo();
	rb_register_cocos2dx_Spawn();
	rb_register_cocos2dx_EaseQuarticActionInOut();
	rb_register_cocos2dx_ShakyTiles3D();
	rb_register_cocos2dx_PageTurn3D();
	rb_register_cocos2dx_Grid3D();
	rb_register_cocos2dx_EaseCircleActionOut();
	rb_register_cocos2dx_TransitionProgressInOut();
	rb_register_cocos2dx_EaseCubicActionInOut();
	rb_register_cocos2dx_EaseBackIn();
	rb_register_cocos2dx_SplitRows();
	rb_register_cocos2dx_Follow();
	rb_register_cocos2dx_Animate();
	rb_register_cocos2dx_ShuffleTiles();
	rb_register_cocos2dx_ProgressTimer();
	rb_register_cocos2dx_ParticleMeteor();
	rb_register_cocos2dx_EaseQuarticActionIn();
	rb_register_cocos2dx_EaseInOut();
	rb_register_cocos2dx_TransitionZoomFlipY();
	rb_register_cocos2dx_ScaleBy();
	rb_register_cocos2dx_EventTouch();
	rb_register_cocos2dx_Animation();
	rb_register_cocos2dx_EaseExponentialIn();
	rb_register_cocos2dx_ReuseGrid();
	rb_register_cocos2dx_EaseQuinticActionOut();
	rb_register_cocos2dx_EventDispatcher();
	rb_register_cocos2dx_MenuItemAtlasFont();
	rb_register_cocos2dx_Liquid();
	rb_register_cocos2dx_OrbitCamera();
	rb_register_cocos2dx_ParallaxNode();
	rb_register_cocos2dx_ClippingRectangleNode();
	rb_register_cocos2dx_EventCustom();
	rb_register_cocos2dx_TransitionFade();
	rb_register_cocos2dx_Component();
	rb_register_cocos2dx_EaseCubicActionOut();
	rb_register_cocos2dx_EventListenerTouchOneByOne();
	rb_register_cocos2dx_ParticleRain();
	rb_register_cocos2dx_Waves();
	rb_register_cocos2dx_EaseOut();
	rb_register_cocos2dx_TransitionSlideInL();
	rb_register_cocos2dx_MenuItemFont();
	rb_register_cocos2dx_TransitionFadeUp();
	rb_register_cocos2dx_EaseSineOut();
	rb_register_cocos2dx_JumpTiles3D();
	rb_register_cocos2dx_MenuItemToggle();
	rb_register_cocos2dx_RemoveSelf();
	rb_register_cocos2dx_SplitCols();
	rb_register_cocos2dx_ProtectedNode();
	rb_register_cocos2dx_MotionStreak();
	rb_register_cocos2dx_RotateBy();
	rb_register_cocos2dx_FileUtils();
	rb_register_cocos2dx_Sprite();
	rb_register_cocos2dx_TransitionSlideInT();
	rb_register_cocos2dx_ProgressTo();
	rb_register_cocos2dx_TransitionProgressOutIn();
	rb_register_cocos2dx_CatmullRomBy();
	rb_register_cocos2dx_Sequence();
	rb_register_cocos2dx_Shaky3D();
	rb_register_cocos2dx_TransitionProgressRadialCW();
	rb_register_cocos2dx_EaseBounceInOut();
	rb_register_cocos2dx_TransitionSlideInR();
	rb_register_cocos2dx_AmbientLight();
	rb_register_cocos2dx_GLProgramCache();
	rb_register_cocos2dx_EaseQuadraticActionIn();
	rb_register_cocos2dx_WavesTiles3D();
	rb_register_cocos2dx_TransitionSlideInB();
	rb_register_cocos2dx_Speed();
	rb_register_cocos2dx_ShatteredTiles3D();
}
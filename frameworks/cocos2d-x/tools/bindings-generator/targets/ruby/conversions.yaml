definitions:
  # the names of the functions - we use this to generate the code and to register the functions in
  # the javascript class
  ifunction: "rb_${generator.prefix}_${class_name}_${func_name}"
  sfunction: "rb_${generator.prefix}_${class_name}_${func_name}"
  constructor: "rb_${generator.prefix}_${class_name}_constructor"
conversions:
  # some times you want to use a special native type when converting from spidermonkey to native
  # the most common case would be from JS-boolean to bool. Using "bool" will fail here since we
  # pass the address to the conversion method, and a JSBool is defined as an integer in spidermonkey
  native_types:
    "@std::vector<std::basic_string.*>.>.>": "std::vector<std::string>"
    "@std::vector<int.*>.>": "std::vector<int>"
    "@cocos2d::Map<std::basic_string.*,": "cocos2d::Map<std::string,"
  ns_map:
    "cocos2d::extension::": "cc."
    "cocos2d::ui::": "ccui."
    "cocos2d::": "cc."
    "spine::": "sp."
    "cocostudio::": "ccs."
    "cocosbuilder::": "cc."
    "CocosDenshion::": "cc."

  to_native:
    # ruby to native
    int: "ok &= rb_value_to_int(${in_value}, (int *)&${out_value})"
    "unsigned int": "ok &= rb_value_to_uint(${in_value}, &${out_value})"
    "unsigned char": "ok &= rb_value_to_uint16(${in_value}, &${out_value})"
    short: "ok &= rb_value_to_int32(${in_value}, &${out_value})"
    "unsigned short": "ok &= rb_value_to_uint32(${in_value}, &${out_value})"
    char: "ok &= rb_value_to_int16(${in_value}, &${out_value})"
    bool: "ok &= rb_value_to_bool(${in_value}, &${out_value})"
    float: "ok &= rb_value_to_float(${in_value}, &${out_value})"
    double: "ok &= rb_value_to_double(${in_value}, &${out_value})"
    long: "ok &= rb_value_to_long(${in_value}, &${out_value})"
    ssize_t: "ok &= rb_value_to_ssize_t(${in_value}, &${out_value})"
    "unsigned long": "ok &= rb_value_to_ulong(${in_value}, &${out_value})"
    #"long long": "ok &= luaval_to_long_long(tolua_S, ${arg_idx},&${out_value})"
    "std::string": "ok &= rb_value_to_std_string(${in_value}, &${out_value})"
    #"String*": "std::string ${out_value}_tmp; ok &= luaval_to_std_string(tolua_S, ${arg_idx}, &${out_value}_tmp); ${out_value} = cocos2d::String::create(${out_value}_tmp)"
    "char*": "std::string ${out_value}_tmp; ok &= rb_value_to_std_string(${in_value}, &${out_value}_tmp); ${out_value} = ${out_value}_tmp.c_str()"
    "Point": "ok &= rb_value_to_ccpoint(${in_value}, &${out_value})"
    "Vec2": "ok &= rb_value_to_vec2(${in_value}, &${out_value})"
    "Vec3": "ok &= rb_value_to_vec3(${in_value}, &${out_value})"
    "Vec4": "ok &= rb_value_to_vec4(${in_value}, &${out_value})"
    "Rect": "ok &= rb_value_to_ccrect(${in_value}, &${out_value})"
    "Size": "ok &= rb_value_to_ccsize(${in_value}, &${out_value})"
    "Color4B": "ok &= rb_value_to_cccolor4b(${in_value}, &${out_value})"
    "Color4F": "ok &= rb_value_to_cccolor4f(${in_value}, &${out_value})"
    "Color3B": "ok &= rb_value_to_cccolor3b(${in_value}, &${out_value})"
    #"PhysicsMaterial": "ok &= luaval_to_physics_material(tolua_S, ${arg_idx}, &${out_value})"
    #"Array*": "ok &= luaval_to_array(tolua_S, ${arg_idx}, &${out_value})"
    #"Dictionary*": "ok &= luaval_to_dictionary(tolua_S, ${arg_idx}, &${out_value})"
    "AffineTransform": "ok &= rb_value_to_ccaffinetransform(${in_value}, &${out_value})"
    "FontDefinition":  "ok &= rb_value_to_FontDefinition(${in_value}, &${out_value})"
    "@Vector<.*>": "ok &= rb_value_to_ccvector(${in_value}, &${out_value})"
    #"@Map<std::basic_string.*>": "ok &= luaval_to_ccmap_string_key(tolua_S, ${arg_idx}, &${out_value})"
    #"Value": "ok &= luaval_to_ccvalue(tolua_S, ${arg_idx}, &${out_value})"
    "ValueMap": "ok &= rb_value_to_ccvaluemap(${in_value}, &${out_value})"
    #"ValueMapIntKey": "ok &= luaval_to_ccvaluemapintkey(tolua_S, ${arg_idx}, &${out_value})"
    #"ValueVector": "ok &= luaval_to_ccvaluevector(tolua_S, ${arg_idx}, &${out_value})"
    #"@vector<std::basic_string.*>": "ok &= luaval_to_std_vector_string(tolua_S, ${arg_idx}, &${out_value})"
    #"@vector<int.*>": "ok &= luaval_to_std_vector_int(tolua_S, ${arg_idx}, &${out_value})"
    #"kmMat4": "ok &= luaval_to_kmMat4(tolua_S, ${arg_idx}, &${out_value})"
    "Mat4": "ok &= rb_value_to_mat4(${in_value}, &${out_value})"
    #"_ttfConfig": "ok &= luaval_to_ttfconfig(tolua_S, ${arg_idx}, &${out_value})"
    #"MeshVertexAttrib": "ok &= luaval_to_mesh_vertex_attrib(tolua_S, ${arg_idx}, &${out_value})"
    #"@vector<float.*>": "ok &= luaval_to_std_vector_float(tolua_S, ${arg_idx}, &${out_value})"
    #"@vector<unsigned short.*>": "ok &= luaval_to_std_vector_ushort(tolua_S, ${arg_idx}, &${out_value})"

    object: "ok &= rb_value_get_ptr(${in_value},&${out_value})"
  from_native:
    # native to ruby
    int: "${out_value} = int_to_rb_value(${in_value})"
    "unsigned int": "${out_value} = uint_to_rb_value(${in_value})"
    "unsigned short": "${out_value} = uint32_to_rb_value(${in_value})"
    "unsigned char": "${out_value} = uint16_to_rb_value(${in_value})"
    #short: "tolua_pushnumber(tolua_S,(lua_Number)${in_value})"
    #char: "tolua_pushnumber(tolua_S,(lua_Number)${in_value})"
    #"long long": "tolua_pushnumber(tolua_S,(lua_Number)${in_value})"
    "std::string": "${out_value} = std_string_to_rb_value(${in_value})"
    "char*": "${out_value} = char_ptr_to_rb_string(${in_value})"
    #"String*": "tolua_pushstring(tolua_S, ${in_value}->getCString())"
    bool: "${out_value} = bool_to_rb_value(${in_value})"
    float: "${out_value} = float_to_rb_value(${in_value})"
    double: "${out_value} = double_to_rb_value(${in_value})"
    long: "${out_value} = long_to_rb_value(${in_value})"
    ssize_t: "${out_value} = int_to_rb_value(${in_value})"
    #"unsigned long": "tolua_pushnumber(tolua_S,(lua_Number)${in_value})"
    "Point": "${out_value} = ccpoint_to_rb_value(${in_value})"
    "Vec2": "${out_value} = vec2_to_rb_value(${in_value})"
    "Vec3": "${out_value} = vec3_to_rb_value(${in_value})"
    "Vec4": "${out_value} = vec4_to_rb_value(${in_value})"
    "Rect": "${out_value} = ccrect_to_rb_value(${in_value})"
    "Size": "${out_value} = ccsize_to_rb_value(${in_value})"
    "Color4B": "${out_value} = cccolor4b_to_rb_value(${in_value})"
    "Color4F": "${out_value} = cccolor4f_to_rb_value(${in_value})"
    "Color3B": "${out_value} = cccolor3b_to_rb_value(${in_value})"
    #"PhysicsMaterial": "physics_material_to_luaval(tolua_S, ${in_value})"
    #"PhysicsContactData*": "physics_contactdata_to_luaval(tolua_S, ${in_value})"
    #"PhysicsRayCastInfo": "physics_raycastinfo_to_luaval(tolua_S, ${in_value})"
    #"Array*": "array_to_luaval(tolua_S,${in_value})"
    #"Dictionary*": "dictionary_to_luaval(tolua_S, ${in_value})"
    "AffineTransform": "${out_value} = ccaffinetransform_to_rb_value(${in_value})"
    "FontDefinition": "${out_value} = FontDefinition_to_rb_value(${in_value})"
    "@Vector<.*>": "${out_value} = ccvector_to_rb_value(${in_value})"
    #"@Map<std::basic_string.*>": "ccmap_string_key_to_luaval(tolua_S, ${in_value})"
    #"Value": "ccvalue_to_luaval(tolua_S, ${in_value})"
    "ValueMap": "${out_value} = ccvaluemap_to_rb_value(${in_value})"
    #"ValueMapIntKey": "ccvaluemapintkey_to_luaval(tolua_S, ${in_value})"
    #"ValueVector": "ccvaluevector_to_luaval(tolua_S, ${in_value})"
    #"@vector<std::basic_string.*>": "ccvector_std_string_to_luaval(tolua_S, ${in_value})"
    #"@vector<int.*>": "ccvector_int_to_luaval(tolua_S, ${in_value})"
    "Mat4": "${out_value} = mat4_to_rb_value(${in_value})"
    #"BlendFunc": "blendfunc_to_luaval(tolua_S, ${in_value})"
    #"_ttfConfig": "ttfconfig_to_luaval(tolua_S, ${in_value})"
    #"MeshVertexAttrib": "mesh_vertex_attrib_to_luaval(tolua_S, ${in_value})"
    #"@vector<float.*>": "ccvector_float_to_luaval(tolua_S, ${in_value})"
    #"@vector<unsigned short.*>": "ccvector_ushort_to_luaval(tolua_S, ${in_value})"
    "FileUtils*": "${out_value} = FileUtils_to_rb_value(${in_value})"
    "Application*": "${out_value} = Application_to_rb_value(${in_value})"
    #"SimpleAudioEngine*": "${out_value} = SimpleAudioEngine_to_rb_value(${in_value})"    
    object:  |
      ${($level + 1) * '\t'}if (${in_value}) {
      ${($level + 2) * '\t'}${out_value} = rbb_get_or_create_value<${ntype.replace("*", "").replace("const ", "")}>((${ntype.replace("const ", "")})${in_value});
      ${($level + 1) * '\t'}} else {
      ${($level + 2) * '\t'}${out_value} = RBNil();
      ${($level + 1) * '\t'}}

